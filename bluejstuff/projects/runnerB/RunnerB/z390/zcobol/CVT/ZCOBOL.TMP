         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/07/08                                                 *
.*********************************************************************
.* 04/09/08 initial coding for global ACCEPT
.*********************************************************************
         ACCEPT &TARGET,&FROM,&SOURCE
         GEN_ACCEPT &TARGET,&FROM,&SOURCE
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/07/08                                                 *
.*********************************************************************
.* 10/28/08 initial coding for global ADD
.* 12/22/08 use ZCGETFLD to get field with qual,base,subscript
.* 02/15/09 support mult s1 added to s2 or mult s1+s2 added to s3
.* 02/26/09 RPI 1012 move onsize end-add pending to add                
.* 08/09/09 RPI 1065 add ACTR for mult operands                        
.*********************************************************************
         ADD   
         COPY  ZC_WS
         :&PARM_IX SETA 2
         :&NP      SETA N'&SYSLIST
         :&TO_IX     SETA 0
         :&GIVING_IX SETA 0
         :&ROUNDED   SETB 0
         :&ONSIZE    SETB 0
         :&LAST_PARM SETA 0
         AWHILE (&PARM_IX LT &NP)
               ACTR 10000
               AIF ('&SYSLIST(&PARM_IX)' EQ 'TO')
                   :&TO_IX SETA &PARM_IX
               AELSEIF ('&SYSLIST(&PARM_IX)' EQ 'GIVING')
                   :&GIVING_IX SETA &PARM_IX
               AELSEIF ('&SYSLIST(&PARM_IX)' EQ 'ROUNDED')
                   :&ROUNDED SETB 1
                   AIF (&LAST_PARM EQ 0)
                       :&LAST_PARM SETA &PARM_IX-1
                   AEND
               AELSEIF ('&SYSLIST(&PARM_IX)' EQ 'ON'                   X
                        AND '&SYSLIST(&PARM_IX+1)' EQ 'SIZE'           X
                        AND '&SYSLIST(&PARM_IX+2)' EQ 'ERROR')
                   :&ONSIZE SETB 1
                   AIF (&LAST_PARM EQ 0)
                       :&LAST_PARM SETA &PARM_IX-1
                   AEND
                   :&PARM_IX SETA &PARM_IX+2
               AELSEIF ('&SYSLIST(&PARM_IX)' EQ 'SIZE'                 X
                        AND '&SYSLIST(&PARM_IX+1)' EQ 'ERROR')
                   :&ONSIZE SETB 1
                   AIF (&LAST_PARM EQ 0)
                       :&LAST_PARM SETA &PARM_IX-1
                   AEND
                   :&PARM_IX SETA &PARM_IX+1
               AEND
               :&PARM_IX SETA &PARM_IX+1
         AEND
         AIF   (&ONSIZE)
               :&IE_LVL  SETA  &IE_LVL+1         ADD PENDING END_ADD
               :&IE_TYPE(&IE_LVL) SETA 11        FOR END_ADD OR PERIOD
               :&ADD_LAB SETA &ADD_LAB+1
               :&IE_TCNT(&IE_LVL) SETA &ADD_LAB
         AEND
         AIF   (&LAST_PARM GT 0)
               :&NP SETA &LAST_PARM
         AEND
         AIF   (&GIVING_IX GT 0)  ADD S1 [+S2] GIVING S3
               ACALL ADD_GIVING
         AELSE
               ACALL ADD_TO
         AEND
         AIF   (&ONSIZE)
               GEN_ONSIZE_START ADD
         AEND
         MEXIT
.*
.* ADD GIVING
.*
         AENTRY ADD_GIVING
         :&S1_PARM_IX SETA 1
         :&S3_PARM_IX SETA &GIVING_IX+1
         :&S1_OK SETB 1
         :&S3_OK SETB 1
         ACALL GET_S1
         ACALL GET_S3
         AWHILE (&S1_OK AND &S3_OK)
               GEN_MOVE &S3,&S3_IX,&S1,&S1_IX
               ACALL GET_S1
               AWHILE (&S1_OK)
                   GEN_ADD  &S3,&S3_IX,&S1,&S1_IX,&ROUNDED,&ONSIZE
                   ACALL GET_S1
               AEND
               ACALL GET_S3
               AIF (&S3_OK)
                   :&S1_PARM_IX SETA 1
                   :&S1_OK SETB 1
                   ACALL GET_S1
               AEND
         AEND
         AEND
.*
.* ADD TO
.*
         AENTRY ADD_TO
         :&S1_PARM_IX SETA 1
         :&S2_PARM_IX SETA &TO_IX+1
         :&S1_OK SETB 1
         :&S2_OK SETB 1
         ACALL GET_S1
         ACALL GET_S2
         AWHILE (&S1_OK AND &S2_OK)
               GEN_ADD  &S2,&S2_IX,&S1,&S1_IX,&ROUNDED,&ONSIZE
               ACALL GET_S1
               AWHILE (&S1_OK)
                   GEN_ADD  &S2,&S2_IX,&S1,&S1_IX,&ROUNDED,&ONSIZE
                   ACALL GET_S1
               AEND
               ACALL GET_S2
               AIF (&S2_OK)
                   :&S1_PARM_IX SETA 1
                   :&S1_OK SETB 1
                   ACALL GET_S1
               AEND
         AEND
         AEND
.*
.* GET S1
.*
         AENTRY GET_S1
         :&PARM_IX SETA &S1_PARM_IX
         AIF   ('&SYSLIST(&PARM_IX)' EQ 'TO')
               AIF (&GIVING_IX GT 0)
                   :&PARM_IX SETA &PARM_IX+1
               AELSE
                   :&S1_OK SETB 0
                   AEXIT AENTRY
               AEND
         AELSEIF (&PARM_IX EQ &GIVING_IX)
               :&S1_OK SETB 0
               AEXIT AENTRY
         AEND
         :&FIELD_REG SETC 'ZC_R1'         S1 IN ZC_R1
         :&FIELD_SS1 SETB 0
         ACALL GET_PARM_FIELD
         :&S1_PARM_IX SETA &PARM_IX
         :&S1    SETC  '&FIELD_NAME'
         :&S1_IX SETA  &FIELD_IX
         AIF   ('&S1' EQ '')
               MNOTE 8,'ADD FIELD1 NOT FOUND'
               MEXIT
         AEND
         AEND
.*
.* GET S2
.*
         AENTRY GET_S2
         :&PARM_IX SETA &S2_PARM_IX
         AIF (&PARM_IX GT &NP)
             :&S2_OK SETB 0
             AEXIT AENTRY
         AEND
         :&FIELD_REG SETC 'ZC_R2'               S2 IN ZC_R2
         :&FIELD_SS1 SETB 0
         ACALL GET_PARM_FIELD
         :&S2_PARM_IX SETA &PARM_IX
         :&S2 SETC '&FIELD_NAME'
         :&S2_IX SETA  &FIELD_IX
         AIF   ('&S2' EQ '')
               MNOTE 8,'ADD FIELD2 NOT FOUND'
               MEXIT
         AEND
         AEND
.*
.* GET S3
.*
         AENTRY GET_S3
         :&PARM_IX SETA &S3_PARM_IX
         AIF (&PARM_IX GT &NP)
             :&S3_OK SETB 0
             AEXIT AENTRY
         AEND
         :&FIELD_REG SETC 'ZC_R3'            S3 IN ZC_R3
         :&FIELD_SS1 SETB 0
         ACALL GET_PARM_FIELD
         :&S3_PARM_IX SETA &PARM_IX
         :&S3 SETC '&FIELD_NAME'
         :&S3_IX SETA  &FIELD_IX
         AIF   ('&S3' EQ '')
               MNOTE 8,'ADD FIELD3 NOT FOUND'
               MEXIT
         AEND
         AEND
         COPY ZCGETFLD
         MEND
         MACRO
.*********************************************************************
.* Copyright 2009 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 08/02/09                                                 *
.*********************************************************************
.* 08/03/09 stub for pending support              
.*********************************************************************
         ALPHABET
         MNOTE 8,'ALPHABET NOT SUPPORTED YET'
         MEXIT
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/16/08                                                 *
.*********************************************************************
.* 04/16/08 initial coding for global ALTER    
.* 09/29/08 ZSTRMAC
.*********************************************************************
.* WARNING: THIS CODE DOES NOT VERIFY THAT THE TARGET IS A GO TO.
.* PLEASE REPLACE USE OF ALTER WITH EVALUATE WHEN STRUCTURE.
.*********************************************************************
         ALTER
         :&NP      SETA  N'&SYSLIST
         :&PARM_IX SETA 1
         AWHILE (&PARM_IX LE &NP-2)
               :&PG_OLD SETC  '&SYSLIST(&PARM_IX)'
               AIF ('&SYSLIST(&PARM_IX+1)' EQ 'OF'                     X
                    OR '&SYSLIST(&PARM_IX+1)' EQ 'IN')
                   :&SN_OLD SETC '&SYSLIST(&PARM_IX+2)'
                   :&PARM_IX SETA &PARM_IX+2
               AELSE 
                   :&SN_OLD SETC ''
               AEND
               AIF ('&SYSLIST(&PARM_IX+1)' EQ 'TO')
                   AIF ('&SYSLIST(&PARM_IX+2)' EQ 'PROCEED'            X         
                        AND '&SYSLIST(&PARM_IX+3)' EQ 'TO')
                        :&PARM_IX SETA &PARM_IX+5
                   AELSE
                        :&PARM_IX SETA &PARM_IX+3
                   AEND
                   :&PG_NEW SETC  '&SYSLIST(&PARM_IX-1)'
                   AIF ('&SYSLIST(&PARM_IX+1)' EQ 'OF'                 X
                        OR '&SYSLIST(&PARM_IX+1)' EQ 'IN')
                       :&SN_NEW SETC '&SYSLIST(&PARM_IX+2)'
                       :&PARM_IX SETA &PARM_IX+2
                   AELSE 
                       :&SN_NEW SETC ''
                   AEND
               AELSE
                   MNOTE 8,'ALTER TO NOT FOUND'
                   MEXIT
               AEND
               GEN_ALTER &PG_OLD,&SN_OLD,&PG_NEW,&SN_NEW
         AEND   
         AIF   (&PARM_IX NE &NP+1)
               MNOTE 8,'ALTER TO OR TO PROCEED TO PARAMETER ERROR'
               MEXIT
         AEND
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/07/08                                                 *
.*********************************************************************
.* 04/07/08 initial coding for z390 target
.*********************************************************************
         AUTHOR &NAME
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/07/08                                                 *
.*********************************************************************
.* 10/14/08 initial coding for global CALL     
.*********************************************************************
         CALL  &PGM,&USING      
         COPY  ZC_WS
         :&NP  SETA N'&SYSLIST
         AIF   (&NP EQ 1)
               GEN_CALL &PGM
               MEXIT
         AEND
         AIF   ('&USING' NE 'USING')
               MNOTE 8,'CALL MISSING USING'
               MEXIT
         AEND
         :&RETURN_IX SETA 0
         :&I SETA 3
         :&PARMS SETC 'USING'
         AWHILE (&I LE &NP)
               AIF ('&SYSLIST(&I)' EQ 'ON'                             X
                 OR '&SYSLIST(&I)' EQ 'NOT'                            X
                 OR '&SYSLIST(&I)' EQ 'OVERFLOW'                       X
                 OR '&SYSLIST(&I)' EQ 'EXCEPTION')
                   MNOTE 8,'CALL ON EXCEPTION/OVERFLOW NOT SUPPORTED'
                   MEXIT
               AELSEIF ('&SYSLIST(&I)' EQ 'RETURNING')
                   :&RETURN_IX SETA &I+1
                   AEXIT AWHILE
               AEND
               :&PARMS SETC '&PARMS,&SYSLIST(&I)'
               :&I SETA &I+1
         AEND
         GEN_CALL &PGM,&PARMS
         AIF (&RETURN_IX GT 0)
               :&PARM_IX SETA &RETURN_IX
               :&FIELD_REG SETC 'ZC_R2'
               :&FIELD_SS1 SETB 1
               ACALL GET_PARM_FIELD
               AIF (&FIELD_IX GT 0)
                   ZC_SYM_FIND RETURN_CODE
                   GEN_MOVE &FIELD_NAME,&FIELD_IX,RETURN_CODE,&SYM_IX
               AELSE
                   MNOTE 8,'CALL RETURNING FIELD NOT FOUND - &FIELD_NAMX
               E'
               AEND
         AEND
         MEXIT
         COPY  ZCGETFLD
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/16/08                                                 *
.*********************************************************************
.* 11/17/08 stub for pending support              
.*********************************************************************
         CANCEL
         MNOTE 8,'CANCEL NOT SUPPORTED YET'
         MEXIT
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/29/08                                                 *
.*********************************************************************
.* 04/29/08 initial coding for global CBL options for MFI compatibility  
.*********************************************************************
         CBL
         COPY ZC_WS
         :&NP SETA N'&SYSLIST
         :&I  SETA 1
         AWHILE (&I LE &NP)
              AIF ('&SYSLIST(&I)' EQ 'CICS')
                  AIF (NOT &ZC_CICS)
                      MNOTE 8,'CBL THIS PROGRAM REQUIRES CICS OPTION'
                  AEND
              AELSEIF (&ZC_WARN)
                  MNOTE 4,'CBL - OPTION IGNORED - &SYSLIST(&I)'
              AEND
              :&I SETA &I+1
         AEND
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/16/08                                                 *
.*********************************************************************
.* 02/25/09 stub for pending support              
.*********************************************************************
         CD
         MNOTE 8,'CD NOT SUPPORTED YET'
         MEXIT
         MEND
         MACRO
.*********************************************************************
.* Copyright 2009 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 08/02/09                                                 *
.*********************************************************************
.* 08/03/09 stub for pending support              
.*********************************************************************
         CLASS    
         MNOTE 8,'CLASS NOT SUPPORTED YET'
         MEXIT
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/14/08                                                 *
.*********************************************************************
.* 04/14/08 initial coding for global ZCOBOL
.* 10/05/08 ZSTRMAC
.*********************************************************************
         CLOSE &FILE
         COPY  ZC_WS
         ZC_FILE_FIND &FILE
         AIF   (&FILE_IX GT 0)
               GEN_CLOSE
         AELSE
               MNOTE 8,'CLOSE FILE NOT FOUND - &FILE'
         AEND
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/16/08                                                 *
.*********************************************************************
.* 02/20/09 initial coding for global COMMUNICATION SECTION
.*********************************************************************
         COMMUNICATION       
         COPY CD.MAC  REPLACE CD INSTRUCTION WITH CD MACRO
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/07/08                                                 *
.*********************************************************************
.* 03/04/09 initial coding for COMPUTE using IF as model
.*********************************************************************
.* Pending work includes support for field,lit,expression in either 
.* first or second operand.  Coming after COMPUTE dubugs GEN_EXP.
.*********************************************************************
         COMPUTE
         COPY  ZC_WS
         :&PARM_IX SETA 2
         AWHILE (&PARM_IX LT N'&SYSLIST                                X
                 AND '&SYSLIST(&PARM_IX)' NE '='                       X
                 AND '&SYSLIST(&PARM_IX)' NE 'EQUAL')
               :&PARM_IX SETA &PARM_IX+1
         AEND
         AIF   (&PARM_IX GT N'&SYSLIST)
               MNOTE 8,'COMPUTE = NOT FOUND'
               MEXIT
         AEND
         :&EXP_PARMS SETC '&SYSLIST(&PARM_IX+1)'
         :&PARM_IX SETA &PARM_IX+2
         AWHILE (&PARM_IX LE N'&SYSLIST                                X
                 AND '&SYSLIST(&PARM_IX)' NE 'ON'                      X
                 AND '&SYSLIST(&PARM_IX)' NE 'NOT') COLLECT EXP PARMS
               :&EXP_PARMS SETC '&EXP_PARMS,&SYSLIST(&PARM_IX)'
               :&PARM_IX SETA &PARM_IX+1
         AEND
         AIF   ('&SYSLIST(&PARM_IX)' EQ 'ON'                           X
                OR '&SYSLIST(&PARM_IX)' EQ 'NOT') ON SIZE/NOT ON SIZE
               MNOTE 8,'COMPUTE ON SIZE NOT SUPPORTED YET'
               MEXIT
         AEND
         :&PARM_IX SETA 1
         :&FIELD_REG SETC 'ZC_R15' NOTE GEN_ADD USES 1, 2, 14 FOR LITS
         :&FIELD_SS1 SETB 1
         ACALL GET_PARM_FIELD                      GET TARGET FIELD
       AIF   (&FIELD_IX GT 0)
         ZC_CALC &FIELD_NAME,&FIELD_IX,&EXP_PARMS  CALC EXP
       AELSE
         MNOTE 8,'COMPUTE TARGET FIELD NOT FOUND - &SYSLIST(1)'
       AEND
         MEXIT
         COPY ZCGETFLD
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/16/08                                                 *
.*********************************************************************
.* 01/02/09 initial coding for gobal CONFIGURATION
.*********************************************************************
         CONFIGURATION            
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/16/08                                                 *
.*********************************************************************
.* 10/28/08 initial coding for CONTINUE no operation.
.*********************************************************************
         CONTINUE                            
         MEND
         MACRO
.*********************************************************************
.* Copyright 2009 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 08/02/09                                                 *
.*********************************************************************
.* 08/03/09 stub for pending support              
.*********************************************************************
         CRT
         MNOTE 8,'CRT NOT SUPPORTED YET'
         MEXIT
         MEND
         MACRO
.*********************************************************************
.* Copyright 2009 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 08/02/09                                                 *
.*********************************************************************
.* 08/03/09 stub for pending support              
.*********************************************************************
         CURRENCY
         MNOTE 8,'CURRENCY NOT SUPPORTED YET'
         MEXIT
         MEND
         MACRO
.*********************************************************************
.* Copyright 2009 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 08/02/09                                                 *
.*********************************************************************
.* 08/03/09 stub for pending support              
.*********************************************************************
         CURSOR  
         MNOTE 8,'CURSOR NOT SUPPORTED YET'
         MEXIT
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author.  Don Higgins                                              *
.* Date   - 04/07/08                                                 *
.*********************************************************************
.* 04/11/08 initial coding for global data division
.* 05/03/08 add DATA END to generate WS list and data definitions
.* 10/05/08 ZSTRMAC
.* 02/25/09 RPI 1002 CREATE USAGE IS INDEX FOR INDEX DATA ITEMS
.* 02/27/09 RPI 1012 GENERATED DEBUG-ITEM AT END OF WS
.*********************************************************************
         DATA  &TYPE
         COPY  ZC_WS
         AIF   ('&TYPE' EQ 'END')   
               ACALL ADD_PREDEFINED_DATA  
         AELSEIF ('&TYPE' NE 'DIVISION')
               MNOTE 8,'DATA UNRECOGNIZED TYPE - &TYPE'
         AEND
         MEXIT
.*
.* ADD PREDEFINED WS AND LK SECTIONS
.*
        AENTRY ADD_PREDEFINED_DATA
        :&FILE_IX SETA 0   END FILE RECORD DEFINITIONS
        AIF    (&LK_MODE)
         WS 01,ZC_LK_END,PIC,X
        AEND       
.*
.* TURN OFF LK LINKAGE SECTION MODE AND RESTORE LAST WS LOC      
.*
        :&LK_MODE SETB 0          TURN OFF LK SECTION IF ON
        AIF    (&LK_SAVE_WS_LOC GT 0)
               :&WS_LOC SETA &LK_SAVE_WS_LOC RESTORE LAST WS LOC FOR PD
        AEND
.*
.* GENERATE INDEX/SUBSCRIPT/LINKAGE POINTERS IN WS
.*
         :&I SETA 1
         AWHILE (&I LE &SET_TOT)
               :&NAME    SETC  '&SET_INDEX(&I)'
               AIF   ('&NAME' EQ '')
                     :&NAME SETC '&SYM_NAME(&SET_SYM_IX(&I))_PTR'
                     WS 77,&NAME,USAGE,POINTER
               AELSE 
                     WS 77,&NAME,USAGE,INDEX                  RPI 1002
                     :&SYM_REF(&SYM_TOT) SETA &SET_SYM_IX(&I) RPI 1002
               AEND
               :&I SETA &I+1
         AEND
.*
.* ADD PREDEFINED WS ITEMS
.*
   WS 01,DEBUG_ITEM
   WS   02,DEBUG_LINE,PIC,X(6)
   WS   02,FILLER,PIC,X,VALUE,SPACE
   WS   02,DEBUG_NAME,PIC,X(30)
   WS   02,FILLER,PIC,X,VALUE,SPACE
   WS   02,DEBUG_SUB_1,PIC,S9999,SIGN,IS,LEADING,SEPARATE,CHARACTER
   WS   02,FILLER,PIC,X,VALUE,SPACE
   WS   02,DEBUG_SUB_2,PIC,S9999,SIGN,IS,LEADING,SEPARATE,CHARACTER
   WS   02,FILLER,PIC,X,VALUE,SPACE
   WS   02,DEBUG_SUB_3,PIC,S9999,SIGN,IS,LEADING,SEPARATE,CHARACTER
   WS   02,FILLER,PIC,X,VALUE,SPACE
   WS   02,DEBUG_CONTENTS,PIC,X(35)
   WS 77,RETURN_CODE,PIC,S9(4),COMP,VALUE,0
           AIF  (&ZC_TRACE)
   WS 77,READY_RESET_TRACE,PIC,X,VALUE,'T'
   WS 77,FILLER,PIC,X(5)
           AEND
.*
.* END OF PREDEFINED DATA (SEE GEN_PROC_END FOR WS/LK GEN)
.*
         AEND
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/29/08                                                 *
.*********************************************************************
.* 04/29/08 initial coding for global DATE-COMPILED
.*********************************************************************
         DATE_COMPILED &DATE                      
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/29/08                                                 *
.*********************************************************************
.* 04/29/08 initial coding for global DATE-WRITTEN
.*********************************************************************
         DATE_WRITTEN &DATE                      
         MEND
         MACRO
.*********************************************************************
.* Copyright 2009 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 08/02/09                                                 *
.*********************************************************************
.* 08/03/09 support DECIMAL-POINT IS COMMA              
.*********************************************************************
         DECIMAL_POINT &IS,&COMMA
         COPY ZC_WS
         AIF   ('&IS' EQ 'IS' AND '&COMMA' EQ 'COMMA')
               :&ZC_DEC_IS_COMMA SETB 1
         AELSE
               MNOTE 8,'DECIMAL-POINT UNKNOWN OPTION - &IS &COMMA'
         AEND
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/16/08                                                 *
.*********************************************************************
.* 02/26/09 stub for pending support              
.*********************************************************************
         DECLARATIVES
         MNOTE 8,'DECLARATIVES NOT SUPPORTED YET'
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/16/08                                                 *
.*********************************************************************
.* 11/17/08 stub for pending support              
.*********************************************************************
         DELETE
         MNOTE 8,'DELETE NOT SUPPORTED YET'
         MEXIT
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/16/08                                                 *
.*********************************************************************
.* 02/20/09 stub for pending support              
.*********************************************************************
         DISABLE
         MNOTE 8,'DISABLE NOT SUPPORTED YET'
         MEXIT
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/07/08                                                 *
.*********************************************************************
.* 04/11/08 initial coding for global DISPLAY 'text' or label
.* 11/19/08 add support for multiple field types using DISPLAY routine
.* 07/25/08 RPI 1065 check for missing parms                             
.*********************************************************************
         DISPLAY 
         :&PARMS SETC '&SYSLIST(1)'
         :&NP    SETA N'&SYSLIST
         AIF   (&NP EQ 0)
               MNOTE 8,'DISPLAY MISSING OPERAND'
               MEXIT
         AEND
         :&I     SETA 2
         AWHILE (&I LE &NP)
               AIF ('&SYSLIST(&I)' NE 'UPON')
                   :&PARMS SETC '&PARMS,&SYSLIST(&I)'
                   :&I SETA &I+1
               AELSE
                   :&I SETA &NP+1
               AEND
         AEND
         GEN_DISPLAY &PARMS 
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This DR code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/07/08                                                 *
.*********************************************************************
.* 10/30/08 initial coding for global MULTIPLY using ADD as model
.* 02/16/09 upgrade using ZCGETFLD to support subscripts and qual.
.* 02/26/09 RPI 1012 move onsize end-add pending to DIVIDE             
.* 07/19/09 RPI 1065 parse both ROUNDED and REMAINING after GIVING     
.* 07/19/09 RPI 1062 correct ON SIZE parsing                           
.*********************************************************************
         DIVIDE  
         COPY  ZC_WS
         :&PARM_IX      SETA 1
         :&FIELD_REG SETC 'ZC_R1'
         :&FIELD_SS1 SETB 0
         ACALL GET_PARM_FIELD
         :&NDR SETC '&FIELD_NAME'                NAME   DIVISOR
         :&XDR SETA &FIELD_IX                    INDEX  DIVISOR
         AIF   (&XDR GT 0)
               :&TDR SETC '&SYM_PIC_TYPE(&XDR)'  TYPE   DIVISOR
               :&LDR SETA &SYM_LEN(&XDR)         LENGTH DIVISOR
               :&SDR SETB &SYM_PIC_SIGN(&XDR)    SIGN   DIVISOR
               :&PDR SETA &SYM_PIC_DEC(&XDR)     DEC-PL DIVISOR
         AELSEIF ('&FIELD_NAME'(1,1) LT '0'                            X
               AND '&FIELD_NAME'(1,1) NE '+'                           X
               AND '&FIELD_NAME'(1,1) NE '-'                           X
               AND '&FIELD_NAME'(1,1) NE '.')
               MNOTE 8,'DIVIDE FIELD NOT DEFINED - &FIELD_NAME'
               MEXIT
         AELSE
               :&TDR SETC ''  DON'T KNOW YET
               :&LDR SETA 0   DON'T KNOW YET
               :&SDR SETB 0   DON'T KNOW YET
               :&PDR SETA 0   DON'T KNOW YET
         AEND
         :&INTO_BY SETC '&SYSLIST(&PARM_IX)'
         AIF   ('&INTO_BY' NE 'INTO' AND '&INTO_BY' NE 'BY') 
               MNOTE 8,'DIVIDE MISSING INTO OR BY'
               MEXIT
         AEND
         :&PARM_IX SETA &PARM_IX+1
         :&FIELD_REG SETC 'ZC_R2'
         :&FIELD_SS1 SETB 0
         ACALL GET_PARM_FIELD                    NAME   DIVIDEND
         :&NDD SETC '&FIELD_NAME'                INDEX  DIVIDEND
         :&XDD SETA &FIELD_IX
         AIF   (&XDD GT 0)                        
               :&TDD SETC '&SYM_PIC_TYPE(&XDD)'  TYPE   DIVIDEND
               :&LDD SETA &SYM_LEN(&XDD)         LENGTH DIVIDEND
               :&SDD SETB &SYM_PIC_SIGN(&XDD)    SIGN   DIVIDEND
               :&PDD SETA &SYM_PIC_DEC(&XDD)     DEC-PL DIVIDEND
         AELSEIF ('&FIELD_NAME'(1,1) LT '0'                            X
               AND '&FIELD_NAME'(1,1) NE '+'                           X
               AND '&FIELD_NAME'(1,1) NE '-'                           X
               AND '&FIELD_NAME'(1,1) NE '.')
               MNOTE 8,'DIVIDE FIELD NOT DEFINED - &FIELD_NAME'
               MEXIT
         AELSE
               :&TDD SETC ''  DON'T KNOW YET
               :&LDD SETA 0   DON'T KNOW YET
               :&SDD SETB 0   DON'T KNOW YET
               :&PDD SETA 0   DON'T KNOW YET
         AEND
         AIF   ('&TDD' EQ '' AND '&TDR' NE '') COPY DR TYPE FOR DD LIT
               :&TDD SETC '&TDR'
               :&LDD SETA &LDR
               :&SDD SETB &SDR
               ACALL SET_LIT_PDD
         AEND
         AIF   ('&TDR' EQ '' AND '&TDD' NE '') COPY DD TYPE FOR DR LIT
               :&TDR SETC '&TDD'
               :&LDR SETA &LDD
               :&SDR SETB &SDD
               ACALL SET_LIT_PDR
         AEND
         AIF   ('&INTO_BY' EQ 'BY')  SWAP DIVIDEND AND DIVIOR
               :&TN  SETC '&NDD'
               :&NDD SETC '&NDR'
               :&NDR SETC '&TN'
               :&TX  SETA &XDD
               :&XDD SETA &XDR
               :&XDR SETA &TX
               :&TT  SETC '&TDD'
               :&TDD SETC '&TDR'
               :&TDR SETC '&TT'
               :&TL  SETA &LDD
               :&LDD SETA &LDR
               :&LDR SETA &TL
               :&TS  SETB &SDD
               :&SDD SETB &SDR
               :&SDR SETB &TS
               :&TP  SETA &PDD
               :&PDD SETA &PDR
               :&PDR SETA &TP
         AEND
         :&NR SETC ''   ASSUME NO REMAINDER STORED
         :&XR SETA 0
         :&TR SETC ''
         :&LR SETA 0
         :&SR SETB 0
         :&PR SETA 0
         AIF   ('&SYSLIST(&PARM_IX)' EQ 'GIVING')
               :&PARM_IX SETA &PARM_IX+1
               ACALL DIVIDE_GIVING
         AELSE                                        
               ACALL DIVIDE_INTO_BY
         AEND
         MEXIT
.*
.* DIVIDE GIVING
.*
         AENTRY DIVIDE_GIVING
         :&FIELD_REG SETC 'ZC_R3'
         :&FIELD_SS1 SETB 0
         ACALL GET_PARM_FIELD                 
         :&NQ SETC '&FIELD_NAME'                 NAME   QUOTIENT 
         :&XQ SETA &FIELD_IX                     INDEX  QUOTIENT
         AIF   (&XQ EQ 0)    
                MNOTE 8,'DIVIDE UNDEFINED QUOTIENT - &NQ'
                MEXIT
         AEND
         :&TQ SETC '&SYM_PIC_TYPE(&XQ)'          TYPE   QUOTIENT
         :&LQ SETA &SYM_LEN(&XQ)                 LENGTH QUOTIENT
         :&SQ SETB &SYM_PIC_SIGN(&XQ)            SIGN   QUOTIENT  
         :&PQ SETA &SYM_PIC_DEC(&XQ)             DEC-PL QUOTIENT 
         AIF ('&TDR' EQ '')   COPY QUOTIENT TYPE IF DIVISOR LIT
             :&TDR SETC '&TQ'
             :&LDR SETA &LQ
             :&SDR SETB &SQ
             ACALL SET_LIT_PDR
         AEND
         AIF ('&TDD' EQ '')   COPY QUOTIENT TYPE IF DIVIDEND LIT
             :&TDD SETC '&TQ'
             :&LDD SETA &LQ
             :&SDD SETB &SQ
             ACALL SET_LIT_PDD
         AEND
         AIF   ('&SYSLIST(&PARM_IX)' EQ 'ROUNDED')  RPI 1062 RND+REM
               :&ROUNDED SETB 1
               :&PARM_IX SETA &PARM_IX+1
         AELSE
               :&ROUNDED SETB 0
         AEND
         AIF   ('&SYSLIST(&PARM_IX)' EQ 'REMAINDER')
               AIF ('&TQ' GE '1' AND '&TQ' LE '9')
                   MNOTE 8,'DIVIDE REMAINDER INVALID FOR HFP, BFP, DFP'
                   MEXIT
               AEND
               :&PARM_IX SETA &PARM_IX+1
               :&FIELD_REG SETC 'ZC_R14'
               :&FIELD_SS1 SETB 0
               ACALL GET_PARM_FIELD                 
               :&NR SETC '&FIELD_NAME'                 NAME   REMAINDER
               :&XR SETA &FIELD_IX                     INDEX  REMAINDER
               AIF   (&XR EQ 0)    
                      MNOTE 8,'DIVIDE UNDEFINED REMAINDER - &NR'
                      MEXIT
               AEND
               :&TR SETC '&SYM_PIC_TYPE(&XR)'          TYPE   REMAINDER
               :&LR SETA &SYM_LEN(&XR)                 LENGTH REMAINDER
               :&SR SETB &SYM_PIC_SIGN(&XR)            SIGN   REMAINDER
               :&PR SETA &SYM_PIC_DEC(&XR)             DEC-PL REMAINDER
         AEND
         ACALL OPTIONS_GEN_DIV_MOVE
         AEND
.*
.* DIVIDE INTO BY - REPLACE ONE OR MORE DIVIDENDS WITH QUOTIENT
.*
         AENTRY DIVIDE_INTO_BY
         AIF   (&XDD EQ 0)
               MNOTE 8,'LITERAL DIVIDEND REQUIRES GIVING'
               MEXIT
         AEND
         :&NQ SETC '&NDD'  STORE QUOTIENT IN DIVIDEND
         :&XQ SETA &XDD                    INDEX  QUOTIENT
         :&TQ SETC '&TDD'                  TYPE   QUOTIENT
         :&LQ SETA &LDD                    LENGTH QUOTIENT
         :&SQ SETB &SDD                    SIGN   QUOTIENT
         :&PQ SETA &PDD                    DEC-PL QUOTIENT
         ACALL OPTIONS_GEN_DIV_MOVE
         AEND
.*
.* OPTIONS GEN DIV MOVE - SET ON SIZE ERROR OPTIONS, GEN DIV, MOVE DUP
.*
         AENTRY OPTIONS_GEN_DIV_MOVE
         :&MOVE_IX SETA &PARM_IX
         ACALL SET_OPTIONS
         ACALL CALL_GEN_DIV
         :&PARM_IX SETA &MOVE_IX
         AWHILE (&PARM_IX LE &LAST_PARM)
               ACTR 4096
               :&FIELD_REG SETC 'ZC_R1'
               :&FIELD_SS1 SETB 1
               ACALL GET_PARM_FIELD                 
               GEN_MOVE &FIELD_NAME,&FIELD_IX,&NQ,&XQ
         AEND
         AEND
.*
.* SET OPTIONS - ROUND AND ON SIZE ERROR
.*
         AENTRY SET_OPTIONS
         :&ROUNDED     SETB 0
         :&ONSIZE     SETB 0
         :&NOT_ONSIZE SETB 0
         :&LAST_PARM   SETA 0
         AWHILE (&PARM_IX LE N'&SYSLIST)
               ACTR 4096
               AIF     ('&SYSLIST(&PARM_IX)' EQ 'ON'                   X
                        AND '&SYSLIST(&PARM_IX+1)' EQ 'SIZE'           X
                        AND '&SYSLIST(&PARM_IX+2)' EQ 'ERROR') RPI 1065
                     :&ONSIZE SETB 1      
                     AIF (&LAST_PARM EQ 0)
                         :&LAST_PARM SETA &PARM_IX-1
                     AEND                              
                     :&PARM_IX SETA N'&SYSLIST+2
               AELSEIF ('&SYSLIST(&PARM_IX)' EQ 'NOT'                  X
                        AND '&SYSLIST(&PARM_IX+1)' EQ 'ON'             X
                        AND '&SYSLIST(&PARM_IX+2)' EQ 'SIZE'           X
                        AND '&SYSLIST(&PARM_IX+3)' EQ 'ERROR') RPI 1065
                     :&NOT_ONSIZE SETB 1                                
                     AIF (&LAST_PARM EQ 0)
                         :&LAST_PARM SETA &PARM_IX-1
                     AEND                              
                     :&PARM_IX SETA N'&SYSLIST+3
               AELSEIF ('&SYSLIST(&PARM_IX)' EQ 'REMAINDER')
                     MNOTE 8,'DIVIDE MULT GIVING WITH REMAINDER ERROR'
                     MEXIT
               AEND 
               :&PARM_IX SETA &PARM_IX+1
         AEND
         AIF (&LAST_PARM EQ 0)
             :&LAST_PARM SETA N'&SYSLIST
         AEND                              
         AIF   (&ONSIZE)
               :&IE_LVL  SETA  &IE_LVL+1         ADD PENDING END_DIV
               :&IE_TYPE(&IE_LVL) SETA 14        FOR END_DIV OR PERIOD
               :&DIV_LAB SETA &DIV_LAB+1
               :&IE_TCNT(&IE_LVL) SETA &DIV_LAB
         AEND
         AEND
.*
.* CALL GEN DIV
.*
         AENTRY CALL_GEN_DIV
         AIF   ('&SYSLIST(&PARM_IX)' EQ 'ROUNDED')
               :&ROUNDED SETB 1
               :&PARM_IX SETA &PARM_IX+1
         AELSE
               :&ROUNDED SETB 0
         AEND
       GEN_DIV &NDD,&TDD,&LDD,&PDD, DIVIDEND  NAME/LIT,TYPE,LEN,PLACES X                  
               &NDR,&TDR,&LDR,&PDR, DIVISOR   NAME/LIT,TYPE,LEN,PLACES X                  
               &NQ,&TQ,&LQ,&SQ,&PQ, QUOTIENT  NAME,TYPE,LEN,SIGN,PLCS  X                  
               &NR,&TR,&LR,&SR,&PR, REMAINDER NAME,TYPE,LEN,SIGN,PLCS  X
               &ROUNDED,       1 IF ROUNDED SPECIFIED                  X
               &ONSIZE,       1 IF ON SIZE SPECIFIED                   X
               &NOT_ONSIZE    1 IF NOT_ONSIZE SPECIFIED                  
         AEND
.*
.* SET LIT LDD=0 AND PDD
.*
         AENTRY SET_LIT_PDD
         :&LDD SETA 0
         :&DP SETA ('&NDD' INDEX '.')
         AIF  (&DP GT 0)
              :&PDD SETA K'&NDD-&DP
         AELSE
              :&PDD SETA 0
         AEND
         AEND
.*
.* SET LIT LDR=0 AND PDR
.*
         AENTRY SET_LIT_PDR
         :&LDR SETA 0
         :&DP SETA ('&NDR' INDEX '.')
         AIF  (&DP GT 0)
              :&PDR SETA K'&NDR-&DP
         AELSE
              :&PDR SETA 0
         AEND
         AEND
         COPY ZCGETFLD
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/15/08                                                 *
.*********************************************************************
.* 06/13/08 compiler directive ignored for now                           
.*********************************************************************
         EJECT    
         MEND

         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/07/08                                                 *
.*********************************************************************
.* 04/09/08 initial coding for global ELSE
.* 10/05/08 ZSTRMAC
.*********************************************************************
         ELSE    
         COPY  ZC_WS
         AIF   (N'&SYSLIST GT 0)
               MNOTE 8,'ELSE - UNDEFINED VERB - &SYSLIST(1)'
         AEND
         AIF   (&IE_LVL LT 1)      
               MNOTE 8,'ELSE MISSING IF'
               MEXIT
         AEND
         AIF   (&IE_TYPE(&IE_LVL) NE 1)  
               MNOTE 8,'ELSE MISSING IF'
               MEXIT
         AEND
         AWHILE (&IE_ELSE(&IE_LVL))       
               AIF (&IE_LVL GT 1)
                   END_IF
               AELSE
                   MNOTE 8,'ELSE DUPLICATE FOR SAME IF'
                   MEXIT
               AEND
         AEND
         GEN_B IF_&IE_TCNT(&IE_LVL)._E
         :&IE_ELSE(&IE_LVL) SETB 1
         GEN_LABEL IF_&IE_TCNT(&IE_LVL)_&IE_BCNT(&IE_LVL),ELSE
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/16/08                                                 *
.*********************************************************************
.* 02/20/09 stub for pending support              
.*********************************************************************
         ENABLE
         MNOTE 8,'ENABLE NOT SUPPORTED YET'
         MEXIT
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/15/08                                                 *
.*********************************************************************
.* 01/11/09 initial coding                              
.*********************************************************************
         END_ADD    
         COPY  ZC_WS
         AIF   (&IE_LVL LT 1)       
               MEXIT
         AEND
         AIF   (&IE_TYPE(&IE_LVL) EQ 11) IS THERE ON SIZE/ERROR
               GEN_LABEL ADD_&IE_TCNT(&IE_LVL),END_ADD
               :&IE_LVL  SETA  &IE_LVL-1
         AEND
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/16/08                                                 *
.*********************************************************************
.* 02/26/09 stub for pending support              
.*********************************************************************
         END_DECLARATIVES
         MNOTE 8,'END_DECLARATIVES NOT SUPPORTED YET'
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/15/08                                                 *
.*********************************************************************
.* 01/11/09 initial coding                              
.*********************************************************************
         END_DIVIDE    
         COPY  ZC_WS
         AIF   (&IE_LVL LT 1)       
               MEXIT
         AEND
         AIF   (&IE_TYPE(&IE_LVL) EQ 14) IS THERE ON SIZE/ERROR
               GEN_LABEL DIVIDE_&IE_TCNT(&IE_LVL),END_DIVIDE
               :&IE_LVL  SETA  &IE_LVL-1
         AEND
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* All rights reserved                                               *      
.* Author - Don Higgins                                              *
.* Date   - 04/07/08                                                 *
.*********************************************************************
.* 04/09/08 initial coding for global END_EVALUATE
.* 10/05/08 ZSTRMAC
.*********************************************************************
         END_EVALUATE    
         COPY  ZC_WS
         AIF   (&IE_LVL LT 1)      
               MNOTE 8,'END-EVALUATE MISSING EVALUATE'
               MEXIT
         AEND
         AIF   (&IE_TYPE(&IE_LVL) NE 2)    
               MNOTE 8,'END-EVALUATE MISSING EVALUATE'
               MNOTE 8,'END-EVALUATE MISSING EVALUATE'
         AEND
         :&NEXT_WHEN SETA  &IE_WHEN(&IE_LVL)+1
         GEN_LABEL EVAL&IE_EVAL(&IE_LVL)._WHEN&NEXT_WHEN,END_WHEN
         GEN_LABEL EVAL&IE_EVAL(&IE_LVL)._END,END_EVALUATE
         :&IE_LVL  SETA &IE_LVL-1
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/07/08                                                 *
.*********************************************************************
.* 04/09/08 initial coding for global END_IF
.* 10/05/08 ZSTRMAC
.*********************************************************************
         END_IF    
         COPY  ZC_WS
         AIF   (&IE_LVL LT 1)      
               MNOTE 8,'END_IF MISSING IF'
               MEXIT
         AEND
         AIF   (&IE_ELSE(&IE_LVL))
               GEN_LABEL IF_&IE_TCNT(&IE_LVL)_E,END_IF
         AELSE
               GEN_LABEL IF_&IE_TCNT(&IE_LVL)_&IE_BCNT(&IE_lVL),END_IF
         AEND
         :&IE_LVL  SETA  &IE_LVL-1
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/15/08                                                 *
.*********************************************************************
.* 01/11/09 initial coding                              
.*********************************************************************
         END_MULTIPLY
         COPY  ZC_WS
         AIF   (&IE_LVL LT 1)       
               MEXIT
         AEND
         AIF   (&IE_TYPE(&IE_LVL) EQ 13) IS THERE ON SIZE/ERROR
               GEN_LABEL MULTIPLY_&IE_TCNT(&IE_LVL),END_MULTIPLY
               :&IE_LVL  SETA  &IE_LVL-1
         AEND
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/07/08                                                 *
.*********************************************************************
.* 11/26/08 initial coding for global END_PERFORM
.*********************************************************************
         END_PERFORM    
         COPY  ZC_WS
         AIF   (&IE_LVL LT 1)      
               MEXIT
         AEND
         AIF   (&IE_TYPE(&IE_LVL) NE 4)
               MEXIT
         AEND
         GEN_B &IE_PM_LAB(&IE_LVL)
         GEN_LABEL PM_&IE_TCNT(&IE_LVL)_E,END_PERFORM
         :&IE_LVL  SETA  &IE_LVL-1
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/15/08                                                 *
.*********************************************************************
.* 04/15/08 initial coding for global END_READ to termainate AT END
.* 10/05/08 ZSTRMAC
.*********************************************************************
         END_READ    
         COPY  ZC_WS
         AIF   (&IE_LVL LT 1)       
               MNOTE 8,'END_READ MISSING READ'
               MEXIT
         AEND
         AIF   (&IE_TYPE(&IE_LVL) NE 3)     
               MNOTE 8,'END-READ INVALID TYPE - &IE_TYPE(&IE_LVL)'
               MEXIT
         AEND
         GEN_LABEL &FILE_NAME(&FILE_IX)._END_READ&IE_TCNT(&IE_LVL),END_X
               READ
         :&IE_LVL  SETA  &IE_LVL-1
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/15/08                                                 *
.*********************************************************************
.* 01/11/09 initial coding                              
.*********************************************************************
         END_SUBTRACT    
         COPY  ZC_WS
         AIF   (&IE_LVL LT 1)       
               MEXIT
         AEND
         AIF   (&IE_TYPE(&IE_LVL) EQ 12) IS THERE ON SIZE/ERROR
               GEN_LABEL SUBTRACT_&IE_TCNT(&IE_LVL),END_SUBTRACT
               :&IE_LVL  SETA  &IE_LVL-1
         AEND
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/16/08                                                 *
.*********************************************************************
.* 11/17/08 stub for pending support              
.*********************************************************************
         ENTRY
         MNOTE 8,'ENTRY NOT SUPPORTED YET'
         MEXIT
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/07/08                                                 *
.*********************************************************************
.* 04/07/08 initial coding for z390 target
.* 10/05/08 ZSTRMAC
.*********************************************************************
         ENVIRONMENT &DIV
         AIF   ('&DIV' NE 'DIVISION')
               MNOTE 4,'ENVIRONMENT - MISSING "DIVISION"'
         AEND
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/07/08                                                 *
.*********************************************************************
.* 04/09/08 initial coding for global EVALUATE
.* 10/05/08 ZSTRMAC
.*********************************************************************
         EVALUATE &SYM   
         COPY  ZC_WS
         ZC_SYM_FIND &SYM
         AIF   (&SYM_IX GT 0)
               :&IE_LVL  SETA  &IE_LVL+1
               :&IE_TYPE(&IE_LVL) SETA 2
               :&EVAL_LAB SETA  &EVAL_LAB+1 
               :&IE_EVAL(&IE_LVL) SETA &EVAL_LAB
               :&IE_WHEN(&IE_LVL) SETA 0
               :&IE_EVAL_IX(&IE_LVL) SETA &SYM_IX
         AELSE
               MNOTE 8,'EVALUATE VARIABLE NOT FOUND - &SYM'
         AEND
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/16/08                                                 *
.*********************************************************************
.* 12/13/08 stub for pending support              
.*********************************************************************
         EXAMINE
         MNOTE 8,'EXAMINE REPLACED BY INSPECT'
         MEXIT
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/16/08                                                 *
.*********************************************************************
.* 12/13/08 stub for pending support              
.*********************************************************************
         EXHIBIT
         MNOTE 8,'EXHIBIT REPLACED BY DISPLAY'
         MEXIT
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/15/08                                                 *
.*********************************************************************
.* 06/13/08 generate perform paragraph exit check                       
.* 10/28/08 add support for EXIT PROGRAM                               
.*********************************************************************
         EXIT  &PGM
       AIF   ('&PGM' EQ 'PROGRAM')
         GEN_STOP RUN
       AEND
         MEND

        MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/07/08                                                 *
.*********************************************************************
.* 04/07/08 initial coding for global FD definition
.* 10/06/08 ZSTRMAC
.*********************************************************************
.* Generate file definition using file data from SELECT in ZC_FD.CPY
.*********************************************************************
         FD    &FILE
         COPY  ZC_WS
         ZC_FILE_FIND &FILE
         AIF   (&FILE_IX EQ 0)      
               MNOTE 8,'FD FILE NAME NOT FOUND - &FILE'
               MEXIT
         AEND
         :&PARM_IX SETA 2
         AIF   ('&SYSLIST(&PARM_IX)' EQ 'IS')
               :&PARM_IX SETA &PARM_IX+1
         AEND
         AIF ('&SYSPARM(&PARM_IX)' EQ 'EXTERNAL')
             :&EXTERNAL SETB 1
             :&PARM_IX SETA &PARM_IX+1
         AELSEIF ('&SYSPARM(&PARM_IX)' EQ 'GLOBAL')
             :&GLOBAL SETB 1
             :&PARM_IX SETA &PARM_IX+1
         AEND
.*
.* PROCESS FD OPTIONS IN ANY ORDER
.*
       AWHILE  ('&SYSLIST(&PARM_IX)' NE '')
         AIF   ('&SYSLIST(&PARM_IX)' EQ 'DATA')
               :&PARM_IX SETA &PARM_IX+1
               AIF ('&SYSLIST(&PARM_IX)' EQ 'RECORD'                   X
                 OR '&SYSLIST(&PARM_IX)' EQ 'RECORDS')
                   :&PARM_IX SETA &PARM_IX+1
                   AIF ('&SYSLIST(&PARM_IX)' EQ 'IS'                   X
                     OR '&SYSLIST(&PARM_IX)' EQ 'ARE')   
                       :&PARM_IX SETA &PARM_IX+1
                   AEND
               AELSE
                   MNOTE 8,'FD UNKNOWN DATA PARM - &SYSLIST(&PARM_IX)'
                   :&PARM_IX SETA N'&SYSLIST+1
               AEND   
               :&FILE_RECORD(&FILE_IX) SETC '&SYSLIST(&PARM_IX)'
               :&PARM_IX SETA &PARM_IX+1 
         AELSEIF ('&SYSLIST(&PARM_IX)' EQ 'BLOCK')
              :&PARM_IX SETA &PARM_IX+1
              AIF ('&SYSLIST(&PARM_IX)' EQ 'CONTAINS')
                  :&PARM_IX SETA &PARM_IX+1
              AEND
              :&FILE_BLKSI2(&PARM_IX) SETC '&SYSLIST(&PARM_IX)'
              :&PARM_IX SETA &PARM_IX+1
              AIF ('&SYSLIST(&PARM_IX)' EQ 'TO')
                  :&FILE_BLKSI1(&PARM_IX) SETC '&FILE_BLKSI2(&PARM_IX)'
                  :&FILE_BLKSI2(&PARM_IX) SETC '&SYSLIST(&PARM_IX+1)'
                  :&PARM_IX SETA &PARM_IX+2
              AEND
              AIF ('&SYSLIST(&PARM_IX)' EQ 'CHARACTERS')
                  :&PARM_IX SETA &PARM_IX+1
              AEND
              AIF ('&SYSLIST(&PARM_IX)' EQ 'RECORDS')
                  :&FILE_BLOCK_RECS(&PARM_IX) SETB 1
                  :&PARM_IX SETA &PARM_IX+1
              AEND
         AELSEIF ('&SYSLIST(&PARM_IX)' EQ 'RECORD')
              :&PARM_IX SETA &PARM_IX+1
              AIF ('&SYSLIST(&PARM_IX)' EQ 'CONTAINS')
                  :&PARM_IX SETA &PARM_IX+1
              AELSE
                  AIF ('&SYSLIST(&PARM_IX)' EQ 'IS')
                      :&PARM_IX SETA &PARM_IX+1
                  AEND
                  AIF ('&SYSLIST(&PARM_IX)' EQ 'VARYING')
                      :&PARM_IX SETA &PARM_IX+1
                      AIF ('&SYSLIST(&PARM_IX)' EQ 'IN')
                          :&PARM_IX SETA &PARM_IX+1
                      AEND
                      AIF ('&SYSLIST(&PARM_IX)' EQ 'SIZE')
                          :&PARM_IX SETA &PARM_IX+1
                      AEND
                      AIF ('&SYSLIST(&PARM_IX)' EQ 'FROM')
                          :&PARM_IX SETA &PARM_IX+1
                      AEND
                  AEND
              AEND
              :&FILE_LRECL2(&PARM_IX) SETC '&SYSLIST(&PARM_IX)'
              :&PARM_IX SETA &PARM_IX+1
              AIF ('&SYSLIST(&PARM_IX)' EQ 'TO')
                  :&FILE_LRECL1(&PARM_IX) SETC '&FILE_LRECL2(&PARM_IX)'
                  :&FILE_LRECL2(&PARM_IX) SETC '&SYSLIST(&PARM_IX+1)'
                  :&PARM_IX SETA &PARM_IX+2
              AEND
              AIF ('&SYSLIST(&PARM_IX)' EQ 'CHARACTERS')
                  :&PARM_IX SETA &PARM_IX+1
              AEND
              AIF ('&SYSLIST(&PARM_IX)' EQ 'DEPENDING')
                  :&PARM_IX SETA &PARM_IX+1
                  AIF ('&SYSLIST(&PARM_IX)' EQ 'ON')
                      :&PARM_IX SETA &PARM_IX+1
                  AEND
                  :&FILE_DEPENDING(&PARM_IX) SETC '&SYSLIST(&PARM_IX)'
                  :&PARM_IX SETA &PARM_IX+1
              AEND
         AELSEIF ('&SYSLIST(&PARM_IX)' EQ 'LABEL')
              :&PARM_IX SETA &PARM_IX+1
              AIF ('&SYSLIST(&PARM_IX)' EQ 'RECORD')
                  :&PARM_IX SETA &PARM_IX+1
              AEND
              AIF ('&SYSLIST(&PARM_IX)' EQ 'RECORDS')
                  :&PARM_IX SETA &PARM_IX+1
              AEND
              AIF ('&SYSLIST(&PARM_IX)' EQ 'IS')
                  :&PARM_IX SETA &PARM_IX+1
              AEND
              AIF ('&SYSLIST(&PARM_IX)' EQ 'ARE')
                  :&PARM_IX SETA &PARM_IX+1
              AEND
              AIF ('&SYSLIST(&PARM_IX)' EQ 'STANDARD')
                  :&PARM_IX SETA &PARM_IX+1
              AEND
              AIF ('&SYSLIST(&PARM_IX)' EQ 'OMITTED')
                  :&PARM_IX SETA &PARM_IX+1
              AEND
         AELSE
              MNOTE 8,'FD OPTION NOT SUPPORTED - &SYSLIST(&PARM_IX)'
              :&PARM_IX SETA N'&SYSLIST+1
         AEND 
       AEND
         WS    91,&FILE                         ADD FILE TO WS 
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/14/08                                                 *
.*********************************************************************
.* 04/14/08 initial coding for global ZCOBOL
.* 10/06/08 ZSTRMAC
.*********************************************************************
         FILE  &SECTION
         AIF   ('&SECTION' NE 'SECTION')
               MNOTE 8,'FILE SECTION MISSING'
         AEND
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/14/08                                                 *
.*********************************************************************
.* 04/14/08 initial coding for global ZCOBOL
.*********************************************************************
         FILE_CONTROL
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/16/08                                                 *
.*********************************************************************
.* 02/20/09 stub for pending support              
.*********************************************************************
         GENERATE
         MNOTE 8,'GENERATE NOT SUPPORTED YET'
         MEXIT
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/16/08                                                 *
.*********************************************************************
.* 04/16/08 initial coding for global GO TO    
.* 10/06/08 ZSTRMAC
.* 08/05/09 RPI 1065 add support for SN-PG paragraph names
.* 08/16/09 RPI 1065 support GO TO without target as model for ALTER
.*          see OBNC1M NIST test.
.*********************************************************************
         GO                                  
         COPY  ZC_WS
         :&NP  SETA  N'&SYSLIST
         :&PARM_IX   SETA  1
         AIF   ('&SYSLIST(&PARM_IX)' EQ 'TO')
               :&PARM_IX SETA  &PARM_IX+1
         AEND
         AIF   (&NP EQ 1)                          RPI 1065
               GEN_B  &LAST_PG_NAME,&LAST_SN_NAME  MODEL FOR ALTER
               MEXIT
         AEND
         :&FIRST SETA &PARM_IX                      RPI 1065
         AIF   ('&SYSLIST(&PARM_IX+1)' EQ 'OF'                         X
               OR '&SYSLIST(&PARM_IX+1)' EQ 'IN')
               :&SN_NAME SETC '&SYSLIST(&PARM_IX+2)'
               :&PG_NAME SETC '&SYSLIST(&PARM_IX)'
               :&PARM_IX SETA &PARM_IX+3
         AELSE
               :&SN_NAME SETC ''
               :&PG_NAME SETC '&SYSLIST(&PARM_IX)'
               :&PARM_IX SETA &PARM_IX+1
         AEND  
         AIF   (&NP LT &PARM_IX)
               GEN_B  &PG_NAME,&SN_NAME
         AELSE
               :&GO_LIST SETC '&SYSLIST(&FIRST)'     RPI 1065
               :&PARM_IX SETA &FIRST+1               RPI 1065
               AWHILE (&PARM_IX LT &NP-2                               X
                      AND '&SYSLIST(&PARM_IX)' NE 'DEPENDING')
                   :&GO_LIST SETC '&GO_LIST,&SYSLIST(&PARM_IX)'
                   :&PARM_IX SETA &PARM_IX+1
               AEND
               AIF  ('&SYSLIST(&PARM_IX)' EQ 'DEPENDING')              X
                    AND '&SYSLIST(&PARM_IX+1)' EQ 'ON')
                    :&PARM_IX SETA &PARM_IX+2
                    :&FIELD_REG SETC 'ZC_R2'
                    :&FIELD_SS1 SETB 0
                    ACALL GET_PARM_FIELD
                    AIF (&FIELD_IX GT 0)
                        GEN_GO_DEPEND &GO_LIST
                    AELSE
                        MNOTE 8,'GO TO DEPENDING VAR NOT FOUND - &FIELDX
               _NAME'
                    AEND
               AELSE
                    MNOTE 8,'GO TO DEPENDING CLAUSE NOT FOUND'
               AEND      
         AEND
         COPY ZCGETFLD
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/07/08                                                 *
.*********************************************************************
.* 04/11/08 initial coding for global GOBACK
.*********************************************************************
         GOBACK
         GEN_GOBACK
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/07/08                                                 *
.*********************************************************************
.* 04/07/08 initial coding for global IDENTIFY
.* 10/06/08 ZSTRMAC
.*********************************************************************
         IDENTIFICATION &DIV
         AIF   ('&DIV' NE 'DIVISION')      
               MNOTE 4,'IDENTIFICATION - MISSING "DIVISION"'
         AEND
         MEND
        MACRO                                                       
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/07/08                                                 *
.*********************************************************************
.* 04/09/08 initial coding for global IF
.* 05/01/08 add support for IF A NOT = B
.* 10/06/08 ZSTRMAC
.* 10/12/08 USE PUSH/POP CONDITION AND LOGICAL OPERATOR STACKS
.*          TO PARSE COMPLEX IF WITH PRECEDENCE (NOT, AND, OR)
.*          AND GENERATE INTERMEDIATE CODE IN TABLE FOR OPTIMIZATION
.*          PRIOR TO CODE GENERATION MACROS GEN_COMP AND GEN_BC
.* 01/05/09 add support for omitted subject+verb in condition test
.*          used in NIST EXEC85.CBL.  Test added to TESTIF1.CBL.
.* 02/22/09 RPI 1001 add support for conditional 88 value tests
.* 02/26/09 RPI 1012 issue MNOTE if first field not found for compare
.* 04/21/09 RPI 1020 correct support for mult OR for same test field 
.* 06/14/09 RPI 1057 use ZC_DFHRESP.CPY and ZC_DFHVALUE.CPY sync AZ390
.*          and correct missing SQ in GET_DFH routines 
.* 06/18/09 RPI 1042 add ZCDFHLIT shared by IF and MOVE               
.* 08/09/09 RPI 1065 allow omitting subject and relation for AND OR   
.* 08/14/09 RPI 1065 optimize mult OR's using same end target if true   
.* 08/15/09 RPI 1065 detect and issue MNOTE for expressions for   
.*********************************************************************
.* Pending work includes support for field,lit,expression in either 
.* first or second operand.  Coming after COMPUTE dubugs GEN_EXP.
.*********************************************************************
         IF    
         COPY  ZC_WS
         :&ZC_ERROR SETB 0 CLEAR ANY GEN_COMP ERRORS
         :&LAST_VAR SETB 0 WAS LAST VAR A FIELD OR LIT 
.*
.* PUSH/POP COND INDEX AND LOGICAL OPERATOR STACKS FOR PARSING
.*
         LCLA  &STK_CD_TOT  CUR TOTAL CD/IOP IX'S ON STACK
         LCLA  &STK_CD(10)  IX TO CD PARM # OR -IOP RESULT #
         LCLA  &STK_OP_TOT  CUR TOTAL OP ON STACK
         LCLA  &STK_OP(10)  OP (1=NOT,2=AND,3=OR,4='(')
         LCLA  &LAST_CD_PARM_IX LAST CD PTR ON STK FOR OMITTED SUB/VERB
         LCLC  &FIELD1,&FIELD2
         LCLA  &FIELD1_IX,&FIELD2_IX
.*
.* GENERATED INTERMEDIATE OPCODE TABLE
.*
         LCLA  &IOP_TOT        TOTAL INTERMEDIATE LOG. OPS
         LCLA  &IOP_OP(50)     LOG. OPER. (1=NOT,2=AND,3=OR)
         LCLA  &IOP_CD1(50)     CONDITION1 +PARM IX OR -LOP IX
         LCLA  &IOP_CD2(50)     CONDITION2 +PARM IX OR -LOP IX
         LCLB  &IOP_TF(50)     SAVE IOP TRUE/FALSE I**N IOP_TF#
         LCLA  &IOP_OR_END(50) OPTIMIZE MULT OR USING SAME END TARGET
         LCLB  &V88_MULT       FLAG FOR GENERATING LABEL FOR MUL 88'S
.*
.* SET IF/EVAL LVL AND EXIT_LAB #
.*
         :&IE_LVL  SETA  &IE_LVL+1          IF LEVEL
         :&IE_TYPE(&IE_LVL) SETA 1          IF VS EVALUATE
         :&IF_CNT SETA &IF_CNT+1            UNIQUE IF COUNTER 
         :&IE_TCNT(&IE_LVL) SETA &IF_CNT
         :&IE_BCNT(&IE_LVL) SETA 1          CUR BLOCK COUNT WITHIN IF
         :&IE_NEXT(&IE_LVL) SETA 1          CUR EXIT BLOCK
         :&IE_ELSE(&IE_LVL) SETB 0          RESET ELSE FLAG
.*
.* BUILD IOP LIST WITH BACKWARD REF UPDATE AND THEN GEN CODE
.*
         ACALL IOP_BUILD      BUILD IOP TABLE
.*  ACALL LIST_IOPS   DEBUG
         ACALL IOP_OPT_OR     OPTIMIZE MULT OR'S
         ACALL IOP_GEN_CODE   GEN CODE FROM IOP TABLE
         MEXIT
.*
.* BUILD IOP TABLE USING BNF CD AND LOP STAKS
.*   1.  PUSH +CONDITION PARM PTRS AND -IOP PTRS      ON CD_STK
.*   2.  PUSH LOGICAL OPERATORS '(',NOT, AND, OR,')'  ON OP_STK 
.*   3.  POP  OP AND 1 OR 2 CD'S TO GEN NEXT IOP 
.*       WHEN LOP PRECEDENCE OR AT END 
.*
         AENTRY IOP_BUILD
         :&NP   SETA  N'&SYSLIST  TOTAL IF PARMS
         AIF (&NP GT 0)
             AIF ('&SYSLIST(&NP)' EQ 'THEN')
                 :&NP SETA &NP-1  IGNORE THEN
             AEND
         AEND
         :&LVL  SETA  0           CUR (..) LEVEL WITHIN IF PARMS
         :&CD_PARM_TOT SETA 0     CUR CONDITION PARM COUNT (A EQ B ETC)
         :&STK_CD_TOT SETA 0      RESET CONDITION TEST/IOP RESULT STACK
         :&STK_OP_TOT SETA 0      RESET LOGICAL IOP OPERATOR STACK
         :&PARM_IX SETA  0        GET PARM INDEX
         :&PREV_PARM SETC ''      PREV PARM
         :&PARM SETC ''           CUR  PARM
         :&SKIP_SIX_OR_LIT SETB 0  SKIP SUBSCRIPTS IN CD'S
         ACALL  GET_PARM           GET NEXT PARM OR ''
         AWHILE ('&PARM' NE '')
               AIF ('&PARM' EQ '''(''')
                   :&LAST_VAR SETB 0
                   AIF ('&PREV_PARM' EQ 'DFHRESP'                      X
                        OR '&PREV_PARM' EQ 'DFHVALUE')  
                        AIF ('&SYSLIST(&PARM_IX+2' EQ ''')''')
                            :&PARM_IX SETA &PARM_IX+2 SKIP (,VALUE,)
                        AELSE
                            MNOTE 8,'IF INVALID DFHRESP/DFHVALUE'
                            MEXIT
                        AEND
                   AELSE            
                        :&LVL SETA &LVL+1
                        :&IOP SETA 4
                        ACALL PUSH_OP      PUSH OP 4=(
                   AEND     
               AELSEIF ('&PARM' EQ ''')''')
                   :&LAST_VAR SETB 0
                   :&LVL SETA &LVL-1
                   AIF (&STK_OP_TOT GT 0) 
                       :&LOOP_NE_4 SETB 1  RPI 1065
                       AWHILE (&STK_OP_TOT GT 0 AND &LOOP_NE_4)
                         AIF (&STK_OP(&STK_OP_TOT) NE 4) FLUSH (..)
                           ACALL POP_OP
                           ACASE (&IOP)
                           AWHEN 1
                               ACALL IOP_ADD_NOT
                           AWHEN 2
                               ACALL IOP_ADD_AND
                           AWHEN 3
                               ACALL IOP_ADD_OR
                           AELSE
                               MNOTE 8,'IF UNKNOWN OP STACK VALUE &OP'
                               MEXIT
                           AEND
                         AELSE
                           :&LOOP_NE_4 SETB 0
                         AEND
                       AEND
                       ACALL POP_OP  REMOVE ( FOR MATCHING )
                   AELSE
                       MNOTE 8,'IF UNBALANCED (..)'
                       MEXIT
                   AEND     
               AELSEIF ('&PARM' EQ 'NOT')
                   :&LAST_VAR SETB 0
                   AIF  (&CD_PARM_TOT EQ 0)
                        :&IOP SETA 1
                        ACALL PUSH_OP  PUSH LOC OPER NOT
                   AEND
               AELSEIF  ('&PARM' EQ 'AND') FLUSH PRIOR NOT/AND OPS
                   :&LAST_VAR SETB 0
                   :&LAST_STK_OP_TOT SETA &STK_OP_TOT+1
                   AWHILE (&STK_OP_TOT LT &LAST_STK_OP_TOT             X
                           AND &STK_OP_TOT GT 0) 
                       :&LAST_STK_OP_TOT SETA &STK_OP_TOT
                       AIF (&STK_OP(&STK_OP_TOT) EQ 1)
                           ACALL POP_OP
                           ACALL IOP_ADD_NOT
                       AELSEIF (&STK_OP(&STK_OP_TOT) EQ 2)
                           ACALL POP_OP
                           ACALL IOP_ADD_AND
                       AEND
                   AEND
                   :&IOP SETA 2
                   ACALL PUSH_OP
               AELSEIF  ('&PARM' EQ 'OR')                               
                   :&LAST_VAR SETB 0
                   :&LAST_STK_OP_TOT SETA &STK_OP_TOT+1
                   AWHILE (&STK_OP_TOT LT &LAST_STK_OP_TOT             X
                           AND &STK_OP_TOT GT 0) 
                       :&LAST_STK_OP_TOT SETA &STK_OP_TOT
                       AIF (&STK_OP(&STK_OP_TOT) EQ 1)
                           ACALL POP_OP
                           ACALL IOP_ADD_NOT
                       AELSEIF (&STK_OP(&STK_OP_TOT) EQ 2)
                           ACALL POP_OP
                           ACALL IOP_ADD_AND
                       AELSEIF (&STK_OP(&STK_OP_TOT) EQ 3)
                           ACALL POP_OP
                           ACALL IOP_ADD_OR
                       AEND
                   AEND
                   :&IOP SETA 3
                   ACALL PUSH_OP
               AELSEIF ('&PARM' EQ 'FUNCTION')
                   :&LAST_VAR SETB 1
                   MNOTE 8,'IF FUNCTION NOT SUPPORTED YET'
                   MEXIT
               AELSE
                   :&EXP_OP SETA ('&PARM' FIND '+-*/')
                   AIF (&LAST_VAR AND &EXP_OP GT 0)
                       MNOTE 8,'IF EXPRESSIONS NOT SUPPORTED YET'
                       MEXIT
                   AEND
                   AIF ('&PARM'(1,1) GE '0')
                       :&LAST_VAR SETB 1
                   AELSEIF ('&PARM' FIND '_') GT 0)
                       :&LAST_VAR SETB 1
                   AELSEIF ('&PARM' FIND '=<>' GT 0)
                       :&LAST_VAR SETB 0
                   AELSE
                       GBLB &(ZCKW_&PARM)
                       AIF (&(ZCKW_&PARM))   IS THIS KEY WORK VS VAR
                           :&LAST_VAR SETB 0    YES, NOT VAR
                       AELSE
                           :&LAST_VAR SETB 1    NO, ASSUME VAR
                       AEND
                   AEND
                   AIF  (&CD_PARM_TOT EQ 0) 
                        :&CD_IOP_IX SETA &PARM_IX
                        ACALL PUSH_CD    PUSH 1ST CD PARM PTR ON CD_STK
                   AEND
                   :&CD_PARM_TOT SETA &CD_PARM_TOT+1 SKIP CD NAME/QUAL
                   :&SKIP_SIX_OR_LIT SETB 1
               AEND
               ACALL GET_PARM
               AIF  (&SKIP_SIX_OR_LIT) SKIP SUBSCRIPTS IN CD'S
                    :&SKIP_SIX_OR_LIT SETB 0
                    AWHILE ('&PARM' EQ '''(''') SKIP SIX AND RMOD 
                        ACALL GET_PARM
                        AWHILE ('&PARM' NE '' AND '&PARM' NE ''')''')
                            ACALL GET_PARM
                        AEND
                        AIF ('&PARM' NE '')
                            ACALL GET_PARM
                        AEND
                    AEND
               AEND 
         AEND
.*
.* FLUSH REMAINING OPS IF ANY AT END OR PARMS
.*
         AWHILE (&STK_OP_TOT GT 0)
              ACALL POP_OP
              ACASE (&IOP)
              AWHEN 1
                  ACALL IOP_ADD_NOT
              AWHEN 2
                  ACALL IOP_ADD_AND
              AWHEN 3
                  ACALL IOP_ADD_OR
              AELSE
                  MNOTE 8,'IF UNKNOWN OP ON STACK AT END &IOP'
                  ACALL LIST_IOPS
                  MEXIT
              AEND
         AEND
         AEND
.*
.* OPTIMIZE MULTIPLE OR'S BY SETTING TRUE TARGET TO END OF LAST OR
.* AND DON'T GEN TF FLAG
.*
         AENTRY IOP_OPT_OR
         :&J SETA &IOP_TOT
         AWHILE (&J GT 1)
             AIF (&IOP_OP(&J) EQ 3) IS THIS OP = OR
                 :&L SETA &J   LAST OR END TARGET
                 :&K SETA &J-1
                 AWHILE (&K GT 0)
                     AIF (&IOP_OP(&K) EQ 3                             X
                          AND (&IOP_CD1(&J) EQ -&K                     X
                               OR &IOP_CD2(&J) EQ -K)) 
                         :&IOP_OR_END(&K) SETA &L  USE SAME END TARGET
                         :&IOP_TF(&K) SETB 0       AND TURN OFF T/F
                         :&J SETA &K
                         :&K SETA &K-1
                     AELSE
                         :&K SETA 0
                     AEND
                 AEND
             AEND
             :&J SETA &J-1
         AEND
         AEND
.*
.* GEN CODE FROM IOPS
.*
         AENTRY IOP_GEN_CODE
.*
.* GEN SINGLE CD FROM STACK IF NO IOPS
.*
         AIF   (&STK_CD_TOT EQ 1)
               AIF   (&IOP_TOT EQ 0)
                     :&CD_PARM_IX SETA &STK_CD(1)
                     :&CD_PREV_PARM SETC ''
                     :&I SETA 1
                     ACALL IOP_GEN_CD
                     GEN_BC   15-&CCT,IF_&IE_TCNT(&IE_LVL)_&IE_BCNT(&IEX
               _LVL)
                     AIF   (&V88_MULT)
                           :&V88_MULT SETB 0
                           GEN_LABEL IF_&IE_TCNT(&IE_LVL)_IOP_&I
                     AEND
                     MEXIT
               AEND
         AELSE
               MNOTE 8,'IF CONDITION STACK COUNT ERROR &STK_CD_TOT'
               ACALL LIST_IOPS
               MEXIT
         AEND
.*
.* GEN CODE FROM IOP TABLE WITH MULTIPLE ENTRIES
.*
         :&I   SETA 1
         AWHILE (&I LE &IOP_TOT)
               ACASE (&IOP_OP(&I))
               AWHEN 1  NOT
                   ACALL IOP_GEN_NOT
               AWHEN 2  AND
                   ACALL IOP_GEN_AND
               AWHEN 3  OR
                   ACALL IOP_GEN_OR
               AELSE
                   MNOTE 8,'IF IOP INVALID OPCODE &IOP_OP(&I)'
               AEND
               :&I SETA &I+1
         AEND
         AIF   (&V88_MULT)
               :&V88_MULT SETB 0
               GEN_LABEL IF_&IE_TCNT(&IE_LVL)_IOP_&I
         AEND
         AEND
.*
.* IOP ADD NOT
.*
         AENTRY IOP_ADD_NOT
         :&IOP_TOT SETA &IOP_TOT+1
         :&IOP_OP(&IOP_TOT) SETA 1     NOT
         ACALL POP_CD_IOP_IX
         :&IOP_CD1(&IOP_TOT) SETA &CD_IOP_IX
         :&CD_IOP_IX SETA -&IOP_TOT
         ACALL PUSH_CD
         AEND
.*
.* IOP ADD AND
.*
         AENTRY IOP_ADD_AND
         :&IOP_TOT SETA &IOP_TOT+1
         :&IOP_OP(&IOP_TOT) SETA 2     AND
         ACALL POP_CD_IOP_IX
         :&IOP_CD2(&IOP_TOT) SETA &CD_IOP_IX
         ACALL POP_CD_IOP_IX
         :&IOP_CD1(&IOP_TOT) SETA &CD_IOP_IX
         :&CD_IOP_IX SETA -&IOP_TOT
         ACALL PUSH_CD
         AEND
.*
.* IOP ADD OR
.*
         AENTRY IOP_ADD_OR
         :&IOP_TOT SETA &IOP_TOT+1
         :&IOP_OP(&IOP_TOT) SETA 3     OR
         ACALL POP_CD_IOP_IX
         :&IOP_CD2(&IOP_TOT) SETA &CD_IOP_IX
         ACALL POP_CD_IOP_IX
         :&IOP_CD1(&IOP_TOT) SETA &CD_IOP_IX
         :&CD_IOP_IX SETA -&IOP_TOT
         ACALL PUSH_CD
         AEND
.*
.* POP CD/IOP AND SET CD_IOP_IX TO CD/IOP IX FROM TOP OF STK_CD 
.* AND SET IOP_TF REQUIRED FOR IOP REF'S
.*
         AENTRY POP_CD_IOP_IX
         AIF  (&STK_CD_TOT GT 0)
              :&CD_IOP_IX SETA &STK_CD(&STK_CD_TOT)  +CD OR -IOP IX
              :&STK_CD_TOT SETA &STK_CD_TOT-1
              AIF (&CD_IOP_IX LE 0)
                  :&J SETA -&CD_IOP_IX
                  AIF (&J GT 0)
                      AIF (NOT &IOP_TF(&J))
                          :&IOP_TF(&J) SETB 1 REQ T/F SAVE FOR IOP REF
                      AELSE
                          MNOTE 8,'IF IOP &J HAS DUP IOP T/F REF'
                          CALL LIST_IOPS
                          MEXIT
                      AEND
                  AELSE
                      MNOTE 8,'IF CD/IOP STACK PTR 0'
                      CALL LIST_IOPS
                      MEXIT
                  AEND
              AEND
         AELSE
              MNOTE 8,'IF MISSING CD STACK PTR FOR NOT'
              CALL LIST_IOPS
              MEXIT
         AEND
         AEND
.*
.* IOP GEN NOT
.*
         AENTRY IOP_GEN_NOT
         AIF   (&IOP_CD1(&I) GT 0)
               :&CD_PARM_IX SETA &IOP_CD1(&I)
               :&CD_PREV_PARM SETC ''
               ACALL IOP_GEN_CD   GEN CONDITION CODE
         AELSE
               :&IOP SETA -&IOP_CD1(&I)
               AIF  (&IOP GT 0)
                    GEN_COMP_BYTE ZCVT_WORKAREA+&IOP,1  RPI 1065
                    :&CCT SETC 'ZC_EQ'      IS IOP T/F CC TRUE
               AELSE
                    MNOTE 8,'IF IOP &I MISSING CD1'
                    ACALL LIST_IOPS
                    MEXIT
               AEND
         AEND
         AIF   (&IOP_TF(&I))         SAVE NOT IOP T/F FOR IOP REF.
               AIF (&I GT &MAX_IOP_TF)
                   :&MAX_IOP_TF SETA &I
               AEND
               GEN_MOVE_BYTE ZCVT_WORKAREA+&I,0  ASSUME NOT CCT FALSE
               GEN_BC &CCT,IF_&IE_TCNT(&IE_LVL)._IOP&I CONT 
               GEN_MOVE_BYTE ZCVT_WORKAREA+&I,1  SET (NOT CCT) TRUE
               GEN_LABEL IF_&IE_TCNT(&IE_LVL)._IOP&I,IF_IOP_NOT
         AELSE                         EXIT IF NOT CCT
               GEN_BC &CCT,IF_&IE_TCNT(&IE_LVL)_&IE_BCNT(&IE_LVL)
         AEND
         AEND
.*
.* IOP GEN AND
.*
         AENTRY IOP_GEN_AND
         AIF   (&IOP_CD1(&I) GT 0)
               :&CD_PARM_IX SETA &IOP_CD1(&I)
               :&CD_PREV_PARM SETC ''
               ACALL IOP_GEN_CD   GEN CONDITION CODE
         AELSE
               :&IOP SETA -&IOP_CD1(&I)
               AIF  (&IOP GT 0)
                    GEN_COMP_BYTE ZCVT_WORKAREA+&IOP,1  
                    :&CCT SETC 'ZC_EQ'      IS IOP T/F CC TRUE
               AELSE
                    MNOTE 8,'IF IOP &I MISSING CD1'
                    ACALL LIST_IOPS
                    MEXIT
               AEND
         AEND
         AIF   (&IOP_TF(&I))         SAVE T/F FOR AND
               GEN_MOVE_BYTE ZCVT_WORKAREA+&I,0   ASSUME FALSE
               GEN_BC 15-&CCT,IF_&IE_TCNT(&IE_LVL)_IOP&I CD1>F
         AELSE                          EXIT IF FALSE
               GEN_BC 15-&CCT,IF_&IE_TCNT(&IE_LVL)_&IE_BCNT(&IE_LVL)
         AEND
         AIF   (&IOP_CD2(&I) GT 0)
               :&CD_PARM_IX SETA &IOP_CD2(&I)
               :&CD_PREV_PARM SETC ''
               ACALL IOP_GEN_CD   GEN CONDITION CODE
         AELSE
               :&IOP SETA -&IOP_CD2(&I)
               AIF  (&IOP GT 0)
                    GEN_COMP_BYTE ZCVT_WORKAREA+&IOP,1  
                    :&CCT SETC 'ZC_EQ'      IS IOP T/F CC TRUE
               AELSE
                    MNOTE 8,'IF IOP &I MISSING CD2'
                    ACALL LIST_IOPS
                    MEXIT
               AEND
         AEND
         AIF   (&IOP_TF(&I))         SAVE T/F FOR IOP REF
               AIF (&I GT &MAX_IOP_TF)
                   :&MAX_IOP_TF SETA &I
               AEND
               GEN_BC 15-&CCT,IF_&IE_TCNT(&IE_LVL)_IOP&I CD2>F
               GEN_MOVE_BYTE ZCVT_WORKAREA+&I,1     CD1 AND CD2 > T
               GEN_LABEL IF_&IE_TCNT(&IE_LVL)_IOP&I,IF_IOP_AND
         AELSE                               EXIT IF CD2 FALSE
               GEN_BC 15-&CCT,IF_&IE_TCNT(&IE_LVL)_&IE_BCNT(&IE_LVL)
         AEND
         AEND
.*
.* IOP GEN OR
.*
         AENTRY IOP_GEN_OR
         :&GEN_CD SETB 1
         AIF   (&IOP_CD1(&I) GT 0)
               :&CD_PARM_IX SETA &IOP_CD1(&I)
               :&CD_PREV_PARM SETC ''
               ACALL IOP_GEN_CD                GEN COND FROM CD1
         AELSE
               :&IOP SETA -&IOP_CD1(&I)     GEN COMD FROM T/F
               AIF  (&IOP GT 0)
                    AIF (&IOP EQ &I-1)
                        :&GEN_CD SETB 0
                    AELSE
                        GEN_COMP_BYTE ZCVT_WORKAREA+&IOP,1  
                        :&CCT SETC 'ZC_EQ'      IS IOP COND TRUE
                    AEND
               AELSE
                    MNOTE 8,'IF IOP &I MISSING CD1'
                    ACALL LIST_IOPS
                    MEXIT
               AEND
         AEND
         AIF   (&IOP_TF(&I))                SAVE T/F FOR OR 
               AIF (&I GT &MAX_IOP_TF)
                   :&MAX_IOP_TF SETA &I
               AEND
               GEN_MOVE_BYTE ZCVT_WORKAREA+&I,1   ASSUME TRUE 
         AEND
         AIF   (&GEN_CD)
               AIF (&IOP_OR_END(&I) GT 0)
                   GEN_BC &CCT,IF_&IE_TCNT(&IE_LVL)_IOP&IOP_OR_END(&I).X
               _T   USE OPTIIMIZED TRUE TARGET 
               AELSE
                   GEN_BC &CCT,IF_&IE_TCNT(&IE_LVL)_IOP&I._T 
               AEND
         AEND
         :&GEN_CD SETB 1
         AIF   (&IOP_CD2(&I) GT 0)
               :&CD_PARM_IX SETA &IOP_CD2(&I)
               :&CD_PREV_PARM SETC ''
               ACALL IOP_GEN_CD             GEN COMP FROM CD2
         AELSE
               :&IOP SETA -&IOP_CD2(&I)     GEN COMP FROM T/F
               AIF  (&IOP GT 0)
                    AIF (&IOP EQ &I-1)
                        :&GEN_CD SETB 0
                    AELSE
                        GEN_COMP_BYTE ZCVT_WORKAREA+&IOP,1  
                        :&CCT SETC 'ZC_EQ'      IS IOP COND TRUE
                    AEND
               AELSE
                    MNOTE 8,'IF IOP &I MISSING CD2'
                    ACALL LIST_IOPS
                    MEXIT
               AEND
         AEND
         AIF   (&IOP_TF(&I))         SAVE T/F FOR AND
               GEN_BC &CCT,IF_&IE_TCNT(&IE_LVL)_IOP&I._T CD2 TRUE
               GEN_MOVE_BYTE ZCVT_WORKAREA+&I,0     CD1 OR CD2 > F
         AEND                       EXIT IF FALSE
         AIF   (&IOP_OR_END(&I) GT 0)     USE OPTIMIZED OR END TARGET
               GEN_BC &CCT,IF_&IE_TCNT(&IE_LVL)_IOP&IOP_OR_END(&I)._T 
         AELSE
               GEN_BC 15-&CCT,IF_&IE_TCNT(&IE_LVL)_&IE_BCNT(&IE_LVL)
         AEND
         AIF (&IOP_OR_END(&I) EQ 0)
             GEN_LABEL IF_&IE_TCNT(&IE_LVL)_IOP&I._T,IF_IOP_OR_TRUE
         AEND
         AEND
.*
.* PUSH COND - PUSH CD_IOP_IX (INDEX OF FIRST CD PARM OR -IOP INDEX)
.*         
         AENTRY PUSH_CD
         :&STK_CD_TOT SETA &STK_CD_TOT+1
         :&STK_CD(&STK_CD_TOT) SETA &CD_IOP_IX
         AIF   (&CD_IOP_IX GT 0) RPI 1065
         AEND
         AEND
.*
.* PUSH OP - PUSH LOGICAL OPERATOR 1=NOT, 2=AND, 3=OR, 4=(
.*
         AENTRY PUSH_OP
         :&CD_PARM_TOT SETA 0             RESET CD PARM COUNTER AT LOP
         :&STK_OP_TOT SETA &STK_OP_TOT+1
         :&STK_OP(&STK_OP_TOT) SETA &IOP
         AEND           
.*
.* POP OP - POP LOGICAL OPERATOR NOT, AND, OR, '''('''
.*
         AENTRY POP_OP
         AIF   (&STK_OP_TOT GE 1)
               :&IOP SETA   &STK_OP(&STK_OP_TOT)
               :&STK_OP_TOT SETA &STK_OP_TOT-1
         AELSE
               MNOTE 8,'IF POP OP ERROR - EMPTY STACK'
         AEND           
         AEND
.*
.* IOP GEN CD - GEN CODE FOR CONDITION TEST STARTING AT CD_PARM_IX 
.*
.*  CD_PARM_IX - INPUT STARTING PARM INDEX
.*  CCT        - SET   CONDITION CODE TEST TRUE (EQ,NE,LT,GT,LE,GE)
.*  Notes:
.*   1.  IF SUBJECT AND/OR RELATION OMITTED, USE LAST CD SUBJECT/REL                        
.*
         AENTRY IOP_GEN_CD
         :&SAVE_FIRST_CD_PARM_IX SETA &CD_PARM_IX        
         :&CD_PARM_IX SETA &CD_PARM_IX-1          
         :&FIELD_SS1 SETB 1
         ACALL  GET_CD_PARM
         AIF   (&FIELD_88_IX GT 0)
               :&LAST_CD_PARM_IX SETA 0        
               ACALL IOP_GEN_88
               AEXIT AENTRY
         AELSEIF (&FIELD_IX GT 0)  COULD BE FIELD1 OR FIELD2
               :&FIELD1 SETC '&FIELD_NAME'
               :&FIELD1_IX SETA &FIELD_IX
               :&FIELD_SS1 SETB 0
               ACALL GET_CD_PARM
               ACALL SET_CCT
               AIF ('&CCT' EQ '')  AND/OR FIELD2 (OMITTED FIELD1,REL) 
                   ACALL RESET_SS1
                   :&FIELD2 SETC '&FIELD_NAME'
                   :&FIELD2_IX SETA &FIELD_IX
                   ACALL SET_OMITTED_FIELD1
                   ACALL SET_OMITTED_CCT
               AELSE
                   :&LAST_CD_PARM_IX SETA &SAVE_FIRST_CD_PARM_IX              
                   ACALL GET_FIELD2  AND/OR FIELD1,REL,FIELD2 
               AEND
         AELSE
               :&CD_PARM_IX SETA &SAVE_FIRST_CD_PARM_IX               
               ACALL SET_CCT
               ACALL RESET_SS1               RPI 1065 
               AIF ('&CCT' EQ '') NOT REL SO ASSUME FIELD2 LIT
                   :&FIELD2 SETC '&FIELD_NAME'
                   :&FIELD2_IX SETA &FIELD_IX
                   ACALL SET_OMITTED_FIELD1
                   ACALL SET_OMITTED_CCT   AND/OR LIT (OMIT FLD1,REL)
               AELSE
                   :&FIELD_SS1 SETB 0
                   ACALL  GET_CD_PARM
                   :&FIELD2 SETC '&FIELD_NAME'
                   :&FIELD2_IX SETA &FIELD_IX
                   ACALL SET_OMITTED_FIELD1 AND/OR REL,FLD2 (OMIT FLD1)
               AEND    
         AEND
.*
.* GEN COMP OF FIELD1 AND FIELD2
.*
         AIF  (&FIELD2_IX GT 0)
              AIF  (&SYM_LVL(&FIELD2_IX) EQ 88)
                   GEN_COMP &SYM_NAME(&SYM_REF(&FIELD2_IX)),&FIELD2_IX,X
               &SYM_VAL(&FIELD2_IX),0
              AELSE
                   GEN_COMP &FIELD1,&FIELD1_IX,&FIELD2,&FIELD2_IX
              AEND
              AIF (&ZC_ERROR)  RPI 1065
                  MEXIT
              AEND
         AELSE
             ACALL GEN_CD_COMP_LIT
         AEND
         ACALL GET_CD_PARM
         AEND
.*
.* SET OMITTED CCT
.*
         AENTRY SET_OMITTED_CCT
         :&CD_PARM_IX SETA &CD_CCT_IX 
         :&PARM       SETC '&SYSLIST(&CD_CCT_IX)' 
         ACALL SET_CCT
         :&CD_PARM_IX SETA &SAVE_CUR_CD_IX RETURN TO CUR PARMS
         AEND
.*
.* SET CCT IF RELATION FOUND ELSE CCT NULL AND CD_PARM_IX UNCHANGED
.*
         AENTRY SET_CCT
         :&CCT SETC ''     ASSUME RELATION NOT FOUND
         :&TESTCLS SETB 0  ASSUME NOT CLASS TEST
         AIF ('&PARM' EQ 'IS')
             ACALL GET_CD_PARM
         AEND
         AIF   ('&PARM' EQ 'NOT')
               ACALL GET_CD_PARM
               AIF   ('&PARM' EQ '='                                   X
                      OR '&PARM' EQ 'EQUAL'                            X            
                      OR '&PARM' EQ 'EQUALS')            
                   :&CCT    SETC 'ZC_NE'
               AELSEIF ('&PARM' EQ '<'                                 X
                        OR '&PARM' EQ 'LESS')
                   :&CCT    SETC 'ZC_GE'
               AELSEIF   ('&PARM' EQ '>'                               X
                          OR '&PARM' EQ 'GREATER')
                   :&CCT    SETC 'ZC_LE'
               AELSEIF ('&PARM' EQ '<=')     RPI 1065
                   :&CCT    SETC 'ZC_GT'
               AELSEIF   ('&PARM' EQ '>=')   RPI 1065
                   :&CCT    SETC 'ZC_LT'
               AELSEIF   ('&PARM' EQ 'SPACES'                          X
                          OR '&PARM' EQ 'SPACE'                        X
                          OR '&PARM' EQ 'ZERO'                         X
                          OR '&PARM' EQ 'ZEROS'                        X
                          OR '&PARM' EQ 'ZEROES'                       X
                          OR '&PARM' EQ 'LOW-VALUES'                   X
                          OR '&PARM' EQ 'LOW-VALUE'                    X
                          OR '&PARM' EQ 'HIGH-VALUES'                  X
                          OR '&PARM' EQ 'HIGH-VALUE'                   X
                          OR '&PARM' EQ 'NUMERIC'                      X
                          OR '&PARM' EQ 'ALPHABETIC'                   X
                          OR '&PARM' EQ 'ALPHANUMERIC')           
                   :&TESTCLS SETB 1
                   :&CCT    SETC 'ZC_NE'
               AELSE
                   MNOTE 8,'IF OPERAND UNKNOWN - &PARM'
                   MEXIT
               AEND
         AELSE
               AIF   ('&PARM' EQ '='                                   X
                      OR '&PARM' EQ 'EQUAL'                            X            
                      OR '&PARM' EQ 'EQUALS')       
                     :&CCT    SETC 'ZC_EQ'
               AELSEIF   ('&PARM' EQ '<'                               X       
                          OR '&PARM' EQ 'LESS')       
                     :&CCT    SETC 'ZC_L'              
               AELSEIF   ('&PARM' EQ '>'                               X       
                          OR '&PARM' EQ 'GREATER')        
                     :&CCT    SETC 'ZC_H'
               AELSEIF ('&PARM' EQ '<=')     RPI 1065
                   :&CCT    SETC 'ZC_LE'
               AELSEIF   ('&PARM' EQ '>=')   RPI 1065
                   :&CCT    SETC 'ZC_GE'
               AELSEIF   ('&PARM' EQ 'SPACES'                          X
                          OR '&PARM' EQ 'SPACE'                        X
                          OR '&PARM' EQ 'ZERO'                         X
                          OR '&PARM' EQ 'ZEROS'                        X
                          OR '&PARM' EQ 'ZEROES'                       X
                          OR '&PARM' EQ 'LOW-VALUES'                   X
                          OR '&PARM' EQ 'LOW-VALUE'                    X
                          OR '&PARM' EQ 'HIGH-VALUES'                  X
                          OR '&PARM' EQ 'HIGH-VALUE'                   X
                          OR '&PARM' EQ 'NUMERIC'                      X
                          OR '&PARM' EQ 'ALPHABETIC'                   X
                          OR '&PARM' EQ 'ALPHANUMERIC')           
                   :&TESTCLS SETB 1
                   :&CCT    SETC 'ZC_EQ'
               AEND
         AEND
         AIF  ('&CCT' NE '')
              AIF  (NOT &TESTCLS)
                   ACALL GET_CD_PARM
              AEND
              AIF  ('&PARM' EQ 'THAN')
                   ACALL GET_CD_PARM 
              AEND        
              AIF  ('&PARM' EQ 'TO')
                   ACALL GET_CD_PARM
              AEND
         AEND
         AEND
.*
.* SET OMITTED FIELD1
.*
         AENTRY SET_OMITTED_FIELD1
         AIF (&LAST_CD_PARM_IX GT 0)
             :&SAVE_CUR_CD_IX SETA &CD_PARM_IX
             :&CD_PARM_IX SETA &LAST_CD_PARM_IX-1                     
             ACALL GET_CD_PARM   GET LAST FIELD1
             AIF (&FIELD_IX EQ 0)
                 MNOTE 8,'IF LAST FIELD1 NOT FOUND - &FIELD_NAME'
                 MEXIT
             AEND
             :&FIELD1 SETC '&FIELD_NAME'
             :&FIELD1_IX SETA &FIELD_IX
             ACALL GET_CD_PARM
             :&CD_CCT_IX SETA &CD_PARM_IX SAVE FOR OMITTED CCT 
             :&CD_PARM_IX SETA &SAVE_CUR_CD_IX RETURN TO CUR PARMS
         AELSE
             MNOTE 8,'IF LAST CD PARM IX FOR FIELD1 NOT FOUND'
             MEXIT
         AEND
         AEND
.*
.* GET FIELD2
.*
         AENTRY GET_FIELD2
         AIF (&FIELD_IX GT 0)
             ACALL RESET_SS1               RPI 1065 
             :&FIELD2 SETC '&FIELD_NAME'
             :&FIELD2_IX SETA &FIELD_IX
         AELSE
             :&FIELD2 SETC '&PARM'
             :&FIELD2_IX SETA 0
         AEND
         AEND
.*
.* GEN COMP LIT
.*
         AENTRY GEN_CD_COMP_LIT
         AIF ('&PARM' EQ 'DFHRESP')
             :&DFHRESP SETC '&SYSLIST(&CD_PARM_IX+2)'
             ACALL GET_DFHRESP
             GEN_COMP &FIELD1,&FIELD1_IX,&DFHLIT,0
         AELSEIF ('&PARM' EQ 'DFHVALUE')
             :&DFHVALUE SETC '&SYSLIST(&CD_PARM_IX+2)'
             ACALL GET_DFHVALUE
             GEN_COMP &FIELD1,&FIELD1_IX,&DFHLIT,0
         AELSE
             GEN_COMP &FIELD1,&FIELD1_IX,&FIELD2,&FIELD2_IX
         AEND
         AIF (&ZC_ERROR)  RPI 1065
             MEXIT
         AEND
         AEND
.*
.*
.* IOP GEN 88 - GEN 1 OR MORE CONDITION 88 LEVEL COMPARES
.*
         AENTRY IOP_GEN_88
         :&FIELD1    SETC '&FIELD_NAME'
         :&FIELD1_IX SETA &FIELD_IX
         :&V88_IX    SETA &SYM_LOC(&FIELD_88_IX)  FIRST VALUE INDEX
         :&V88_MULT  SETB 0                       ASSUME NOT MULT
         :&CCT SETC 'ZC_EQ'       NO  THEN EQ = OK
         AWHILE (&V88_IX GT 0)
               GEN_COMP &FIELD1,&FIELD1_IX,&V88_VAL(&V88_IX),0
               AIF (&ZC_ERROR)  RPI 1065
                   MEXIT
               AEND
               :&V88_IX SETA &V88_NEXT(&V88_IX)
               AIF (&V88_IX GT 0)
                   AIF (&IOP_OP(&I) NE 1)
                       AIF (NOT &V88_MULT)
                           :&V88_MULT SETB 1
                       AEND
                       GEN_BC &CCT,IF_&IE_TCNT(&IE_LVL)_IOP_&I
                   AELSE
                       GEN_BC &CCT,IF_&IE_TCNT(&IE_LVL)_&IE_BCNT(&IE_LVX
               L)
                   AEND
               AEND
         AEND
         AEND
.*
.* GET NEXT IF PARM (SUBSTITUTE DFHRESP(CODE) WITH LITERAL VALUE)
.*
         AENTRY GET_PARM
         :&PREV_PARM SETC '&PARM'
         :&PARM_IX SETA &PARM_IX+1
         AIF (&PARM_IX LE &NP)
             :&PARM SETC '&SYSLIST(&PARM_IX)'     
         AELSE
             AIF (&LVL NE 0)
                 MNOTE 8,'IF UNBALANCED (...)'
             AEND
             :&PARM SETC ''
         AEND
         AEND
.*
.* GET CD PARM USING CD_PARM_IX UNTIL NEXT LOG OP                                
.*
         AENTRY GET_CD_PARM
         :&PREV_PARM SETC '&PARM'
         :&CD_PARM_IX SETA &CD_PARM_IX+1
         AIF   (&CD_PARM_IX GE 1 AND &CD_PARM_IX LE &NP)
               :&PARM SETC '&SYSLIST(&CD_PARM_IX)'
               AIF ('&PARM' EQ '''('''                                 X
                    OR '&PARM' EQ ''')'''                              X 
                    OR '&PARM' EQ 'AND'                                X
                    OR '&PARM' EQ 'OR') RPI 1065 AND/OR FORCES NEW COMP
                   :&PARM SETC ''
               AELSEIF ('&PARM' EQ '+' OR '&PARM' EQ '-')
                   :&PARM SETC '&PARM&SYSLIST(&CD_PARM_IX+1)'
                   :&CD_PARM_IX SETA &CD_PARM_IX+1
               AELSEIF (('&PARM' EQ '<' OR '&PARM' EQ '>')             X
                       AND '&SYSLIST(&CD_PARM_IX+1)' EQ '=')  RPI 1065
                   :&PARM SETC '&PARM&SYSLIST(&CD_PARM_IX+1)'
                   :&CD_PARM_IX SETA &CD_PARM_IX+1
               AELSEIF ('&PARM'(1,1) LT '0'                            X
                        AND '&PARM'(1,1) NE ''''                       X
                        AND '&PARM'(1,1) NE '.') RPI 1065 FIND FIELD             
                   :&SAVE_PARM_IX SETA &PARM_IX
                   :&PARM_IX SETA &CD_PARM_IX
                   :&FIELD_REG SETC 'ZC_R2'
                   ACALL GET_PARM_FIELD
                   :&PARM SETC '&FIELD_NAME'
                   :&CD_PARM_IX SETA &PARM_IX-1
                   :&PARM_IX SETA &SAVE_PARM_IX
               AELSE
                   :&FIELD_NAME SETC '&PARM' 
                   :&FIELD_IX SETA 0
               AEND
         AELSE
               :&PARM SETC ''
         AEND
         AIF   (&CD_PARM_IX LT 0)
               :&CD_PARM_IX SETA 0
         AEND
         AEND
.*
.* LIST IOPS FOR AID IN DEBUGGING
.* 
         AENTRY LIST_IOPS
         :&J   SETA 1
         MNOTE 'ZCOBOL IOP TABLE LISTING - TOTAL IOPS = &IOP_TOT'
         AWHILE (&J LE &IOP_TOT)
               MNOTE 'IOP=&J OP=&IOP_OP(&J) CD1=&IOP_CD1(&J) CD2=&IOP_CX
               D2(&J) TF=&IOP_TF(&J) OR-END=&IOP_OR_END(&J)'
               :&J SETA &J+1
         AEND
         AEND
.*
.* RESET SS1 - REMOVE LEN FROM OFF(LEN,REG) OR NAME(LEN)
.*
         AENTRY RESET_SS1
         :&K SETA ('&FIELD_NAME' FIND '(')
         AIF   ('&FIELD_NAME'(1,1) GE '0')  IS THIS O(L,R) 
               AIF (&K GT 1)
                   :&FIELD_OFF SETA '&FIELD_NAME'(1,&K-1)
                   :&J SETA ('&FIELD_NAME' FIND ',')
                   AIF (&J GT &K+1)
                       :&FIELD_LEN SETA '&FIELD_NAME'(&K+1,&J-1)
                       :&FIELD_REG SETC '&FIELD_NAME'(&J+1,K'&FIELD_NAMX
               E-&J-1)
                       :&FIELD_NAME SETC '&FIELD_NAME'(1,&K).'&FIELD_NAX
               ME'(&J+1,*)  O(R)
                   AEND
               AEND
         AELSEIF (&K GT 1)                        RPI 1065
               :&FIELD_NAME SETC '&FIELD_NAME'(1,&K-1)
         AEND
         AEND
         COPY ZCGETFLD
         COPY ZCDFHLIT
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author.  Don Higgins                                              *
.* Date   - 04/07/08                                                 *
.*********************************************************************
.* 06/13/08 INITIALIZE not supported yet                
.*********************************************************************
         INITIALIZE 
         MNOTE 8,'INITIALIZE NOT SUPPORTED YET'
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/16/08                                                 *
.*********************************************************************
.* 02/20/09 stub for pending support              
.*********************************************************************
         INITIATE
         MNOTE 8,'INITIATE NOT SUPPORTED YET'
         MEXIT
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* All rights reserved                                               *      
.* Author - Don Higgins                                              *
.* Date   - 04/14/08                                                 *
.*********************************************************************
.* 04/14/08 initial coding for global ZCOBOL
.*********************************************************************
         INPUT_OUTPUT
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/16/08                                                 *
.*********************************************************************
.* 11/17/08 stub for pending support              
.* 01/14/09 initial coding
.* 07/19/09 RPI fix FIELD_REC ZC_R3
.*********************************************************************
.* R2=V1,R3=V2   THESE MAY BE PASSED MULTIPLE TIMES TO GEN/ZC390LIB
.* R14=V3,R15=V4 THESE MUST BE RESET FOR EACH CALL TO GEN
.* R1,R14,R15 USED IN STANDARD LINKAGE FROM GEN TO ZC390LIB INSPECT.MLC
.*********************************************************************
         INSPECT
         COPY ZC_WS
         :&TEST_OK   SETB 0
         :&TEST_TYPE SETC ''
         :&TEST_VAR  SETC ''
         :&TEST_IX   SETA 0
         :&PARM_IX   SETA 1
         :&FIELD_REG SETC 'ZC_R2'  R2=V1 INSPECT FIELD IF SUBSCRIPTED
         :&FIELD_SS1 SETB 0
         ACALL GET_PARM_FIELD
         AIF   (&FIELD_IX EQ 0)
               MNOTE 8,'INSPECT FIELD NOT FOUND &SYSLIST(1)'
               MEXIT
         AEND
         :&V1    SETC '&FIELD_NAME'
         :&V1_IX SETA &FIELD_IX
         AIF   ('&SYSLIST(&PARM_IX)' EQ 'TALLYING')
               :&PARM_IX SETA &PARM_IX+1
               ACALL TALLYING                                      
         AELSEIF ('&SYSLIST(&PARM_IX)' EQ 'REPLACING')
               :&PARM_IX SETA &PARM_IX+1
               ACALL REPLACING                                      
         AELSEIF ('&SYSLIST(&PARM_IX)' EQ 'CONVERTING')
               :&PARM_IX SETA &PARM_IX+1
               ACALL CONVERTING                                     
         AELSE
               MNOTE 8,'INSPECT UNKNOWN PARM - &SYSLIST(&PARM_IX)'
         AEND
         MEXIT
.*
.* INSPECT V1 TALLYING V2 FOR [CHARACTERS TEST,ALL/LEADING V3 TEST]
.*  TEST = BEFORE/AFTER [INITIAL] V4
.* NOTES:
.*  1.  TALLYING MAY ALSO BE FOLLOWED BY REPLACING USING THE SAME V1
.*
         AENTRY TALLYING
      :&TALLYING_CNT SETA 0
      AWHILE   ('&SYSLIST(&PARM_IX)' NE ''                             X
                AND '&SYSLIST(&PARM_IX)' NE 'REPLACING')
         :&TALLYING_CNT SETA &TALLYING_CNT+1
         :&FIELD_REG SETC 'ZC_R3'  R3=V2 TALLY VAR IF SUBSC  RPI 1065
         :&FIELD_SS1 SETB 0
         ACALL GET_PARM_FIELD
         AIF   (&FIELD_IX EQ 0)
               MNOTE 8,'INSPECT TALLYING FIELD NOT FOUND &SYSLIST(&FIELX
               D_IX)'
               MEXIT
         AEND
         :&V2    SETC '&FIELD_NAME'
         :&V2_IX SETA &FIELD_IX
         AIF   ('&SYSLIST(&PARM_IX)' NE 'FOR')
               MNOTE 8,'INSPECT MISSING FOR AFTER TALLYING'
               MEXIT
         AEND
         :&PARM_IX SETA &PARM_IX+1
       :&STYPE_CNT SETA 0
       AWHILE  ('&SYSLIST(&PARM_IX)' NE ''                             X
                AND '&SYSLIST(&PARM_IX)' NE 'REPLACING')
         :&STYPE_CNT SETA &STYPE_CNT+1
         AIF   ('&SYSLIST(&PARM_IX)' EQ 'CHARACTERS')
               :&STYPE SETC 'CHARACTERS'
               :&PARM_IX SETA &PARM_IX+1
               :&TEST_CNT SETA 0
               AWHILE ('&SYSLIST(&PARM_IX)' NE ''                      X
                      AND '&SYSLIST(&PARM_IX)' NE 'REPLACING')
                   :&TEST_CNT SETA &TEST_CNT+1
                   ACALL GET_TEST_PHRASE
                   AIF (&TEST_OK) 
                       GEN_INSPECT TALLYING,&STYPE,&V1,&V1_IX,&V2,&V2_IX
               X,&TEST_TYPE,&TEST_VAR,&TEST_IX
                   AEND
               AEND
               AIF (&TEST_CNT EQ 0)
                   MNOTE 8,'INSPECT TALLYING CHARACTERS MISSING TEST'
                   MEXIT
               AEND
         AELSEIF   ('&SYSLIST(&PARM_IX)' EQ 'ALL'                      X
                    OR '&SYSLIST(&PARM_IX)' EQ 'LEADING')
               :&STYPE SETC '&SYSLIST(&PARM_IX)'
               :&PARM_IX SETA &PARM_IX+1
               :&FIELD_REG SETC 'ZC_R3'
               :&FIELD_SS1 SETB 0
               ACALL GET_PARM_FIELD
               AIF (&FIELD_IX GT 0                                     X
                    OR '&FIELD_NAME'(1,1) EQ '''')
                    :&V3 SETC '&FIELD_NAME'
                    :&V3_IX SETA &FIELD_IX
                    :&TEST_CNT SETA 0
                    AWHILE ('&SYSLIST(&PARM_IX)' NE ''                 X
                           AND '&SYSLIST(&PARM_IX)' NE 'REPLACING')
                       :&TEST_CNT SETA &TEST_CNT+1
                       ACALL GET_TEST_PHRASE
                       AIF (&TEST_OK) 
                           GEN_INSPECT TALLYING,&STYPE,&V1,&V1_IX,&V2,&X
               V2_IX,&V3,&V3_IX,&TEST_TYPE,&TEST_VAR,&TEST_IX
                       AEND
                    AEND
                    AIF (&TEST_CNT EQ 0)
                        AIF ('&SYSLIST(&PARM_IX)' EQ '')
                           GEN_INSPECT TALLYING,&STYPE,&V1,&V1_IX,&V2,&X
               V2_IX,&V3,&V3_IX,0   NO TEST
                        AELSE
                            MNOTE 8,'INSPECT TALLYING UNKNOWN CLAUSE - X
               &SYSLIST(&PARM_IX)'
                            MEXIT
                        AEND
                    AEND
               AELSE
                    MNOTE 8,'INSPECT MISSING ALL IDENTIFIER'
                    MEXIT
               AEND
         AELSE
               MNOTE 8,'INSPECT MISSING CHARACTERS/ALL/LEADING'
               MEXIT
         AEND
       AEND
      AEND
      AIF      (&TALLYING_CNT EQ 0)
               MNOTE 8,'INSPECT TALLYING MISSING VAR'
               MEXIT
      AELSEIF  ('&SYSLIST(&PARM_IX)' EQ 'REPLACING')
               :&PARM_IX SETA &PARM_IX+1
               ACALL REPLACING
      AEND
         AEND
.*
.* INSPECT V1 REPLACING [CHARACTERS BY V3 TEST,
.*                      ALL/LEADING/FIRST V2 BY V3 TEST]
.*                      TEST = BEFORE/AFTER [INITIAL] V4
.*
         AENTRY REPLACING
      :&REPLACING_CNT SETA 0
      AWHILE ('&SYSLIST(&PARM_IX)' NE '')
         :&REPLACING_CNT SETA &REPLACING_CNT+1
         AIF   ('&SYSLIST(&PARM_IX)' EQ 'CHARACTERS'                   X
                AND '&SYSLIST(&PARM_IX+1)' EQ 'BY')
               :&STYPE SETC 'CHARACTERS'
               :&PARM_IX SETA &PARM_IX+2
               :&V2 SETC ''
               :&V2_IX SETA 0
               :&FIELD_REG SETC 'ZC_R3'
               :&FIELD_SS1 SETB 0
               ACALL GET_PARM_FIELD
               AIF (&FIELD_IX GT 0                                     X
                    OR '&FIELD_NAME'(1,1) EQ '''')
                    :&V3 SETC '&FIELD_NAME'
                    :&V3_IX SETA &FIELD_IX
                    :&TEST_CNT SETA 0
                    AWHILE ('&SYSLIST(&PARM_IX)' NE ''                 X
                           AND '&SYSLIST(&PARM_IX)' NE 'REPLACING')
                       :&TEST_CNT SETA &TEST_CNT+1
                       ACALL GET_TEST_PHRASE
                       AIF (&TEST_OK) 
                           GEN_INSPECT REPLACING,&STYPE,&V1,&V1_IX,&V2,X
               &V2_IX,&V3,&V3_IX,&TEST_TYPE,&TEST_VAR,&TEST_IX
                       AEND
                    AEND
                    AIF (&TEST_CNT EQ 0)
                        MNOTE 8,'INSPECT REPLACING CHARACTERS MISSING TX
               EST'
                        MEXIT
                    AEND
               AELSE
                    MNOTE 8,'INSPECT REPLACING CHARACTERS MISSING IDENTX
               IFIER'
                    MEXIT
               AEND
         AELSEIF   ('&SYSLIST(&PARM_IX)' EQ 'ALL'                      X
                    OR '&SYSLIST(&PARM_IX)' EQ 'LEADING'               X
                    OR '&SYSLIST(&PARM_IX)' EQ 'FIRST')
               :&STYPE SETC '&SYSLIST(&PARM_IX)'
               :&PARM_IX SETA &PARM_IX+1
             :&STYPE_CNT SETA 0
             AWHILE ('&SYSLIST(&PARM_IX)' NE ''                        X
                     AND '&SYSLIST(&PARM_IX)' NE 'REPLACING')
               :&STYPE_CNT SETA &STYPE+1
               :&FIELD_REG SETC 'ZC_R2'
               :&FIELD_SS1 SETB 0
               ACALL GET_PARM_FIELD
               AIF (&FIELD_IX GT 0                                     X
                    OR '&FIELD_NAME'(1,1) EQ '''')
                :&V2 SETC '&FIELD_NAME'
                :&V2_IX SETA &FIELD_IX
                AIF ('&SYSLIST(&PARM_IX)' EQ 'BY')
                  :&PARM_IX SETA &PARM_IX+1
                AELSE
                  MNOTE 8,'INSPECT REPLACING MISSING BY'
                  MEXIT
                AEND
                :&FIELD_REG SETC 'ZC_R3'
                :&FIELD_SS1 SETB 0
                ACALL GET_PARM_FIELD
                AIF (&FIELD_IX GT 0                                    X
                       OR '&FIELD_NAME'(1,1) EQ '''')
                    :&V3 SETC '&FIELD_NAME'
                    :&V3_IX SETA &FIELD_IX
                    :&TEST_CNT SETA 0
                    AWHILE ('&SYSLIST(&PARM_IX)' NE ''                 X
                           AND '&SYSLIST(&PARM_IX)' NE 'REPLACING')
                       :&TEST_CNT SETA &TEST_CNT+1
                        ACALL GET_TEST_PHRASE
                        AIF (&TEST_OK) 
                            GEN_INSPECT REPLACING,&STYPE,&V1,&V1_IX,&V2X
               ,&V2_IX,&V3,&V3_IX,&TEST_TYPE,&TEST_VAR,&TEST_IX
                        AEND
                    AEND
                    AIF (&TEST_CNT EQ 0)
                        MNOTE 8,'INSPECT REPLACING ALL/LEADING/FIRST MIX
               SSING TEST'
                        MEXIT
                    AEND
                 AELSE
                    MNOTE 8,'INSPECT REPLACING UNDEFINED ID3'
                    MEXIT
                 AEND
               AELSE
                    MNOTE 8,'INSPECT REPLACING MISSING ID2'
                    MEXIT
               AEND
             AEND
             AIF (&STYPE_CNT EQ 0)
                 MNOTE 8,'INSPECT REPLACING &STYPE MISSING VAR'
                 MEXIT
             AEND
         AELSE
               MNOTE 8,'INSPECT MISSING CHARACTERS/ALL/LEADING/FIRST'
               MEXIT
         AEND
       AEND
       AIF     (&REPLACING_CNT EQ 0)
               MNOTE 8,'INSPECT REPLACING MISSING VAR'
               MEXIT
       AEND
         AEND
.*
.* INSPECT V1 CONVERTING V2 TO V3 TEST
.*  TEST = BEFORE/AFTER [INITIAL] V4
.*
         AENTRY CONVERTING
         :&FIELD_REG SETC 'ZC_R2'
         :&FIELD_SS1 SETB 0
         ACALL GET_PARM_FIELD
         AIF   (&FIELD_IX EQ 0                                         X
               AND '&FIELD_NAME' EQ '')
               MNOTE 8,'INSPECT CONVERTING FROM FIELD NOT FOUND'
               MEXIT
         AEND
         :&V2    SETC '&FIELD_NAME'
         :&V2_IX SETA &FIELD_IX
         AIF   ('&SYSLIST(&PARM_IX)' NE 'TO')
               MNOTE 8,'INSPECT CONVERTING MISSING TO'
               MEXIT
         AEND
         :&PARM_IX SETA &PARM_IX+1
         :&FIELD_REG SETC 'ZC_R3'
         :&FIELD_SS1 SETB 0
         ACALL GET_PARM_FIELD
         AIF   (&FIELD_IX EQ 0                                         X
               AND '&FIELD_NAME' EQ '')
              MNOTE 8,'INSPECT MISSING ALL IDENTIFIER'
              MEXIT
         AEND
         :&V3 SETC '&FIELD_NAME'
         :&V3_IX SETA &FIELD_IX
         
         AIF   ('&SYSLIST(&PARM_IX)' NE '')
               ACALL GET_TEST_PHRASE
         AELSE
               :&TEST_OK SETB 1
         AEND
         AIF (&TEST_OK) 
               GEN_INSPECT CONVERTING,&V1,&V1_IX,&V2,&V2_IX,&V3,&V3_IX,X
               &TEST_TYPE,&TEST_VAR,&TEST_IX
         AEND
         AEND
.*
.* GET TEST PHRASE - BEFORE/AFTER [INITIAL] VAR
.*
         AENTRY GET_TEST_PHRASE
         AIF   ('&SYSLIST(&PARM_IX)' EQ 'BEFORE')
               :&TEST_TYPE SETC 'BEFORE'
         AELSEIF ('&SYSLIST(&PARM_IX)' EQ 'AFTER')
               :&TEST_TYPE SETC 'AFTER'
         AELSE
               MNOTE 8,'INSPECT TEST MISSING BEFORE/AFTER'
               MEXIT
         AEND
         :&PARM_IX SETA &PARM_IX+1
         AIF   ('&SYSLIST(&PARM_IX)' EQ 'INITIAL')
               :&PARM_IX SETA &PARM_IX+1
         AEND
         :&FIELD_REG SETC 'ZC_R14'
         :&FIELD_SS1 SETB 0
         ACALL GET_PARM_FIELD
         AIF   (&FIELD_IX GT 0                                         X
               OR '&FIELD_NAME'(1,1) EQ '''')
               :&TEST_VAR SETC '&FIELD_NAME'
               :&TEST_IX  SETA &FIELD_IX
               :&TEST_OK  SETB 1
         AELSE
              :&TEST_OK SETB 0
              MNOTE 8,'INSPECT MISSING TEST IDENTIFIER'
              MEXIT
         AEND
         AEND
         MEXIT
         COPY ZCGETFLD
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/16/08                                                 *
.*********************************************************************
.* 04/16/08 initial coding for global INSTALLATION
.*********************************************************************
         INSTALLATION            
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/16/08                                                 *
.*********************************************************************
.* 02/20/09 stub for pending support              
.*********************************************************************
         I_O_CONTROL
         MNOTE 8,'I_O_CONTROL NOT SUPPORTED YET'
         MEXIT
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/07/08                                                 *
.*********************************************************************
.* 04/09/08 initial coding for global LABEL
.* 10/06/08 ZSTRMAC
.*********************************************************************
         LABEL     &LABEL,&TYPE
         AIF   ('&TYPE' EQ '')
               GEN_LABEL &LABEL,PARAGRAPH
         AELSEIF ('&TYPE' EQ 'SECTION')
               GEN_LABEL &LABEL,SECTION
         AELSE
               MNOTE 8,'LABEL TYPE UNKNOWN - &TYPE'
         AEND
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/16/08                                                 *
.*********************************************************************
.* 04/16/08 initial coding for global LINKAGE SECTION
.* 10/06/08 ZSTRMAC
.*********************************************************************
.* 1. LK_MODE SET FOR WS TO GEN DSECT FOR EACH 01 NAMED LK_NNNN 
.* 2. &SYM_LK HAS INDEX TO 01 LVL WHICH HAS SYM_REF SET TO VAR_PTR IX
.* 3. PROC AND ENTRY SET 01 SYM_REF TO VAR_PTR, WS SETS SYM_LK
.* 4. GEN_BASE LOADS DSECT ADDR FROM VAR_PTR FOR SYM IN LINKAGE SECT
.*********************************************************************
         LINKAGE &SECT
         COPY  ZC_WS
         AIF   ('&SECT' NE 'SECTION')      
               MNOTE 4,'LINKAGE MISSING "SECTION"'
               MEXIT
         AEND
         :&FILE_IX SETA 0 END ANY FILE RECORD DEFINITIONS
         :&LK_SAVE_WS_LOC SETA &WS_LOC SAVE WS LAST LOC FOR PD      
         :&LK_MODE SETB  1             TURN LK MODE
         MEND
         MACRO
.*********************************************************************
.* Copyright 2009 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 08/02/09                                                 *
.*********************************************************************
.* 08/03/09 stub for pending support              
.*********************************************************************
         LOCALE    
         MNOTE 8,'LOCALE NOT SUPPORTED YET'
         MEXIT
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/16/08                                                 *
.*********************************************************************
.* 11/17/08 stub for pending support              
.*********************************************************************
         MERGE
         MNOTE 8,'MERGE NOT SUPPORTED YET'
         MEXIT
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/07/08                                                 *
.*********************************************************************
.* 04/10/08 initial coding for global MOVE     
.* 05/02/08 add support for literal values by PIC_TYPE
.* 10/06/08 ZSTRMAC
.* 02/27/09 RPI 1012 SUPPORT ALL '?' LIT
.* 06/18/09 RPI 1042 add ZCDFHLIT shared by IF and MOVE                 
.*********************************************************************
.* MOVE id1 TO id2 id3 idn
.*********************************************************************
         MOVE  
         COPY  ZC_WS
         :&SOURCE SETC '&SYSLIST(1)'
         :&ADDR_OF SETB 0
         :&PARM_IX SETA 2
         :&SOURCE_IX SETA 0
         AIF   ('&SOURCE' EQ 'ALL')
               :&SOURCE SETC '*&SYSLIST(2)' PREFIX *LIT FOR ALL LIT
               :&PARM_IX SETA 3
         AELSEIF   ('&SOURCE' EQ 'LENGTH')
               AIF ('&SYSLIST(2)' EQ 'OF')
                   :&SOURCE SETC '&SYSLIST(3)'
                   :&PARM_IX SETA 4
               AELSE
                   :&SOURCE SETC '&SYSLIST(2)'
                   :&PARM_IX SETA 3
               AEND
               ZC_SYM_FIND &SOURCE
               AIF  (&SYM_IX GT 0)
                    :&SOURCE SETC '&SYM_LEN(&SYM_IX)'
               AELSE
                    MNOTE 8,'MOVE LENGTH OF &SOURCE NOT FOUND'
                    MEXIT
               AEND
         AELSEIF ('&SOURCE' EQ 'ADDRESS')
               AIF ('&SYSLIST(2)' EQ 'OF')
                   :&SOURCE SETC '&SYSLIST(3)'
                   :&PARM_IX SETA 3
               AELSE
                   :&SOURCE SETC '&SYSLIST(2)'
                   :&PARM_IX SETA 2
               AEND
               :&FIELD_REG SETC 'ZC_R2'
               :&FIELD_SS1 SETB 0
               ACALL GET_PARM_FIELD
               AIF (&FIELD_IX EQ 0)
                   MNOTE 8,'MOVE SOURCE FIELD NOT FOUND &FIELD_NAME'
                   MEXIT
               AEND
               :&SOURCE_IX SETA &FIELD_IX
               :&SOURCE    SETC '&FIELD_NAME'
               :&ADDR_OF SETB 1
         AELSEIF   ('&SOURCE' EQ '+' OR '&SOURCE' EQ '-')
               :&SOURCE SETC '&SOURCE&SYSLIST(2)'
               :&PARM_IX SETA 3
         AELSEIF   ('&SOURCE'(1,2) EQ 'X''') OR '&SOURCE'(1,2) EQ 'X"')
               :&SOURCE SETC 'X'''.'&SOURCE'(3,K'&SOURCE-3).''''
         AELSEIF  ('&SOURCE' EQ 'DFHRESP')
               :&DFHRESP SETC '&SYSLIST(3)'
               ACALL GET_DFHRESP
               :&SOURCE  SETC '&DFHLIT'
               :&PARM_IX SETA 5
         AELSEIF  ('&SOURCE' EQ 'DFHVALUE')
               :&DFHVALUE SETC '&SYSLIST(3)'
               ACALL GET_DFHVALUE
               :&SOURCE   SETC '&DFHLIT'
               :&PARM_IX  SETA 5
         AELSEIF   ('&SOURCE'(1,1) NE ''''                             X
                  AND ('&SOURCE'(1,1) GT '9' OR '&SOURCE'(1,1) LT '0') X
                  AND '&SOURCE'(1,1) NE '.')  RPI 1065 
               AIF ('&SOURCE' EQ 'FUNCTION')
                   MNOTE 8,'MOVE FUNCTION NOT SUPPORTED YET'
                   MEXIT
               AEND
               :&PARM_IX SETA 1
               :&FIELD_REG SETC 'ZC_R2'
               :&FIELD_SS1 SETB 0
               ACALL GET_PARM_FIELD
               :&SOURCE_IX SETA &FIELD_IX
               AIF (&FIELD_IX GT 0)
                   :&SOURCE SETC '&FIELD_NAME'
               AEND
         AEND
         AIF   ('&SYSLIST(&PARM_IX)' NE 'TO')
               MNOTE 8,'MOVE MISSING TO'
               MEXIT
         AEND
         :&PARM_IX SETA &PARM_IX+1
       AWHILE ('&SYSLIST(&PARM_IX)' NE '')
         ACTR 4096
         :&FIELD_REG SETC 'ZC_R2'
         :&FIELD_SS1 SETB 1
         ACALL GET_PARM_FIELD
         AIF (&FIELD_IX EQ 0)
             MNOTE 8,'MOVE TARGET FIELD NOT FOUND - &FIELD_NAME'
             MEXIT
         AEND
         :&TARGET_IX SETA &FIELD_IX
         :&TARGET SETC '&FIELD_NAME'
         AIF (&SOURCE_IX GT 0)
               AIF (&ADDR_OF AND '&SYM_PIC_TYPE(&TARGET_IX)' NE 'A')
                   MNOTE 8,'MOVE TARGET OF ADDRESS OF MUST BE POINTER'
                   MEXIT
               AEND
         AEND
         GEN_MOVE &TARGET,&TARGET_IX,&SOURCE,&SOURCE_IX
       AEND
         MEXIT
         COPY ZCGETFLD
         COPY ZCDFHLIT
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/07/08                                                 *
.*********************************************************************
.* 10/30/08 initial coding for global MULTIPLY using ADD as model
.* 02/26/09 RPI 1012 move onsize end-add pending to MULTIPLY           
.* 07/19/09 RPI 1062 correct ON SIZE parsing                           
.*********************************************************************
         MULTIPLY
         COPY  ZC_WS
         :&ROUNDED SETB 0
         :&ONSIZE  SETB 0
         :&PARM_IX   SETA 1
         :&FIELD_REG SETC 'ZC_R1'
         :&FIELD_SS1 SETB 0
         ACALL GET_PARM_FIELD
         :&S1    SETC '&FIELD_NAME'                
         :&S1_IX SETA &FIELD_IX                    
         AIF   ('&SYSLIST(&PARM_IX)' NE 'BY')
               MNOTE 8,'MULTIPLY MISSING BY'
               MEXIT
         AEND
         :&PARM_IX SETA &PARM_IX+1
         :&S2_OK SETB 1
         ACALL SET_OPTIONS
         ACALL GET_S2
         AIF   (&S2_OK)
               AIF ('&SYSLIST(&PARM_IX)' EQ 'GIVING')
                   :&PARM_IX SETA &PARM_IX+1
                   ACALL MPY_GIVING
               AELSE
                   ACALL MPY_BY
               AEND
         AEND
         AIF   (&ONSIZE)
               GEN_ONSIZE_START MPY
         AEND
         MEXIT
.*
.* MPY GIVING
.*
         AENTRY MPY_GIVING
         :&S3_OK SETB 1
         ACALL GET_S3
         AWHILE (&S3_OK)
             GEN_MOVE &S3,&S3_IX,&S1,&S1_IX
             GEN_MPY  &S3,&S3_IX,&S2,&S2_IX,&ROUNDED,&ONSIZE
             ACALL GET_S3
         AEND
         AEND
.*
.* MPY BY (NO GIVING, MULT MULTIPLIERS)
.*
         AENTRY MPY_BY
         AWHILE (&S2_OK)
             GEN_MPY  &S2,&S2_IX,&S1,&S1_IX,&ROUNDED,&ONSIZE
             ACALL GET_S2
         AEND
         AEND
.*
.* GET S2 AND OPTIONAL ROUNDING
.*
         AENTRY GET_S2
         AIF (&PARM_IX GT &LAST_PARM)
             :&S2_OK SETB 0
             AEXIT AENTRY
         AEND
         :&FIELD_REG SETC 'ZC_R2'
         :&FIELD_SS1 SETB 0
         ACALL GET_PARM_FIELD
         :&S2    SETC '&FIELD_NAME'                
         :&S2_IX SETA &FIELD_IX                    
         AIF   ('&SYSLIST(&PARM_IX)' EQ 'ROUNDED')
               :&ROUNDED SETB 1
               :&PARM_IX SETA &PARM_IX+1
         AELSE 
               :&ROUNDED SETB 0
         AEND
         AEND
.*
.* GET S3 AND OPTIONAL ROUNDING
.*
         AENTRY GET_S3
         AIF (&PARM_IX GT &LAST_PARM)
             :&S3_OK SETB 0
             AEXIT AENTRY
         AEND
         :&FIELD_REG SETC 'ZC_R3'
         :&FIELD_SS1 SETB 0
         ACALL GET_PARM_FIELD
         :&S3    SETC '&FIELD_NAME'                
         :&S3_IX SETA &FIELD_IX                    
         AIF   ('&SYSLIST(&PARM_IX)' EQ 'ROUNDED')
               :&ROUNDED SETB 1
               :&PARM_IX SETA &PARM_IX+1
         AELSE 
               :&ROUNDED SETB 0
         AEND
         AEND
.*
.* SET OPTIONS - ROUND AND ON SIZE ERROR
.*
         AENTRY SET_OPTIONS
         :&SAVE_PARM_IX SETA &PARM_IX
         :&ROUNDED     SETB 0
         :&ON_SIZE     SETB 0
         :&NOT_ON_SIZE SETB 0
         :&LAST_PARM   SETA 0
         AWHILE (&PARM_IX LE N'&SYSLIST)
               ACTR 4096
               AIF     ('&SYSLIST(&PARM_IX)' EQ 'ON'                   X
                        AND '&SYSLIST(&PARM_IX+1)' EQ 'SIZE'           X
                        AND '&SYSLIST(&PARM_IX+2)' EQ 'ERROR') RPI 1065
                     :&ON_SIZE SETB 1      
                     AIF (&LAST_PARM EQ 0)
                         :&LAST_PARM SETA &PARM_IX-1
                     AEND                              
                     :&PARM_IX SETA N'&SYSLIST+2
               AELSEIF ('&SYSLIST(&PARM_IX)' EQ 'NOT'                  X
                        AND '&SYSLIST(&PARM_IX+1)' EQ 'ON'             X
                        AND '&SYSLIST(&PARM_IX+2)' EQ 'SIZE'           X
                        AND '&SYSLIST(&PARM_IX+3)' EQ 'ERROR') RPI 1065
                     :&NOT_ON_SIZE SETB 1                                
                     AIF (&LAST_PARM EQ 0)
                         :&LAST_PARM SETA &PARM_IX-1
                     AEND                              
                     :&PARM_IX SETA N'&SYSLIST+3
               AELSEIF ('&SYSLIST(&PARM_IX)' EQ 'REMAINDER')
                     MNOTE 8,'DIVIDE MULT GIVING WITH REMAINDER ERROR'
                     MEXIT
               AEND 
               :&PARM_IX SETA &PARM_IX+1
         AEND
         AIF (&LAST_PARM EQ 0)
             :&LAST_PARM SETA N'&SYSLIST
         AEND                        
         :&PARM_IX SETA &SAVE_PARM_IX      
         AIF   (&ONSIZE)
               :&IE_LVL  SETA  &IE_LVL+1         ADD PENDING END_MPY
               :&IE_TYPE(&IE_LVL) SETA 13        FOR END_MPY OR PERIOD
               :&MPY_LAB SETA &MPY_LAB+1
               :&IE_TCNT(&IE_LVL) SETA &MPY_LAB
         AEND
         AEND
         COPY ZCGETFLD
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/16/08                                                 *
.*********************************************************************
.* 04/16/08 initial coding for global GO TO    
.* 10/06/08 ZSTRMAC
.*********************************************************************
         NEXT  &SENTENCE                     
         COPY  ZC_WS
         AIF   ('&SENTENCE' EQ 'SENTENCE')
               AIF (NOT &PERIOD_NEXT)
                   :&PERIOD_NEXT SETB 1
                   :&PERIOD_NEXT_LAB SETA &PERIOD_NEXT_LAB+1
               AEND
               GEN_B  PERIOD_NEXT_&PERIOD_NEXT_LAB
         AELSE
               MNOTE 8,'NEXT MISSING SENTENCE'
         AEND
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/16/08                                                 *
.*********************************************************************
.* 11/17/08 stub for pending support              
.*********************************************************************
         NOT
         MNOTE 8,'NOT ON IS NOT SUPPORTED YET'
         MEXIT
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 02/11/09                                                 *
.*********************************************************************
.* 02/11/09 initial coding for NOTE comment sentence
.*********************************************************************
         NOTE   
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/16/08                                                 *
.*********************************************************************
.* 04/16/08 initial coding for global OBJECT-COMPUTER
.*********************************************************************
         OBJECT_COMPUTER    
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/14/08                                                 *
.*********************************************************************
.* 04/14/08 initial coding for global ZCOBOL
.* 10/06/08 ZSTRMAC
.*********************************************************************
         OPEN  &TYPE,&FILE
         COPY  ZC_WS
         AIF   ('&TYPE' NE 'INPUT'                                     X
                AND '&TYPE' NE 'OUTPUT')
                MNOTE 8,'OPEN UNKNOWN TYPE - &TYPE'
                MEXIT
         AEND
         ZC_FILE_FIND &FILE
         AIF   (&FILE_IX GT 0)     
               GEN_OPEN &TYPE
         AELSE 
               MNOTE 8,'OPEN FILE NOT FOUND - &FILE'
         AEND 
         MEND
         MACRO
.*********************************************************************
.* Copyright 2009 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 08/02/09                                                 *
.*********************************************************************
.* 08/03/09 stub for pending support              
.*********************************************************************
         ORDER   
         MNOTE 8,'ORDER NOT SUPPORTED YET'
         MEXIT
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/15/08                                                 *
.*********************************************************************
.* 04/15/08 initial coding for global PERFORM  
.* 11/28/08 add formats 1-4 see TESTPM1.CBL
.* 07/09/09 RPI correct BY for negative increments
.* 08/04/09 RPI RPI support qualified PG names within section
.*********************************************************************
         PERFORM                          
         COPY  ZC_WS
         :&PM_LAB SETA &PM_LAB+1
         :&NP    SETA  N'&SYSLIST
         :&TEST_BEFORE SETB 1
         :&I SETA 1
         AIF   ('&SYSLIST(&I)' EQ 'WITH'                               X
               AND '&SYSLIST(&I+1)' EQ 'TEST')
               AIF  ('&SYSLIST(&I+2)' EQ 'BEFORE')
                    :&TEST_BEFORE SETB 1
               AELSEIF ('&SYSLIST(&I+2)' EQ 'AFTER')
                    :&TEST_BEFORE SETB 0
               AELSE
                    MNOTE 8,'PERFORM WITH TEST MISSING BEFORE/AFTER'
                    MEXIT
               AEND
               :&I SETA &I+3
         AEND
         AIF   ('&SYSLIST(&I)' EQ 'UNTIL')
               ACALL FORMAT_3B  
               MEXIT
         AEND
         AIF   ('&SYSLIST(&I)' EQ 'VARYING')
               ACALL FORMAT_4B  
               MEXIT
         AEND
         AIF   ('&SYSLIST(&I+1)' EQ 'TIMES')
               ACALL FORMAT_2B
         AELSE
               AIF (&NP GT 0)
                   ACALL FORMAT_1A_2A_3A_4A
               AELSE
                   ACALL FORMAT_1B
               AEND
         AEND
         MEXIT
.*
.* FORMAT 1A PERFORM PG1 [THRU PG2] END-PERFORM/. 
.* FORMAT 2A PERFORM PG1 [THRU PG2] n TIMES END-PERFORM/. 
.* FORMAT 3A PERFORM PG1 [THRU PG2] [UNTIL cond] END-PERFORM/. 
.* FORMAT 3A PERFORM PG1 [THRU PG2] [VARYING ..] END-PERFORM/. 
.*
         AENTRY FORMAT_1A_2A_3A_4A
         :&PG_NAME1 SETC '&SYSLIST(&I)' RPI 1065 SN/PG SUPPORT
         :&I        SETA &I+1
         AIF   ('&SYSLIST(&I)' EQ 'OF' OR '&SYSLIST(&I)' EQ 'IN')
               :&SN_NAME1 SETC '&SYSLIST(&I+1)'
               :&I SETA &I+2
         AELSE
               :&SN_NAME1 SETC '' 
         AEND
         AIF   ('&SYSLIST(&I)' EQ 'THRU'                               X
                OR '&SYSLIST(&I)' EQ 'THROUGH')      
               :&PG_NAME2 SETC  '&SYSLIST(&I+1)'
               :&I SETA  &I+2
               AIF  ('&SYSLIST(&I)' EQ 'OF' OR '&SYSLIST(&I)' EQ 'IN')
                    :&SN_NAME2 SETC '&SYSLIST(&I+1)'
                    :&I SETA &I+2
               AELSE
                    :&SN_NAME2 SETC '&SN_NAME1' 
               AEND
         AELSE
               :&PG_NAME2 SETC '&PG_NAME1._END'
               :&SN_NAME2 SETC '&SN_NAME1' 
         AEND
         :&IF_PARM SETC  ''
         AIF   (&I LE &NP)     
               AIF   ('&SYSLIST(&I)' EQ 'WITH'                         X
               AND '&SYSLIST(&I+1)' EQ 'TEST')
                    AIF  ('&SYSLIST(&I+2)' EQ 'BEFORE')
                         :&TEST_BEFORE SETB 1
                    AELSEIF ('&SYSLIST(&I+2)' EQ 'AFTER')
                         :&TEST_BEFORE SETB 0
                    AELSE
                         MNOTE 8,'PERFORM WITH MISSING BEFORE/AFTER'
                         MEXIT
                    AEND
                    :&I SETA &I+3
               AEND
               AIF   ('&SYSLIST(&I)' EQ 'UNTIL')
                     ACALL FORMAT_3A
               AELSEIF ('&SYSLIST(&I)' EQ 'VARYING')
                     ACALL FORMAT_4A
               AELSEIF ('&SYSLIST(&I+1)' EQ 'TIMES')
                     ACALL FORMAT_2A
               AELSE
                     MNOTE 8,'PERFORM UNKNOWN -  &SYSLIST(&I)'
                     MEXIT
               AEND
         AELSE
               ACALL FORMAT_1A
         AEND
         AEND
.*
.* FORMAT 1A PERFORM PG1 [THRU PG2] END-PERFORM/. 
.*
         AENTRY FORMAT_1A
         GEN_PERFORM &PG_NAME1,&SN_NAME1,&PG_NAME2,&SN_NAME2  
         AEND
.*
.* FORMAT 1B PERFORM statement END-PERFORM. 
.*
         AENTRY FORMAT_1B   ADD PM LEVEL TO MATCH END_PERFORM OR .
         AEND
.*
.* FORMAT 2A PERFORM pg1 [THRU pg2] n TIMES END-PM
.*
         AENTRY FORMAT_2A
         GEN_VAR ZC_PM_NTIME_&VAR_TOT,F
         :&VAR_IX SETA &SYM_IX
         MOVE &SYSLIST(&I),TO,&SYM_NAME(&VAR_IX)
         GEN_B     PM_&PM_LAB._P
         GEN_LABEL PM_&PM_LAB._T,PERFORM_TEST
         IF &SYM_NAME(&VAR_IX),=,0
               GEN_B PM_&PM_LAB._E
         END_IF
         GEN_LABEL   PM_&PM_LAB._P,PERFORM
         GEN_PERFORM &PG_NAME1,&SN_NAME1,&PG_NAME1,&SN_NAME2  
         SUBTRACT 1,FROM,&SYM_NAME(&VAR_IX)
         GEN_B PM_&PM_LAB._T
         GEN_LABEL PM_&PM_LAB._E,PERFORM_END
         AEND
.*
.* FORMAT 2B PERFORM N TIMES statement END-PERFORM
.*
         AENTRY FORMAT_2B
         GEN_VAR ZC_PM_VARY_&VAR_TOT,F
         :&VAR_IX SETA &SYM_IX
         MOVE &SYSLIST(&I),TO,&SYM_NAME(&VAR_IX)
         GEN_B     PM_&PM_LAB._T
         GEN_LABEL PM_&PM_LAB._D,PERFORM_DEC_TIMES
         SUBTRACT 1,FROM,&SYM_NAME(&VAR_IX)
         GEN_LABEL PM_&PM_LAB._T,PERFORM_TEST
         IF &SYM_NAME(&VAR_IX),=,0
               GEN_B PM_&PM_LAB._E
         END_IF
         GEN_PM_LVL PM_&PM_LAB._D
         AEND
.*
.* FORMAT 3A PERFORM pg1 [THRU pg2 [WITH TEST BEFORE/AFTER] UNTIL cond
.*
         AENTRY FORMAT_3A
         ACALL  SET_IF_PARMS
         GEN_LABEL PM_&PM_LAB._T,PERFORM_TEST
         IF    &IF_PARM
               GEN_B PM_&PM_LAB._E
         END_IF
         GEN_PERFORM &PG_NAME1,&SN_NAME1,&PG_NAME2,&SN_NAME2  
         AIF   ('&IF_PARM' NE '')      
               GEN_B PM_&PM_LAB._T
               GEN_LABEL PM_&PM_LAB._E,PERFORM_END
         AEND
         AEND
.*
.* FORMAT 3B PERFORM [WITH TEST BEFORE/AFTER] UNTIL cond stmt END-PM
.*
         AENTRY FORMAT_3B
         ACALL  SET_IF_PARMS
         GEN_LABEL PM_&PM_LAB._T,PERFORM_TEST
         IF    &IF_PARM
               GEN_B PM_&PM_LAB._E
         END_IF
         GEN_PM_LVL PM_&PM_LAB._T  
         AEND
.*
.* FORMAT 4A PERFORM pg1 [THRU pg2 [WITH TEST BEFORE/AFTER] 
.*   VARYING v1 FROM i1 BY i2 UNTIL cond
.*
         AENTRY FORMAT_4A
         ACALL  SET_FROM_BY_UNTIL
         ACALL  SET_IF_PARMS
         MOVE  &FROM,TO,&VAR
         AIF   (&TEST_BEFORE)
               GEN_LABEL PM_&PM_LAB._T,PERFORM_TEST
               IF  &IF_PARM
                   GEN_B PM_&PM_LAB._E
               END_IF
               GEN_PERFORM &PG_NAME1,&SN_NAME1,&PG_NAME1,&SN_NAME2  
               ADD &BY,TO,&VAR
               GEN_B PM_&PM_LAB._T
         AELSE
               GEN_LABEL PM_&PM_LAB._P,PERFORM_TEST
               GEN_PERFORM &PG_NAME1,&SN_NAME1,&PG_NAME2,&SN_NAME2  
               IF  &IF_PARM
                   GEN_B PM_&PM_LAB._E
               END_IF
               ADD &BY,TO,&VAR
               GEN_B PM_&PM_LAB._P
         AEND
         GEN_LABEL PM_&PM_LAB._E,PERFORM_END
         AEND
.*
.* FORMAT 4B PERFORM [WITH TEST BEFORE/AFTER] 
.*  VARYING v1 FROM i1 BY i2 UNTIL cond stmt END-PM
.*
         AENTRY FORMAT_4B
         ACALL  SET_FROM_BY_UNTIL
         ACALL  SET_IF_PARMS
         MOVE  &FROM,TO,&VAR
         AIF   (&TEST_BEFORE)
               GEN_B PM_&PM_LAB._T
               GEN_LABEL PM_&PM_LAB._A,PERFORM_AUGMENT
               ADD &BY,TO,&VAR
               GEN_LABEL PM_&PM_LAB._T,PERFORM_TEST
               IF  &IF_PARM
                   GEN_B PM_&PM_LAB._E
               END_IF
               GEN_PM_LVL PM_&PM_LAB._A  
         AELSE
               GEN_B PM_&PM_LAB._P
               GEN_LABEL PM_&PM_LAB._A,PERFORM_AUGMENT
               ADD &BY,TO,&VAR
               IF  &IF_PARM
                   GEN_B PM_&PM_LAB._E
               END_IF
               GEN_LABEL PM_&PM_LAB._P,PERFORM_STATEMENT
               GEN_PM_LVL PM_&PM_LAB._A  
         AEND
         AEND
.*
.* SET VARYING FROM BY UNTIL
.*
         AENTRY SET_FROM_BY_UNTIL
         :&VAR  SETC '&SYSLIST(&I+1)'          SKIP VARYING
         AIF  ('&SYSLIST(&I+2)' NE 'FROM')
              MNOTE 8,'PERFORM VARYING MISSING FROM'
              MEXIT
         AEND
         :&I    SETA &I+3
         :&FROM SETC '&SYSLIST(&I)'
         AIF   ('&FROM' EQ '+' OR '&FROM' EQ '-')
               :&FROM SETC '&SYSLIST(&I)&SYSLIST(&I+1)' RPI 1065
               :&I SETA &I+1
         AEND
         :&I SETA &I+1
         AIF   ('&SYSLIST(&I)' NE 'BY')
               MNOTE 8,'PERFORM VARYING MISSING BY'
               MEXIT
         AEND
         :&I   SETA &I+1
         :&BY  SETC '&SYSLIST(&I)'
         AIF   ('&BY' EQ '+' OR '&BY' EQ '-')
               :&BY SETC '&BY&SYSLIST(&I+1)'   
               :&I SETA &I+1                   
         AEND
         :&I SETA &I+1
         AIF   ('&SYSLIST(&I)' NE 'UNTIL')
               MNOTE 8,'PERFORM VARYING MISSING UNTIL'
               MEXIT
         AEND
         AEND
.*
.* SET_IF_PARMS
.*
         AENTRY SET_IF_PARMS
         :&IF_PARM SETC  '&SYSLIST(&I+1)'
         :&I       SETA  &I+2
         AWHILE (&I LE &NP)
              :&IF_PARM SETC  '&IF_PARM'.','.'&SYSLIST(&I)'
              :&I SETA &I+1
         AEND
         AEND
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/15/08                                                 *
.*********************************************************************
.* 04/15/08 initial coding for global flush pending IF,EVALUATE lvls    
.* 10/06/08 ZSTRMAC
.* 07/14/09 RPI 1064 drop b2's at period if used
.*********************************************************************
         PERIOD    
         COPY  ZC_WS
         AIF (&BASE_B1_USED)               RPI 1065
             :&BASE_B1_USED SETB 0
             GEN_DROP &BASE_B1
         AEND
         AIF (&LBASE_B1_USED)              RPI 1065
             :&LBASE_B1_USED SETB 0
             GEN_DROP &LBASE_B1
         AEND
         AIF (&BASE_B2_USED)               RPI 1065
             :&BASE_B2_USED SETB 0
             GEN_DROP &BASE_B2
         AEND
         AIF (&LBASE_B2_USED)              RPI 1065
             :&LBASE_B2_USED SETB 0
             GEN_DROP &LBASE_B2
         AEND
         :&BASE_LRU     SETA 2   SET HIGH REG FIRST AND SKIP DROP     
         :&BASE_B1_HIGH SETA 0   RESET DYNAMIC WS BASE REGS
         :&BASE_B2_HIGH SETA 0
         :&LBASE_LRU     SETA 2  SET HIGH REG FIRST AND SKIP DROP 
         :&LBASE_B1_HIGH SETA 0  RESET DYNAMIC LK BASE REGS
         :&LBASE_B2_HIGH SETA 0
         AWHILE (&IE_LVL GT 0)
               AIF   (&IE_TYPE(&IE_LVL) EQ 1)        
                     END_IF
               AELSEIF (&IE_TYPE(&IE_LVL) EQ 2)             
                     END_EVALUATE
               AELSEIF (&IE_TYPE(&IE_LVL) EQ 3)               
                     END_READ
               AELSEIF (&IE_TYPE(&IE_LVL) EQ 4)               
                     END_PERFORM
               AELSEIF (&IE_TYPE(&IE_LVL) EQ 11)  RPI 1012             
                     END_ADD
               AELSEIF (&IE_TYPE(&IE_LVL) EQ 12)  RPI 1012             
                     END_SUBTRACT
               AELSEIF (&IE_TYPE(&IE_LVL) EQ 13)  RPI 1012             
                     END_MULTIPLY
               AELSEIF (&IE_TYPE(&IE_LVL) EQ 14)  RPI 1012             
                     END_DIVIDE
               AELSE
                     MNOTE 8,'PERIOD UNKNOWN LEVEL TYPE - &IE_TYPE(&IE_X
               LVL)'
                     MEXIT
               AEND
         AEND
         AIF   (&PERIOD_NEXT)
               :&PERIOD_NEXT SETB 0
               GEN_LABEL PERIOD_NEXT_&PERIOD_NEXT_LAB,NEXT_SENTENCE
         AEND
         MEND

         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/07/08                                                 *
.*********************************************************************
.* 04/07/08 initial coding for z390 target
.* 04/11/08 generate ZC_PROC_START, ZC_PROC_END, ZC_WS_LIST
.* 05/03/08 move ZC_WS_END to DATA END                          
.* 10/06/08 ZSTRMAC
.*********************************************************************
         PROCEDURE &TYPE,&USING
         COPY  ZC_WS
         :&NP SETA N'&SYSLIST
         AIF   ('&TYPE' EQ 'DIVISION')          
               AIF   ('&ZC_PGM' EQ '')                                
                     MNOTE 4,'PROGRAM-ID MISSING NAME MAIN ASSUMED'
                     :&ZC_PGM SETC  'MAIN'
               AEND
               :&PARMS SETC ''
               AIF ('&USING' EQ 'USING')
                   :&PARMS SETC 'USING'
                   :&I SETA 3
                   AWHILE (&I LE &NP)
                       :&PARMS SETC '&PARMS,&SYSLIST(&I)'
                       :&I SETA &I+1
                   AEND 
               AEND
               :&ZC_PGM GEN_PROC_START &PARMS
         AELSEIF   ('&TYPE' EQ 'END')
               GEN_PROC_END     GEN STOP RUN, LITERALS
               ZC_STATS       GEN ZCOBOL COMPILE STATISTICS
         AELSE
               MNOTE 8,'PROCEDURE TYPE NOT RECOGNIZED - &TYPE'
         AEND
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/07/08                                                 *
.*********************************************************************
.* 04/11/08 initial coding for global PROGRAM_ID
.* 10/06/08 ZSTRMAC
.*********************************************************************
         PROGRAM_ID &PGM
         COPY  ZC_WS
         GBLA  &ZC_PGM_CNT
         :&ZC_PGM_CNT SETA &ZC_PGM_CNT+1
         AIF   (&ZC_PGM_CNT GT 1)
               MNOTE 8,'MULTIPLE PGM BATCH COMPILE NOT SUPPORTED YET'
               MEXIT
         AEND
         AIF   ('&PGM' EQ '')        
               MNOTE 4,'PROGRAM-ID MISSING PROGRAM NAME - MAIN ASSUMED'
               :&ZC_PGM SETC  'MAIN'
         AEND
         :&ZC_PGM SETC  '&PGM'
         GEN_ID
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/16/08                                                 *
.*********************************************************************
.* 02/20/09 stub for pending support              
.*********************************************************************
         RD
         MNOTE 8,'RD NOT SUPPORTED YET'
         MEXIT
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/14/08                                                 *
.*********************************************************************
.* 04/14/08 initial coding for global ZCOBOL
.* 10/06/08 ZSTRMAC
.* 09/04/09 RPI 1065 use ZC_FILE_FIND to set FILE_IX
.*********************************************************************
         READ  &FILE
         COPY  ZC_WS
         ZC_FILE_FIND &FILE        RPI 1065
         AIF   (&FILE_IX EQ 0)      
               MNOTE 8,'READ FILE NOT FOUND - &FILE'
               MEXIT
         AEND
         :&NP      SETA  N'&SYSLIST
         :&MOVE    SETC  ''
         :&AT      SETC  ''
         :&PARM_IX SETA 2
         AIF   (&PARM_IX LT &NP)
               AIF   ('&SYSLIST(&PARM_IX)' EQ 'INTO')
                     :&MOVE    SETC  '&SYSLIST(&PARM_IX+1)'
                     :&PARM_IX SETA  &PARM_IX+2
               AEND
               AIF   ('&SYSLIST(&PARM_IX)' EQ 'AT'                     X
                      AND '&SYSLIST(&PARM_IX+1)' EQ 'END')
                     :&AT SETC  'AT' INDICATE AT END FOLLOWS READ
               AELSE
                     MNOTE 8,'READ UNKNOWN OPERAND - &SYSLIST(&PARM_IX)X
               '
                     MEXIT
               AEND
         AEND
         GEN_READ &MOVE,&AT
         MEXIT
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/16/08                                                 *
.*********************************************************************
.* 12/13/08 turn on trace if TRACE option on for compile (OS/VS)             
.*********************************************************************
         READY
         COPY  ZC_WS
         AIF   ('&SYSLIST(1)' NE 'TRACE')
               MNOTE 8,'READY TRACE OPTION NOT FOUND'
               MEXIT
         AEND
         AIF   (&ZC_TRACE) TURN ON IF TRACE OPTION ACTIVE
               MOVE  'T',TO,READY_RESET_TRACE
         AEND
         MEXIT
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/16/08                                                 *
.*********************************************************************
.* 02/20/09 stub for pending support              
.*********************************************************************
         RECEIVE
         MNOTE 8,'RECEIVE NOT SUPPORTED YET'
         MEXIT
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/16/08                                                 *
.*********************************************************************
.* 11/17/08 stub for pending support              
.*********************************************************************
         RELEASE
         MNOTE 8,'RELEASE NOT SUPPORTED YET'
         MEXIT
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/16/08                                                 *
.*********************************************************************
.* 12/13/08 stub for pending support              
.*********************************************************************
         REMARKS
         MNOTE 8,'REMARKS REPLACED BY COMMENTS WITH * IN POS. 7'
         MEXIT
         MEND
         MACRO
.*********************************************************************
.* Copyright 2009 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 08/18/09                                                 *
.*********************************************************************
.* 08/18/09 stub for pending support              
.*********************************************************************
         REPLACE
         MNOTE 8,'REPLACE NOT SUPPORTED YET'
         MEXIT
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/16/08                                                 *
.*********************************************************************
.* 02/20/09 stub for pending support              
.*********************************************************************
         REPORT
         MNOTE 8,'REPORT NOT SUPPORTED YET'
         MEXIT
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/16/08                                                 *
.*********************************************************************
.* 12/13/08 reset paragraph name trace (OS/VS COBOL)              
.*********************************************************************
         RESET
         COPY ZC_WS
         AIF   ('&SYSLIST(1)' NE 'TRACE')
               MNOTE 8,'READY TRACE OPTION NOT FOUND'
               MEXIT
         AEND
         AIF   (&ZC_TRACE) TURN OFF IF TRACE OPTION ACTIVE
               MOVE  'F',TO,READY_RESET_TRACE
         AEND
         MEXIT
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/07/08                                                 *
.*********************************************************************
.* 04/11/08 initial coding for global RETURN
.*********************************************************************
         RETURN
         GEN_RETURN
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/16/08                                                 *
.*********************************************************************
.* 11/17/08 stub for pending support              
.*********************************************************************
         REWRITE
         MNOTE 8,'REWRITE NOT SUPPORTED YET'
         MEXIT
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/16/08                                                 *
.*********************************************************************
.* 02/20/09 stub for pending support              
.*********************************************************************
         SEARCH
         MNOTE 8,'SEARCH NOT SUPPORTED YET'
         MEXIT
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/16/08                                                 *
.*********************************************************************
.* 02/20/09 stub for pending support              
.*********************************************************************
         SECURITY
         MEXIT
         MEND
        MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/07/08                                                 *
.*********************************************************************
.* 04/07/08 initial coding for global ZCOBOL
.* 10/06/08 ZSTRMAC
.* 01/02/09 add optional OPTIONAL, and default ORGANIZATION LINE SEQ.
.* 09/07/09 RPI 1065 allow options in any order                       
.*********************************************************************
.* Add file name, ddname or dsname, and recfm to file table.
.* See FD which generated DCB in WS and adds record name to file table.
.* Notes:
.*   1.  RECFM/BLKSIZE set at open after WS defines record name
.*********************************************************************
         SELECT 
         COPY  ZC_WS
         :&STATUS  SETC '' NO DEFAULT FILE STATUS FIELD
         :&PARM_IX SETA 1
         AIF   ('&SYSLIST(&PARM_IX)' EQ 'OPTIONAL')
               :&PARM_IX SETA &PARM_IX+1            IGNORE OPTIONAL
         AEND
         :&FILE SETC '&SYSLIST(&PARM_IX)'
         :&PARM_IX SETA &PARM_IX+1
         AIF   ('&SYSLIST(&PARM_IX)' NE 'ASSIGN')
               MNOTE 8,'SELECT ASSIGN TO NOT FOUND'
               MEXIT
         AEND
         :&PARM_IX SETA &PARM_IX+1
         AIF   ('&SYSLIST(&PARM_IX)' EQ 'TO')
               :&PARM_IX SETA &PARM_IX+1
         AEND
         :&DDNAME SETC '&SYSLIST(&PARM_IX)'
         :&PARM_IX SETA &PARM_IX+1
         :&FILE_TOT SETA &FILE_TOT+1
         :&FILE_NAME(&FILE_TOT) SETC '&FILE'
         :&FILE_DDNAME(&FILE_TOT) SETC '&DDNAME'
         :&ORG    SETC 'QSAM' QSAM,LSEQ,RRDS,KSDS
         :&MODE   SETC 'SEQ'  SEQ,RAN,DYN
         :&KEY    SETC '' INDEXED  KEY FIELD
         :&XRBA   SETC '' RELATIVE KEY FIELD
.*
.* PROCESS OPTIONAL PARMS IN ANY ORDER
.*
       AWHILE  ('&SYSLIST(&PARM_IX)' NE '')
         AIF   ('&SYSLIST(&PARM_IX)' EQ 'ORGANIZATION')
               :&PARM_IX SETA &PARM_IX+1
               AIF ('&SYSLIST(&PARM_IX)' EQ 'IS') 
                   :&PARM_IX SETA &PARM_IX+1
               AEND  
               AIF   ('&SYSLIST(&PARM_IX)' EQ 'LINE'                   X
                      AND '&SYSLIST(&PARM_IX+1)' EQ 'SEQUENTIAL')
                     :&ORG  SETC 'LSEQ'
                     :&MODE SETC 'SEQ'
                     :&PARM_IX SETA &PARM_IX+2
               AELSEIF ('&SYSLIST(&PARM_IX)' EQ 'SEQUENTIAL')
                     :&ORG SETC 'QSAM'        
                     :&PARM_IX SETA &PARM_IX+1
               AELSEIF ('&SYSLIST(&PARM_IX)' EQ 'INDEXED')
                     :&ORG SETC 'KSDS'        
                     :&PARM_IX SETA &PARM_IX+1
               AELSEIF ('&SYSLIST(&PARM_IX)' EQ 'RELATIVE')
                     :&ORG SETC 'RRDS'        
                     :&PARM_IX SETA &PARM_IX+1
               AELSE
                     MNOTE 8,'SELECT UNKNOWN ORGANIZATION TYPE = &SYSLIX
               ST(&PARM_IX)'
                     :&PARM_IX SETA N'&SYSLIST+1
               AEND
         AELSEIF ('&SYSLIST(&PARM_IX)' EQ 'ACCESS')
               :&PARM_IX SETA &PARM_IX+1
               AIF ('&SYSLIST(&PARM_IX)' EQ 'MODE') 
                   :&PARM_IX SETA &PARM_IX+1
               AEND
               AIF ('&SYSLIST(&PARM_IX)' EQ 'IS') 
                   :&PARM_IX SETA &PARM_IX+1
               AEND
               AIF ('&SYSLIST(&PARM_IX)' EQ 'SEQUENTIAL') 
                   :&PARM_IX SETA &PARM_IX+1
                   :&MODE SETC 'SEQ'
               AELSEIF ('&SYSLIST(&PARM_IX)' EQ 'DYNAMIC') 
                   :&PARM_IX SETA &PARM_IX+1
                   :&MODE SETC 'DYN'
               AELSEIF ('&SYSLIST(&PARM_IX)' EQ 'RANDOM') 
                   :&PARM_IX SETA &PARM_IX+1
                   :&MODE SETC 'RAN'
               AELSE
                   MNOTE 8,'SELECT ACCESS MODE UNKNOWN - &SYSLIST(&PARMX
               _IX)'
                   :&PARM_IX SETA N'&SYSLIST+1
               AEND
         AELSEIF ('&SYSLIST(&PARM_IX)' EQ 'RECORD')
               :&PARM_IX SETA &PARM_IX+1
               AIF ('&SYSLIST(&PARM_IX)' EQ 'KEY')
                   :&PARM_IX SETA &PARM_IX+1
               AEND    
               AIF ('&SYSLIST(&PARM_IX)' EQ 'IS')
                   :&PARM_IX SETA &PARM_IX+1
               AEND    
               :&KEY SETC '&SYSLIST(&PARM_IX)'
               :&PARM_IX SETA &PARM_IX+1
         AELSEIF ('&SYSLIST(&PARM_IX)' EQ 'RELATIVE')
               :&PARM_IX SETA &PARM_IX+1
               AIF ('&SYSLIST(&PARM_IX)' EQ 'KEY')
                   :&PARM_IX SETA &PARM_IX+1
               AEND    
               AIF ('&SYSLIST(&PARM_IX)' EQ 'IS')
                   :&PARM_IX SETA &PARM_IX+1
               AEND    
               :&XRBA SETC '&SYSLIST(&PARM_IX)'
               :&PARM_IX SETA &PARM_IX+1
         AELSEIF ('&SYSLIST(&PARM_IX)' EQ 'FILE'                       X
               OR '&SYSLIST(&PARM_IX)' EQ 'STATUS')
               :&PARM_IX SETA &PARM_IX+1
               AIF ('&SYSLIST(&PARM_IX)' EQ 'STATUS')
                   :&PARM_IX SETA &PARM_IX+1
               AEND
               AIF ('&SYSLIST(&PARM_IX)' EQ 'IS') 
                   :&PARM_IX SETA &PARM_IX+1
               AEND
               :&STATUS SETC '&SYSLIST(&PARM_IX)'
               :&PARM_IX SETA &PARM_IX+1
         AELSE
               MNOTE 8,'SELECT UNKNOWN OPTION - &SYSLIST(&PARM_IX)'
               :&PARM_IX SETA N'&SYSLIST+1
         AEND
       AEND
.*
.* SAVE FILE INFO
.*
       :&FILE_ORG(&FILE_TOT)    SETC '&ORG' 
       :&FILE_MODE(&FILE_TOT)   SETC '&MODE' 
       :&FILE_KEY(&FILE_TOT)    SETC '&KEY' 
       :&FILE_XRBA(&FILE_TOT)   SETC '&XRBA' 
       :&FILE_STATUS(&FILE_TOT) SETC '&STATUS'
       AIF     ('&SYSLIST(&PARM_IX)' NE '')
               MNOTE 8,'SELECT UNKNOWN OPTION - &SYSLIST(&PARM_IX)'
               MEXIT
       AEND
       
.*
.* VALIDATE LINE SEQUENTIAL ASCII TEXT FILE TO/FROM FIXED RECORD
.*
       AIF ('&ORG' EQ 'LSEQ')
           AIF ('&MODE' NE 'SEQ')
               MNOTE 8,'SELECT INVALID LINE SEQUENTIAL MODE - &MODE'
               MEXIT
           AEND
           AIF ('&KEY' NE '')
               MNOTE 8,'SELECT INVALID LINE SEQUENTIAL KEY - &KEY'
               MEXIT
           AEND
           AIF ('&XRBA' NE '')
               MNOTE 8,'SELECT INVALID LINE SEQUENTIAL XRBA - &XRBA'
               MEXIT
           AEND
       AELSEIF ('&ORG' EQ 'QSAM')
           AIF ('&MODE' NE 'SEQ')
               MNOTE 8,'SELECT INVALID SEQUENTIAL MODE - &MODE'
               MEXIT
           AEND
           AIF ('&KEY' NE '')
               MNOTE 8,'SELECT INVALID SEQUENTIAL KEY - &KEY'
               MEXIT
           AEND
           AIF ('&XRBA' NE '')
               MNOTE 8,'SELECT INVALID SEQUENTIAL XRBA - &XRBA'
               MEXIT
           AEND
       AELSEIF ('&ORG' EQ 'KSDS')
           AIF ('&KEY' EQ '')
               MNOTE 8,'SELECT INVALID INDEXED KEY - &KEY'
               MEXIT
           AEND
       AELSEIF ('&ORG' EQ 'RRDS')
           AIF ('&KEY' NE '')
               MNOTE 8,'SELECT INVALID RELATIVE KEY - &KEY'
               MEXIT
           AEND
           AIF ('&XRBA' EQ '' AND '&MODE' NE 'SEQ')
               MNOTE 8,'SELECT INVALID RELATIVE XRBA - &XRBA'
               MEXIT
           AEND
       AELSE
         MNOTE 8,'SELECT ORG NOT SUPPORTED YET - &ORG'
         MEXIT
       AEND
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/16/08                                                 *
.*********************************************************************
.* 02/20/09 stub for pending support              
.*********************************************************************
         SEND  
         MNOTE 8,'SEND NOT SUPPORTED YET'
         MEXIT
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/16/08                                                 *
.*********************************************************************
.* 02/23/09 initial coding for global SET         
.*********************************************************************
         SET      
         COPY  ZC_WS                      
         :&PARM_IX SETA 1
         AWHILE (&PARM_IX LT N'&SYSLIST)
                AIF   ('&SYSLIST(&PARM_IX)' EQ 'TO')
                      :&LAST_PARM   SETA &PARM_IX-1
                      :&SOURCE_PARM SETA &PARM_IX+1
                      AIF ('&SYSLIST(&SOURCE_PARM)' EQ 'TRUE')
                          :&TYPE SETA 2
                      AELSE
                          :&TYPE SETA 1
                      AEND
                      AEXIT AWHILE
                AELSEIF ('&SYSLIST(&PARM_IX)' EQ 'UP'                  X
                         AND '&SYSLIST(&PARM_IX+1)' EQ 'BY')
                      :&LAST_PARM SETA &PARM_IX-1
                      :&SOURCE_PARM SETA &PARM_IX+2
                      :&TYPE SETA 3
                      AEXIT AWHILE
                AELSEIF ('&SYSLIST(&PARM_IX)' EQ 'DOWN'                X
                        AND '&SYSLIST(&PARM_IX+1)' EQ 'BY')
                      :&LAST_PARM SETA &PARM_IX-1
                      :&SOURCE_PARM SETA &PARM_IX+2
                      :&TYPE SETA 4
                      AEXIT AWHILE
                AELSE
                      :&PARM_IX SETA &PARM_IX+1
                AEND
         AEND
         AIF   (&TYPE EQ 0)
               MNOTE 8,'SET MISSING TO, UP BY, OR DOWN BY'
               MEXIT
         AEND
         :&PARM_IX SETA &SOURCE_PARM
         :&FIELD_REG SETC 'ZC_R3'
         :&FIELD_SS1 SETB 0
         ACALL GET_PARM_FIELD
         :&SOURCE    SETC '&FIELD_NAME'
         :&SOURCE_IX SETA &FIELD_IX
         :&PARM_IX SETA 1
         AWHILE (&PARM_IX LE &LAST_PARM)
               AIF (&SOURCE_IX GT 0 AND &PARM_IX GT 1)
                   GEN_BASE &SOURCE_IX
               AEND
               :&FIELD_REG SETC 'ZC_R2'
               :&FIELD_SS1 SETB 1
               ACALL GET_PARM_FIELD
               AIF   (&FIELD_IX GT 0)
                     :&TARGET SETC '&FIELD_NAME'
                     :&TARGET_IX SETA &FIELD_IX
               AELSE
                     MNOTE 8,'SET MISSING TARGET FIELD - &SYSLIST(1)'
                     MEXIT
               AEND
               GEN_SET &TYPE,&TARGET,&TARGET_IX,&SOURCE,&SOURCE_IX
         AEND
         MEXIT
         COPY  ZCGETFLD
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/16/08                                                 *
.*********************************************************************
.* 11/17/08 stub for pending support              
.*********************************************************************
         SORT
         MNOTE 8,'SORT NOT SUPPORTED YET'
         MEXIT
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/16/08                                                 *
.*********************************************************************
.* 04/16/08 initial coding for global SOURCE-COMPUTER
.*********************************************************************
         SOURCE_COMPUTER     
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/16/08                                                 *
.*********************************************************************
.* 01/02/09 initial coding for gobal SPECIAL-NAMES
.*********************************************************************
         SPECIAL_NAMES            
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/07/08                                                 *
.*********************************************************************
.* 04/09/08 initial coding for global STOP RUN
.*********************************************************************
         STOP  &RUN
         GEN_STOP &RUN
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/16/08                                                 *
.*********************************************************************
.* 11/17/08 stub for pending support              
.*********************************************************************
         STRING
         MNOTE 8,'STRING NOT SUPPORTED YET'
         MEXIT
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/07/08                                                 *
.*********************************************************************
.* 10/28/08 initial coding for global SUBTRACT
.* 12/22/08 use ZCGETFLD to get field with qual,base,subscript
.* 02/15/09 use ADD as model for mult source and target support       
.* 02/26/09 RPI 1012 move onsize end-add pending to SUBTRACT           
.* 08/09/09 RPI 1065 add ACTR for mult operands                        
.*********************************************************************
         SUBTRACT
         COPY  ZC_WS
         :&PARM_IX SETA 2
         :&NP      SETA N'&SYSLIST
         :&FROM_IX   SETA 0
         :&GIVING_IX SETA 0
         :&ROUNDED   SETB 0
         :&ONSIZE    SETB 0
         :&LAST_PARM SETA 0
         AWHILE (&PARM_IX LT &NP)
               ACTR 10000      
               AIF ('&SYSLIST(&PARM_IX)' EQ 'FROM')
                   :&FROM_IX SETA &PARM_IX
               AELSEIF ('&SYSLIST(&PARM_IX)' EQ 'GIVING')
                   :&GIVING_IX SETA &PARM_IX
               AELSEIF ('&SYSLIST(&PARM_IX)' EQ 'ROUNDED')
                   :&ROUNDED SETB 1
                   AIF (&LAST_PARM EQ 0)
                       :&LAST_PARM SETA &PARM_IX-1
                   AEND
               AELSEIF ('&SYSLIST(&PARM_IX)' EQ 'ON'                   X
                        AND '&SYSLIST(&PARM_IX+1)' EQ 'SIZE'           X
                        AND '&SYSLIST(&PARM_IX+2)' EQ 'ERROR')
                   :&ONSIZE SETB 1
                   AIF (&LAST_PARM EQ 0)
                       :&LAST_PARM SETA &PARM_IX-1
                   AEND
                   :&PARM_IX SETA &PARM_IX+2
               AELSEIF ('&SYSLIST(&PARM_IX)' EQ 'SIZE'                 X
                        AND '&SYSLIST(&PARM_IX+1)' EQ 'ERROR')
                   :&ONSIZE SETB 1
                   AIF (&LAST_PARM EQ 0)
                       :&LAST_PARM SETA &PARM_IX-1
                   AEND
                   :&PARM_IX SETA &PARM_IX+1
               AEND
               :&PARM_IX SETA &PARM_IX+1
         AEND
         AIF   (&LAST_PARM GT 0)
               :&NP SETA &LAST_PARM
         AEND
         AIF   (&FROM_IX EQ 0)
               MNOTE 8,'SUBTRACT MISSING FROM'
               MEXIT
         AEND
         AIF   (&ONSIZE)
               :&IE_LVL  SETA  &IE_LVL+1         ADD PENDING END_SUB
               :&IE_TYPE(&IE_LVL) SETA 12        FOR END_SUB OR PERIOD
               :&SUB_LAB SETA &SUB_LAB+1
               :&IE_TCNT(&IE_LVL) SETA &SUB_LAB
         AEND
         AIF   (&GIVING_IX GT 0)  SUBTRACT S1+ FROM S2 GIVING S3+
               ACALL SUB_GIVING
         AELSE
               ACALL SUB_FROM
         AEND
         AIF   (&ONSIZE)
               GEN_ONSIZE_START SUB
         AEND
         MEXIT
.*
.* SUB GIVING
.*
         AENTRY SUB_GIVING
         :&S1_PARM_IX SETA 1
         :&S2_PARM_IX SETA &FROM_IX+1
         :&S3_PARM_IX SETA &GIVING_IX+1
         :&S1_OK SETB 1
         :&S2_OK SETB 1
         :&S3_OK SETB 1
         ACALL GET_S1
         ACALL GET_S2
         ACALL GET_S3
         AWHILE (&S1_OK AND &S2_OK AND &S3_OK)
               GEN_MOVE &S3,&S3_IX,&S2,&S2_IX
               GEN_SUB  &S3,&S3_IX,&S1,&S1_IX,&ROUNDED,&ONSIZE
               ACALL GET_S1
               AWHILE (&S1_OK)
                   GEN_SUB  &S3,&S3_IX,&S1,&S1_IX,&ROUNDED,&ONSIZE
                   ACALL GET_S1
               AEND
               ACALL GET_S3
               AIF (&S3_OK)
                   :&S1_PARM_IX SETA 1
                   :&S1_OK SETB 1
                   ACALL GET_S1
               AEND
         AEND
         AEND
.*
.* SUB FROM
.*
         AENTRY SUB_FROM
         :&S1_PARM_IX SETA 1
         :&S2_PARM_IX SETA &FROM_IX+1
         :&S1_OK SETB 1
         :&S2_OK SETB 1
         ACALL GET_S1
         ACALL GET_S2
         AWHILE (&S1_OK AND &S2_OK)
               GEN_SUB  &S2,&S2_IX,&S1,&S1_IX,&ROUNDED,&ONSIZE
               ACALL GET_S1
               AWHILE (&S1_OK)
                   GEN_SUB  &S2,&S2_IX,&S1,&S1_IX,&ROUNDED,&ONSIZE
                   ACALL GET_S1
               AEND
               ACALL GET_S2
               AIF (&S2_OK)
                   :&S1_PARM_IX SETA 1
                   :&S1_OK SETB 1
                   ACALL GET_S1
               AEND
         AEND
         AEND
.*
.* GET S1
.*
         AENTRY GET_S1
         :&PARM_IX SETA &S1_PARM_IX
         AIF   (&PARM_IX EQ &FROM_IX)
               :&S1_OK SETB 0
               AEXIT AENTRY
         AEND
         :&FIELD_REG SETC 'ZC_R1'         S1 IN R1
         :&FIELD_SS1 SETB 0
         ACALL GET_PARM_FIELD
         :&S1_PARM_IX SETA &PARM_IX
         :&S1    SETC  '&FIELD_NAME'
         :&S1_IX SETA  &FIELD_IX
         AEND
.*
.* GET S2
.*
         AENTRY GET_S2
         :&PARM_IX SETA &S2_PARM_IX
         AIF (&PARM_IX GT &NP)
             :&S2_OK SETB 0
             AEXIT AENTRY
         AEND
         :&FIELD_REG SETC 'ZC_R2'               S2 IN R2
         :&FIELD_SS1 SETB 0
         ACALL GET_PARM_FIELD
         :&S2_PARM_IX SETA &PARM_IX
         :&S2 SETC '&FIELD_NAME'
         :&S2_IX SETA  &FIELD_IX
         AEND
.*
.* GET S3
.*
         AENTRY GET_S3
         :&PARM_IX SETA &S3_PARM_IX
         AIF (&PARM_IX GT &NP)
             :&S3_OK SETB 0
             AEXIT AENTRY
         AEND
         :&FIELD_REG SETC 'ZC_R3'            S3 IN R3
         :&FIELD_SS1 SETB 0
         ACALL GET_PARM_FIELD
         :&S3_PARM_IX SETA &PARM_IX
         :&S3 SETC '&FIELD_NAME'
         :&S3_IX SETA  &FIELD_IX
         AEND
         COPY ZCGETFLD
         MEND
         MACRO
.*********************************************************************
.* Copyright 2009 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 08/02/09                                                 *
.*********************************************************************
.* 08/03/09 stub for pending support              
.*********************************************************************
         SYMBOLIC 
         MNOTE 8,'SYMBOLIC NOT SUPPORTED YET'
         MEXIT
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/16/08                                                 *
.*********************************************************************
.* 02/20/09 stub for pending support              
.*********************************************************************
         TERMINATE
         MNOTE 8,'TERMINATE NOT SUPPORTED YET'
         MEXIT
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/16/08                                                 *
.*********************************************************************
.* 11/17/08 stub for pending support              
.* 01/20/09 replace with call to INSPECT CONVERTING
.*********************************************************************
         TRANSFORM  
         COPY  ZC_WS
         :&PARM_IX SETA 1
         :&FIELD_REG SETC 'ZC_R2'  R2=V1 INSPECT FIELD IF SUBSCRIPTED
         :&FIELD_SS1 SETB 0
         ACALL GET_PARM_FIELD
         AIF   (&FIELD_IX EQ 0)
               MNOTE 8,'TRANSFORM FIELD NOT FOUND &SYSLIST(1)'
               MEXIT
         AEND
         :&V1    SETC '&FIELD_NAME'
         :&V1_IX SETA &FIELD_IX
         AIF   ('&SYSLIST(&PARM_IX)' EQ 'CHARACTERS'                   X
                AND '&SYSLIST(&PARM_IX+1)' EQ 'FROM')
                :&PARM_IX SETA &PARM_IX+2
         AELSE
               MNOTE 8,'TRANSFORM CHARACTERS FROM '..' TO '..' ERROR'
               MEXIT
         AEND
         :&FIELD_REG SETC 'ZC_R3'
         :&FIELD_SS1 SETB 0
         ACALL GET_PARM_FIELD
         AIF   (&FIELD_IX EQ 0                                         X
               AND '&FIELD_NAME'(1,1) NE '''')
               MNOTE 8,'TRANSFORM FROM FIELD NOT FOUND'
               MEXIT
         AEND
         :&V2    SETC '&FIELD_NAME'
         :&V2_IX SETA &FIELD_IX
         AIF   ('&SYSLIST(&PARM_IX)' NE 'TO')
               MNOTE 8,'TRANSFORM MISSING TO'
               MEXIT
         AEND
         :&PARM_IX SETA &PARM_IX+1
         :&FIELD_REG SETC 'ZC_R14'
         :&FIELD_SS1 SETB 0
         ACALL GET_PARM_FIELD
         AIF   (&FIELD_IX EQ 0                                         X
               AND '&FIELD_NAME'(1,1) NE '''')
              MNOTE 8,'TRANSFORM MISSING TO FIELD'
              MEXIT
         AEND
         :&V3 SETC '&FIELD_NAME'
         :&V3_IX SETA &FIELD_IX
         GEN_INSPECT CONVERTING,&V1,&V1_IX,&V2,&V2_IX,&V3,&V3_IX,,,0
         COPY ZCGETFLD
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/16/08                                                 *
.*********************************************************************
.* 11/17/08 stub for pending support              
.*********************************************************************
         UNSTRING
         MNOTE 8,'UNSTRING NOT SUPPORTED YET'
         MEXIT
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/16/08                                                 *
.*********************************************************************
.* 02/26/09 RPI 1012 stub for pending support              
.*********************************************************************
         ENABLE
         MNOTE 8,'USE NOT SUPPORTED YET'
         MEXIT
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/07/08                                                 *
.*********************************************************************
.* 04/09/08 initial coding for global WHEN
.* 10/06/08 ZSTRMAC
.*********************************************************************
         WHEN  &VAL  
         COPY  ZC_WS
         AIF   (&IE_LVL LT 1)
               MNOTE 8,'WHEN MISSING EVALUATE'
               MEXIT
         AEND
         AIF   (&IE_TYPE(&IE_LVL) NE 2)
               MNOTE 8,'WHEN MISSING EVALUATE'
               MEXIT
         AEND
         :&IE_WHEN(&IE_LVL) SETA &IE_WHEN(&IE_LVL)+1
         AIF   (&IE_WHEN(&IE_LVL) GT 1)                
               GEN_B EVAL&IE_EVAL(&IE_LVL)._END
         AEND
         GEN_LABEL EVAL&IE_EVAL(&IE_LVL)._WHEN&IE_WHEN(&IE_lVL),WHEN
         AIF   ('&VAL' NE 'OTHER')
               GEN_COMP &SYM_NAME(&IE_EVAL_IX(&IE_LVL)),&IE_EVAL_IX(&IEX
               _LVL),&VAL,0
               :&NEXT_WHEN SETA  &IE_WHEN(&IE_LVL)+1
               GEN_BC   ZC_NE,EVAL&IE_EVAL(&IE_LVL)._WHEN&NEXT_WHEN
         AEND
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/07/08                                                 *
.*********************************************************************
.* 04/07/08 initial coding for z390 target
.* 06/02/09 reset global &FILE_IX at start of working-storage
.*          see zcobol\test\TESTFIL1.CBL regression test
.*********************************************************************
         WORKING_STORAGE &SECT
         COPY ZC_WS
               :&FILE_IX SETA 0
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/14/08                                                 *
.*********************************************************************
.* 04/14/08 initial coding for global ZCOBOL
.* 04/30/08 change SYM_FILE_IX to SYM_REF    
.* 10/06/08 ZSTRMAC
.* 07/09/09 RPI 1065 move FILE_IX from SYM_REF to SYM_FD for groups
.*********************************************************************
         WRITE &RECORD
         COPY  ZC_WS
         :&NP  SETA  N'&SYSLIST
         AIF   (&NP GT 1 AND '&SYSLIST(2)' EQ 'FROM')
               MOVE  &SYSLIST(3),TO,&RECORD
         AEND
         ZC_SYM_FIND &RECORD
         AIF   (&SYM_IX EQ 0)
               MNOTE 8,'WRITE RECORD NOT FOUND - &RECORD'
               MEXIT
         AEND
         :&FILE_IX SETA  &SYM_FD(&SYM_IX)  RPI 1065
         AIF   (&FILE_IX EQ 0)
               MNOTE 8,'WRITE RECORD NOT A FILE RECORD - &RECORD'
               MEXIT
         AEND
         GEN_WRITE &RECORD
         MEXIT
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/07/08                                                 *
.*********************************************************************
.* 04/08/08 initial coding to build global WS definition 
.* 04/30/08 add 88's, change SYM_FILE_IX to SYM_REF, add SYM_LVL
.* 05/01/08 add PIC_TYPE support for DEFHPXZ based on PIC,VALUE,
.*          USAGE, and OCCURS clauses (REDEFINES pending)                                  
.* 05/18/08 add REDEFINE support                                
.* 06/10/08 add USAGE IS POINTER support                        
.* 06/10/08 add INDEXED BY support                        
.* 10/06/08 ZSTRMAC, GROUP OCCURS, USAGE, DUP SYM IN DIFF LEVELS
.* 12/03/08 add level 91 filename 
.* 12/21/08 inc SYM_FILLER_VAL_CNT for label used by CICS GEN_INIT_WS 
.* 01/08/09 set SYM_SIT used by ZCGETFLD.CPY subscript parser
.* 02/23/09 RPI 1001 set SYM_LOC for 88 to first V88 value index
.* 02/25/09 RPI 1002 change index data items from type A to I     
.* 02/26/09 RPI 1012 add support for VALUE ALL clause, 66 RENAMES,
.* 02/27/09 RPI 1012 support SIGN LEADING/TRAILING SEPARATE CHARACTER
.* 02/27/09 RPI 1012 support single & in text literal (double it)    
.* 03/06/09 RPI 1004 add HFP/BFP/DFP/FLOAT-SHORT/LONG/EXTENDED        
.* 03/11/09 RPI 1004 add COMP PIC S9(39) type Q 16 byte 128 bit int
.* 03/20/09 RPI 1004 rename explicit 1-9 FLOAT-HEX/BINARY/DECIMAL-N
.* 04/29/09 RPI 1032 issue error if PIC clause has quote or no 9ZX      
.* 06/20/09 RPI 1042 add computational                                  
.* 07/09/09 RPI 1065 move FILE_IX from SYM_REF to SYM_FD to supp groups 
.* 07/19/09 RPI 1065 add SYNC clause                                        
.* 07/23/09 RPI 1065 add support for P assumed decimal point in PIC         
.* 07/25/09 RPI 1065 gen 2 quotes in value for WS_GEN to gen 1 quote        
.* 08/02/09 RPI 1065 check for duplicates and allow 01/nn level dups        
.* 08/08/09 RPI 1065 make BY in INDEXED BY optional                         
.* 08/08/09 RPI 1065 support DISPLAY clause (its the default)               
.* 08/08/09 RPI 1065 use SCALE_NUM_LIT to scale PIC_VAL for FGHPQZ               
.* 08/12/09 RPI 1065 set SYM_FXT to head of duplicate symbol list                
.* 08/17/09 RPI 1065 support 88 level VALUES ARE n1 THRU n2                      
.* 08/18/09 RPI 1065 add clauses JUSTIFIED, LEADING, TRAILING,                   
.*          ASCENDING, DESCENDING, BLANK WHEN ZERO
.* 10/12/09 RPI 1090 CORRECT COMP-4/COMP-5 TO COMP_4/COMP_5 FOR COMP
.*********************************************************************
.* 
.* WS level,name,clauses in any order (PIC,VALUE,USAGE supported)
.* Notes:
.*   1.  If name omitted FILLER is assumed.
.*   2.  For 88 level, must follow WS item, only VALUE or VALUES
.*   3.  Level 77 treated like 01
.*   4.  S9(4) COMP = H, S9(9) COMP = F, S9(18) COMP = G (FL8)
.*   5.  REDEFINE sets &WS_LVL_RDEF flag and &WS_LVL_RDEF_END
.*   6.  USAGE   on group propagated to lower level items
.*   6.  OCCURS on group duplicates calculated length at end of group
.*   7.  VALUE QUOTE(S) assumes APOST(') vs QUOTE(") for now  
.*   8.  PIC_TYPE 123=HFP,456=BFP,789=DFP
.*   9.  PIC_TYPE Q COMP PIC S9(3) QUADWORD 16 byte 128 bit integer
.*********************************************************************
         WS    &LEVEL,&NAME
         COPY  ZC_WS            
         :&NEW_LVL_NO SETA  '&LEVEL'   MAY CHANGE FROM 77 TO 01
         :&NEW_SYM    SETC  '&NAME'    MAY CHANGE FROM ?  TO FILLER
         :&ERR_ID     SETC  '&NEW_LVL_NO &NEW_SYM'
         :&REF_IX     SETA  0
         :&PIC_SEP    SETB  0 SEPARATE SIGN
         :&PIC_LEAD   SETB  0 LEADING
         :&PIC_TRAIL  SETB  0 TRAILING
         AIF   (&NEW_LVL_NO EQ 88)     CONDITION VALUES
               ACALL WS_88             
               MEXIT
         AELSEIF (&NEW_LVL_NO EQ 66)   RENAMES
               ACALL WS_66
               MEXIT
         AEND
         AIF   (&NEW_LVL_NO EQ 91)
               :&NEW_LVL_NO  SETA 1 
               :&CUR_SET_LVL SETA 0
               ACALL WS_END_PRIOR
               :&NEW_LVL_NO  SETA 91
               ACALL WS_91_FILE  ADD FILE DCB 
               MEXIT
         AEND
         AIF   (&NEW_LVL_NO EQ 77)
               :&NEW_LVL_NO SETA 1  TREAT 77 LIKE 01
         AEND
         AIF   (&NEW_LVL_NO EQ 1)
               :&CUR_SET_LVL SETA 0  RESET CURRENT SUBSCRIPT LVL
         AEND
         ACALL WS_END_PRIOR
.*
.*       ADD NEW LEVEL # AT SAME OR HIGHER LEVEL
.*
         AIF   (&WS_LVL EQ 0)
               ACALL WS_ADD_LVL
         AELSEIF (&NEW_LVL_NO GT &WS_LVL_NO(&WS_LVL))
               ACALL WS_ADD_LVL
         AEND
         AIF   (&WS_LVL EQ 1)
               :&WS_LVL_RDEF(1) SETB 0   RESET REDEFINE AT LVL 1
               :&WS_LVL_USE(1)  SETC ''  RESET GROUP USAGE AT LVL 1
         AEND
         ACALL WS_STORE_NN
         AIF (&FILE_IX GT 0)
             AIF (&FILE_RECORD(&FILE_IX) EQ '')
                 :&FILE_RECORD(&FILE_IX) SETC '&SYM_NAME(&SYM_TOT)'
             AEND
         AEND
         AIF   (&WS_LVL EQ 1 AND '&PIC' EQ '')
               :&WS_LVL_USE(1) SETC '&USAGE' SET NEW LVL 1 USAGE DEF
         AEND
         :&WS_LVL_SYM_IX(&WS_LVL) SETA &SYM_TOT   WS_LVL SYM INDEX
         MEXIT
.*
.* END PRIOR
.*
         AENTRY WS_END_PRIOR
         :&WS_LOC_SAVE SETA &WS_LOC
         AIF  (&WS_LVL GT 0)
.*
.*            END HIGHER LEVEL # GROUPS/REDEF ITEMS
.*
              ACALL WS_END_NN  
.*
.*            END REDEFINE AT SAME LEVEL # IF ANY
.*
              AIF   (&WS_LVL_RDEF(&WS_LVL)                             X  
                    AND &WS_LOC GE &WS_LVL_RDEF_END(&WS_LVL))
                    :&WS_LVL_RDEF(&WS_LVL) SETB 0                 
              AEND
         AEND
         AEND
.*
.* END ALL HIGHER LEVEL WS GROUP AND REDEFINE ITEMS
.*
         AENTRY WS_END_NN
         AWHILE (&WS_LVL GT 1 AND &NEW_LVL_NO LT &WS_LVL_NO(&WS_LVL))
              ACALL WS_END_GROUP                   
              AIF (&WS_LVL_RDEF(&WS_LVL))
                  ACALL WS_END_REDEFINE
              AEND
              :&WS_LVL SETA &WS_LVL-1
         AEND
         AIF   (&WS_LVL_SYM_IX(&WS_LVL) GT 0)
               ACALL WS_END_GROUP
         AEND
         AIF   (&WS_LVL_RDEF(&WS_LVL)                                  X
                AND &WS_LOC GE &WS_LVL_RDEF_END(&WS_LVL))
              :&WS_LVL_RDEF(&WS_LVL) SETB 0  END REDEFINE
         AEND
         AEND
.*
.* WS END GROUP - SET SYM_LEN AND WS_LOC IF GROUP OCCURS > 1
.*
         AENTRY WS_END_GROUP
         :&IX SETA  &WS_LVL_SYM_IX(&WS_LVL)
       AIF  (&IX GT 0)
         AIF (&SYM_LEN(&IX) EQ 0)                     IS THIS GROUP LVL
             :&LEN     SETA  &WS_LOC-&SYM_LOC(&IX)    CALC GROUP LENGTH
             AIF (&LEN GT 0)
                 :&SYM_LEN(&IX) SETA &LEN                      
                 :&WS_PAD SETA &SYM_LOC(&IX)+&SYM_DUP(&IX)*&LEN-&WS_LOC
                 AIF (&WS_PAD GT 0)
                     :&WS_LOC SETA &WS_LOC+&WS_PAD
                 AEND
                 AIF (&IX GT 1)
                     AIF (&SYM_LEN(&IX-1) EQ 0) IS PRIOR WS ITEM 0 LEN
                         AIF (&SYM_LVL(&IX-1) EQ &SYM_LVL(&IX))
                             :&SYM_LEN(&IX-1) SETA &LEN      FIX 0 LEN
                         AEND
                     AEND
                 AEND 
             AEND  
         AEND
       AEND
         AEND
.*
.* STORE NEW 01-49 LEVEL WS ITEM AT CURRENT WS_LVL LEVEL
.*
         AENTRY WS_STORE_NN
         :&SYM_TOT SETA  &SYM_TOT+1
         :&SYM_NAME(&SYM_TOT) SETC '&NEW_SYM' ASSUME NAME VS CLAUSE   
         AIF  (&WS_LVL GT 1)
              :&QIX SETA &WS_LVL_SYM_IX(&WS_LVL-1)
         AELSE
              :&QIX SETA 0  
         AEND
         AIF  (&LK_MODE)        
              AIF  (&NEW_LVL_NO EQ 1)
                   :&LK_TOT  SETA &LK_TOT+1
                   :&LAST_LK_DSECT_IX SETA &SYM_TOT
                   :&WS_LOC SETA 0
              AEND
              :&SYM_LK(&SYM_TOT) SETA &LAST_LK_DSECT_IX
         AEND
         :&SYM_LVL(&SYM_TOT)  SETA &NEW_LVL_NO     SYMBOL LEVEL
         :&SYM_REF(&SYM_TOT)  SETA &REF_IX SYM 88,RDEF, OR LK VAR IX
         :&SYM_FD(&SYM_TOT)   SETA &FILE_IX SYM FD INDEX 
         :&SYM_LOC(&SYM_TOT)  SETA &WS_LOC  SYM FIELD WS OFFSET
         :&SYM_LEN(&SYM_TOT)  SETA 0        SYM FIELD LENGTH DEFAULT
         :&SYM_DUP(&SYM_TOT)  SETA 1        SYM FIELD OCCURANCES     
         :&SYM_PIC_TYPE(&SYM_TOT) SETC 'X'  SYM PIC TYPE DEFAULT DISP
         AIF   (&NEW_LVL_NO GT 49)
               MNOTE 8,'WS &ERR_ID INVALID LVL'
               MEXIT
         AEND
         :&SYM_IX_LST SETA &SYM_TOT     SAVE WS ITEM BEING ADDED
         ACALL WS_SCAN_CLAUSES          DEFINE ALL CLAUSES IN ANY ORDER
         ACALL WS_PROC_CLAUSES          PROCESS ALL CLAUSES FOR WS ITEM
         AIF  (&ZC_CICS                                                X
               AND '&NEW_SYM' EQ 'FILLER'                              X
               AND '&SYM_VAL(&SYM_TOT)' NE '') GEN FILLER NAME FOR VAL
               :&SYM_FILLER_VAL_CNT SETA &SYM_FILLER_VAL_CNT+1
               :&NEW_SYM SETC 'ZC_FILLER_V&SYM_FILLER_VAL_CNT'
               :&SYM_NAME(&SYM_TOT) SETC '&NEW_SYM'
               :&QIX SETA &SYM_QIX(&SYM_TOT)
         AEND
         :&SYM_QIX(&SYM_TOT) SETA &QIX SET QUALFIER IX OR 0     
         AIF  ('&NEW_SYM' NE 'FILLER')
              ZC_SYM_INDEX &NEW_SYM,&QIX   ADD QUALIFIED NAME
         AEND
         AIF   (&SYM_DUP(&SYM_TOT) GT 1)
               :&SYM_SIT(&SYM_TOT) SETA 1
         AEND
         :&CUR_QIX SETA &SYM_QIX(&SYM_TOT)
         AWHILE (&CUR_QIX GT 0)
               AIF (&SYM_DUP(&CUR_QIX) GT 1)
                 :&SYM_SIT(&SYM_TOT) SETA &SYM_SIT(&SYM_TOT)+1
               AEND
               :&CUR_QIX SETA &SYM_QIX(&CUR_QIX)
         AEND
         AIF   (&SYM_TOT GT 1)
               AIF (&SYM_LVL(&SYM_TOT-1) LT &SYM_LVL(&SYM_TOT)         X
                    AND '&SYM_PIC(&SYM_TOT-1)' NE '')
                   MNOTE 8,'WS ITEM LEVEL > PREV ELEMENTARY ITEM LEVEL'
               AEND
         AEND
         AEND
.*
.* END REDEFINE ADDING FILLER IF NEEDED AND RESET WS_LOC TO END
.*
         AENTRY WS_END_REDEFINE
         AIF   (&WS_LVL_RDEF_END(&WS_LVL) LT &WS_LOC)
               :&DIFF SETA &WS_LOC-&WS_LVL_RDEF_END(&WS_LVL)
               MNOTE 8,'WS &ERR_ID REDEFINE EXCEEDS LENGTH BY &DIFF'
         AEND
         AIF   (&WS_LVL_RDEF_END(&WS_LVL) GT &WS_LOC)
               :&WS_PAD SETA &WS_LVL_RDEF_END(&WS_LVL)-&WS_LOC
               ACALL GEN_WS_FILLER
         AEND
         :&WS_LOC SETA &WS_LVL_RDEF_END(&WS_LVL)
         :&WS_LVL_RDEF(&WS_LVL) SETB 0
         AEND
.*
.* GEN WS FILLER TO PAD REDEFINE GAP = &WS_PAD
.*
         AENTRY GEN_WS_FILLER
         :&SYM_TOT SETA  &SYM_TOT+1
         :&SYM_NAME(&SYM_TOT) SETC 'FILLER' PAD REDEFINE                   
         :&SYM_LVL(&SYM_TOT)  SETA &NEW_LVL_NO     SYMBOL LVL
         :&SYM_REF(&SYM_TOT)  SETA &REF_IX  SYM FILE,88,REDF,LK-V
         :&SYM_FD(&SYM_TOT)   SETA &FILE_IX SYM FD INDEX
         :&SYM_LOC(&SYM_TOT)  SETA &WS_LOC  SYM FIELD WS OFFSET
         :&SYM_LEN(&SYM_TOT)  SETA &WS_PAD 
         :&SYM_DUP(&SYM_TOT)  SETA 1        SYM FIELD OCCURANCES     
         :&SYM_PIC_TYPE(&SYM_TOT) SETC 'X'  SYM PIC TYPE DEF DSP
         AEND
.*
.* STORE SINGLE OR MULTIPLE 88 CONDITION VALUES FOR PRIOR WS ITEM
.*
         AENTRY WS_88
         :&SYM_TOT SETA  &SYM_TOT+1
         :&SYM_NAME(&SYM_TOT) SETC '&NEW_SYM'
         :&SYM_QIX(&SYM_TOT)  SETA &SYM_IX_LST  SET LEVEL RPI 1065
         ZC_SYM_INDEX &NEW_SYM
         :&SYM_LVL(&SYM_TOT) SETA &NEW_LVL_NO SYMBOL LVL
         AIF   (&SYM_IX_LST EQ 0)
               MNOTE 8,'WS &ERR_ID  MISSING PREVIOUS ITEM'
               MEXIT
         AEND
         AIF   ('&SYM_NAME(&SYM_IX_LST)' EQ 'FILLER') MAKE UNIQUE NAME
               :&SYM_FILLER_VAL_CNT SETA &SYM_FILLER_VAL_CNT+1 RPI 1065
               :&SYM_NAME(&SYM_IX_LST) SETC 'ZC_FILLER_V&SYM_FILLER_VALX
               _CNT'
         AEND
         :&SYM_REF(&SYM_TOT)  SETA &SYM_IX_LST  POINT TO LAST WS ITEM
         :&SYM_LOC(&SYM_TOT) SETA &V88_TOT+1 PTR TO FIRST 88 VALUE
         AIF   ('&SYSLIST(3)' EQ 'VALUE')                              
               :&I       SETA  4
               AIF   ('&SYSLIST(&I)' EQ 'IS')          
                     :&I SETA &I+1
               AELSEIF ('&SYSLIST(&I)' EQ 'ALL')   RPI 1012         
                     :&I SETA &I+1
                     :&SYM_VAL_ALL(&SYM_TOT) SETB 1 TURN ON ALL FLAG
               AEND
               :&V88_TOT SETA &V88_TOT+1
               :&V88_VAL(&V88_TOT) SETC '&SYSLIST(&I)'
               :&I SETA &I+1
               AIF  ('&V88_VAL(&V88_TOT)' EQ 'X')
                    :&V88_VAL(&V88_TOT) SETC 'X&SYSLIST(&I)'
                    :&I SETA &I+1
               AEND
               AIF  ('&V88_VAL(&V88_TOT)' EQ 'X')
                    :&V88_VAL(&V88_TOT) SETC 'X&SYSLIST(&I)'
                    :&I SETA &I+1
               AELSEIF  ('&V88_VAL(&V88_TOT)' EQ 'QUOTE'               X
                         OR '&V88_VAL(&V88_TOT)' EQ 'QUOTES')
                    :&V88_VAL(&V88_TOT) SETC ''''''''''  RPI 1065 'QQ'
               AEND
         AELSEIF ('&SYSLIST(3)' EQ 'VALUES')  
               :&NP      SETA  N'&SYSLIST
               :&I       SETA  4
               AIF   ('&SYSLIST(4)' EQ 'ARE')             
                     :&I       SETA  5
               AEND
               AWHILE (&I LE &NP)
                 AIF  ('&SYSLIST(&I+1)' EQ 'THRU'                      X
                     OR '&SYSLIST(&I+1)' EQ 'THROUGH')
                    :&V1 SETA &SYSLIST(&I)
                    :&V2 SETA &SYSLIST(&I+2)
                    AIF (&V1 GT &V2)
                        MNOTE 8,'WS 88 VALUE RANGE ERROR'
                        MEXIT
                    AEND
                    AWHILE (&V1 LE &V2)
                       :&V88_TOT SETA &V88_TOT+1
                       :&V88_VAL(&V88_TOT) SETC '&V1'
                       :&V88_NEXT(&V88_TOT) SETA &V88_TOT+1
                       :&V1 SETA &V1+1
                    AEND
                    :&I SETA &I+3
                 AELSE
                    :&V88_TOT SETA &V88_TOT+1
                    :&V88_VAL(&V88_TOT) SETC '&SYSLIST(&I)'
                    AIF  ('&V88_VAL(&V88_TOT)' EQ 'X')
                        :&V88_VAL(&V88_TOT) SETC 'X&SYSLIST(&I)'
                        :&I SETA &I+1
                    AELSEIF  ('&V88_VAL(&V88_TOT)' EQ 'QUOTE'          X
                              OR '&V88_VAL(&V88_TOT)' EQ 'QUOTES')
                        :&V88_VAL(&V88_TOT) SETC ''''''''''  1065 'QQ' 
                    AEND
                    :&V88_NEXT(&V88_TOT) SETA &V88_TOT+1
                    :&I SETA   &I+1
                 AEND
               AEND
               :&V88_NEXT(&V88_TOT) SETA 0
         AELSE
               MNOTE 8,'WS &ERR_ID INVALID LVL 88 VALUE &PIC_VAL'
         AEND
         AEND
.*
.* 66 name1 RENAMES name2 [THRU/THROUGH name3]  RPI 1012
.*
         AENTRY WS_66
         :&SYM_TOT SETA  &SYM_TOT+1
         :&SYM_NAME(&SYM_TOT) SETC '&NEW_SYM'
         :&SYM_QIX(&SYM_TOT) SETA &WS_LVL_SYM_IX(1)
         :&SYM_LVL(&SYM_TOT) SETA 2 REDEFINE 66 AS 02
         ZC_SYM_INDEX &NEW_SYM
         AIF   ('&SYSLIST(3)' NE 'RENAMES')
               MNOTE 8,'WS 66 MISSING RENAMES'
               MEXIT
         AEND                    
         :&PARM_IX SETA 4
         ACALL GET_PARM_FIELD
         AIF   (&FIELD_IX EQ 0)
               MNOTE 'WS RENAMED FIELD NOT FOUND - &SYSLIST(4)'
               MEXIT 
         AEND
         :&NAME2_IX SETA &FIELD_IX
         :&SYM_LOC(&SYM_TOT) SETA &SYM_LOC(&NAME2_IX)
         AIF   (N'&SYSLIST LT &PARM_IX)  REDEFINE SINGLE ITEM
               :&SYM_LEN(&SYM_TOT) SETA &SYM_LEN(&NAME2_IX)
               :&SYM_PIC_TYPE(&SYM_TOT) SETC 'X'
               AEXIT AENTRY
         AEND
         AIF   ('&SYSLIST(&PARM_IX)' NE 'THRU'                         X                              
               AND '&SYSLIST(&PARM_IX)' NE 'THROUGH')          
               MNOTE 8,'WS RENAME UNRECOGNIZED CLAUSE - &SYSLIST(&PARM_X
               IX)'
               MEXIT
         AEND
         :&PARM_IX SETA &PARM_IX+1
         ACALL GET_PARM_FIELD
         AIF   (&FIELD_IX EQ 0)
               MNOTE 'WS RENAMED FIELD NOT FOUND - &SYSLIST(&PARM_IX)'
               MEXIT 
         AEND
         :&NAME3_IX SETA &FIELD_IX
         :&SYM_LEN(&SYM_TOT) SETA &SYM_LOC(&NAME3_IX)+&SYM_LEN(&NAME3_IX
               X)-&SYM_LOC(&NAME2_IX)
         :&SYM_PIC_TYPE(&SYM_TOT) SETC 'X'
         AEND
.*
.* ADD FILE DCB
.* 
         AENTRY WS_91_FILE
         :&SYM_TOT SETA  &SYM_TOT+1
         :&SYM_NAME(&SYM_TOT) SETC '&NEW_SYM'
         ZC_SYM_INDEX &NEW_SYM
         :&SYM_LVL(&SYM_TOT) SETA &NEW_LVL_NO SYMBOL LVL
         :&SYM_FD(&SYM_TOT)  SETA &FILE_IX  POINT TO FILE FOUND IN FD
         :&WS_LOC SETA &WS_LOC+(&WS_LOC+7)/8*8-&WS_LOC 
         :&SYM_LOC(&SYM_TOT)  SETA &WS_LOC
         :&SYM_LEN(&SYM_TOT)  SETA &ZC_DCB_LEN
         :&SYM_DUP(&SYM_TOT)  SETA 1
         :&SYM_PIC_TYPE(&SYM_TOT) SETC 'X'
         :&WS_LOC SETA &WS_LOC+&ZC_DCB_LEN
         AEND
.*
.* SCAN FOR CLAUSES AND SET NAME TO FILLER IF NO NAME FIELD
.*
.*  INDEXED BY- SET  INDEX TO INDEX NAME FOR OCCURS FIELD                                
.*  OCCURS    - SET  DUP 
.*  PIC       - SETS PIC
.*  REDEFINES - SAVE CUR WS_LOC, RESET WS_LOC, TURN ON RDEF FLAG 
.*  SIGN      - SETS PIC_LEAD IF SIGN IS LEADING SEPARATE CHARACTER
.*  USAGE     - SETS USAGE
.*  VALUE     - SETS PIC_VAL
.*
         AENTRY WS_SCAN_CLAUSES
         AIF   (&WS_LVL GT 1)
               :&USAGE SETC '&WS_LVL_USE(&WS_LVL-1)'
         AELSE
               :&USAGE   SETC ''
         AEND
         :&INDEX   SETC ''
         :&PIC     SETC  ''
         :&PIC_TYPE SETC 'X'  DEFAULT DISPLAY X (INCLUDES A AND Z)
         :&PIC_LEN  SETA  0   EXPLICIT LENGTH IF ANY
         :&PIC_SIGN SETB  0   DEFAULT UNSIGNED
         :&PIC_LEAD SETB  0   DEFAULT SIGN NOT LEADING
         :&PIC_VAL  SETC  ''  INITIAL VALUE IF ANY
         :&PIC_VAL_ALL SETB 0 REPEAT VALUE           RPI 1012
         :&DUP     SETA  1    DEFAULT OCCURANCES
         :&NP      SETA  N'&SYSLIST
         :&I       SETA  2
         AWHILE (&I LE &NP)
               AIF ('&SYSLIST(&I)' EQ 'PIC'                            X
                    OR '&SYSLIST(&I)' EQ 'PICTURE')         
                    AIF  (&I EQ 2)    
                         :&NEW_SYM SETC 'FILLER'            
                         :&SYM_NAME(&SYM_TOT) SETC 'FILLER'
                    AEND
                    :&I       SETA  &I+1
                    AIF   ('&SYSLIST(&I)' EQ 'IS')
                          :&I       SETA  &I+1
                    AEND
                    ACALL SET_PIC_AND_LEN
                    :&I  SETA  &I+1
               AELSEIF   ('&SYSLIST(&I)' EQ 'VALUE')          
                    AIF  (&I EQ 2)                
                         :&NEW_SYM SETC 'FILLER'            
                         :&SYM_NAME(&SYM_TOT) SETC 'FILLER'
                    AEND
                    :&I       SETA  &I+1
                    AIF   ('&SYSLIST(&I)' EQ 'IS')
                         :&I       SETA  &I+1
                    AELSEIF ('&SYSLIST(&I)' EQ 'ALL')   RPI 1012         
                     :&I SETA &I+1
                     :&PIC_VAL_ALL SETB 1
                    AEND
                    AIF  (&WS_LVL NE 0)                                 
                         AIF (&WS_LVL_RDEF(&WS_LVL) AND &ZC_WARN)
                             MNOTE 4,'WS &ERR_ID REDEFINE VALUE IGNOREDX
               '
                         AELSE
                             :&PIC_VAL SETC '&SYSLIST(&I)'
                         AEND
                    AELSE
                         :&PIC_VAL SETC '&SYSLIST(&I)'
                    AEND
                    :&I       SETA  &I+1
                    AIF  ('&PIC_VAL' EQ 'ZERO'                         X
                          OR '&PIC_VAL' EQ 'ZEROS'                     X
                          OR '&PIC_VAL' EQ 'ZEROES')
                         :&PIC_VAL SETC '0' 
                    AELSEIF  ('&PIC_VAL' EQ 'X')
                         :&PIC_VAL SETC 'X&SYSLIST(&I)'
                         :&I SETA &I+1
                    AELSEIF ('&PIC_VAL' EQ '+' OR '&PIC_VAL' EQ '-')
                         :&PIC_VAL SETC '&PIC_VAL&SYSLIST(&I)'
                         :&I SETA &I+1
                    AELSEIF ('&PIC_VAL' EQ '''&&''')
                         :&PIC_VAL SETC '''&&&&''' REQ'D FOR DC
                    AELSEIF  ('&PIC_VAL' EQ 'QUOTE'                    X
                              OR '&PIC_VAL' EQ 'QUOTES')
                         :&PIC_VAL SETC ''''''''''  RPI 1065 'QQ'
                    AEND
               AELSEIF   ('&SYSLIST(&I)' EQ 'OCCURS')    
                    :&CUR_SET_LVL SETA &CUR_SET_LVL+1  INC SUB LVL CTR
                    :&DUP SETA  &SYSLIST(&I+1)
                    :&I   SETA  &I+2
                    AIF   ('&SYSLIST(&I)' EQ 'TIMES')
                          :&I       SETA  &I+1
                    AELSEIF ('&SYSLIST(&I)' EQ 'TO') n1 TO n2 TIMES
                          :&DUP_MIN SETA &DUP
                          :&DUP SETA &SYSLIST(&I+1)   (USE N2)
                          :&I   SETA &I+2
                          AIF   ('&SYSLIST(&I)' EQ 'TIMES')
                                :&I       SETA  &I+1
                          AEND
                          AIF   ('&SYSLIST(&I)' EQ 'DEPENDING'         X
                                 AND '&SYSLIST(&I+1)' EQ 'ON')
                                :&SYM_DEPEND(&I) SETC '&SYSLIST(&I+2)'
                                :&I SETA &I+3
                          AELSE
                                MNOTE 8,'WS &ERR_ID MISSING DEPENDING OX
               N'
                          AEND
                    AEND     
                    :&SYM_DUP(&SYM_TOT) SETA &DUP  
               AELSEIF   ('&SYSLIST(&I)' EQ 'INDEXED')                 
                    :&I       SETA  &I+1
                    AIF  ('&SYSLIST(&I)' EQ 'BY')  RPI 1062
                         :&I SETA &I+1
                    AEND
                    :&INDEX   SETC '&SYSLIST(&I)'
                    :&I       SETA &I+1
               AELSEIF   ('&SYSLIST(&I)' EQ 'REDEFINES')              
                    ZC_SYM_FIND &SYSLIST(&I+1)
                    AIF   (&SYM_IX EQ 0)
                          MNOTE 8,'WS &ERR_ID REDEFINE ITEM NOT FOUND -X
                &SYSLIST(&I+1)'
                          MEXIT
                    AELSE
                      AIF (&SYM_FXT(&SYM_IX) GT 0)  RPI 1065
                          :&SYM_IX SETA &SYM_FXT(&SYM_IX)
                          AWHILE (&SYM_IX GT 0) 
                              AIF (&WS_LVL_SYM_IX(&WS_LVL-1) EQ &SYM_QIX
               X(&SYM_IX))            
                                  AEXIT AWHILE
                              AELSE
                                  :&SYM_IX SETA &SYM_NXT(&SYM_IX)
                                  AIF (&SYM_IX EQ 0)
         MNOTE 8,'WS QUAL REDEFINE NOT FOUND FOR - &SYM_NAME(&SYM_TOT)'
                          MEXIT
                                  AEND
                              AEND
                          AEND
                      AEND
                    AEND
                    :&SYM_REF(&SYM_TOT) SETA &SYM_IX  SET REDEFINE IX 
                    AIF (&SYM_LEN(&SYM_IX) EQ 0)
                        :&SYM_LEN(&SYM_IX) SETA &WS_LOC-&SYM_LOC(&SYM_IX
               X)
                    AEND
                    :&WS_LVL_RDEF_END(&WS_LVL) SETA &SYM_LOC(&SYM_IX)+&X
               SYM_LEN(&SYM_IX)*&SYM_DUP(&SYM_IX)
                    :&WS_LOC  SETA  &SYM_LOC(&SYM_IX) RESET LOC TO RED
                    :&WS_LVL_RDEF_IX(&WS_LVL) SETA &SYM_IX WS SYM IX
                    :&SYM_LOC(&SYM_TOT) SETA &WS_LOC
                    :&WS_LVL_RDEF(&WS_LVL) SETB 1     TURN ON REDEFINE
                    :&I       SETA  &I+2
               AELSEIF   ('&SYSLIST(&I)' EQ 'SYNC'                     X
                       OR '&SYSLIST(&I)' EQ 'SYNCHRONIZED') RPI 1062
                    :&SYM_OPT(&SYM_TOT) SETC '&SYM_OPT(&SYM_TOT).S'
                    :&I       SETA  &I+1
                    AIF   ('&SYSLIST(&I)' EQ 'RIGHT'                   X 
                        OR '&SYSLIST(&I)' EQ 'LEFT') RPI 1062
                          :&I       SETA  &I+1
                    AEND
               AELSEIF   ('&SYSLIST(&I)' EQ 'USAGE')            
                    :&I       SETA  &I+1
                    AIF   ('&SYSLIST(&I)' EQ 'IS') 
                          :&I       SETA  &I+1
                    AEND
                    :&USAGE   SETC  '&SYSLIST(&I)'
                    :&I       SETA  &I+1
               AELSEIF   ('&SYSLIST(&I)' EQ 'SIGN')
                    :&I       SETA  &I+1
                    AIF   ('&SYSLIST(&I)' EQ 'IS') 
                          :&I       SETA  &I+1
                    AEND
                    AIF   ('&SYSLIST(&I)' EQ 'LEADING') 
                          :&PIC_LEAD SETB 1      LEADING SIGN 
                          :&I       SETA  &I+1
                    AELSEIF ('&SYSLIST(&I)' EQ 'TRAILING')
                          :&PIC_TRAIL SETB 1      TRAILING SIGN 
                          :&I       SETA  &I+1
                    AELSE
                          MNOTE 8,'WS SIGN UNKNOWN OPTION &SYLIST(&I)'
                          MEXIT
                    AEND
                    AIF   ('&SYSLIST(&I)' EQ 'SEPARATE')
                          :&PIC_SEP SETB 1
                          :&I  SETA  &I+1
                          AIF  ('&SYSLIST(&I)' EQ 'CHARACTER')
                               :&I SETA  &I+1
                          AEND
                    AEND
               AELSEIF  ('&SYSLIST(&I)' EQ 'LEADING') 
                    :&PIC_LEAD SETB 1      LEADING SIGN RPI 1012
                    :&I       SETA  &I+1
                    AIF   ('&SYSLIST(&I)' EQ 'SEPARATE')
                          :&PIC_SEP SETB 1
                          :&I  SETA  &I+1
                          AIF  ('&SYSLIST(&I)' EQ 'CHARACTER')
                               :&I SETA  &I+1
                          AEND
                    AEND
               AELSEIF ('&SYSLIST(&I)' EQ 'TRAILING')
                    :&PIC_TRAIL SETB 1      TRAILING SIGN RPI 1012
                    :&I       SETA  &I+1
                    AIF   ('&SYSLIST(&I)' EQ 'SEPARATE')
                          :&PIC_SEP SETB 1
                          :&I  SETA  &I+1
                          AIF  ('&SYSLIST(&I)' EQ 'CHARACTER')
                               :&I SETA  &I+1
                          AEND
                    AEND
               AELSEIF ('&SYSLIST(&I)'  EQ 'COMP'                      X
                      OR '&SYSLIST(&I)' EQ 'COMPUTATIONAL'             X
                      OR '&SYSLIST(&I)' EQ 'COMP_1'                    X
                      OR '&SYSLIST(&I)' EQ 'COMP_2'                    X
                      OR '&SYSLIST(&I)' EQ 'COMP_3'                    X
                      OR '&SYSLIST(&I)' EQ 'COMP_4'                    X
                      OR '&SYSLIST(&I)' EQ 'COMP_5'                    X
                      OR '&SYSLIST(&I)' EQ 'BINARY'                    X
                      OR '&SYSLIST(&I)' EQ 'FLOAT_BINARY_7'            X
                      OR '&SYSLIST(&I)' EQ 'FLOAT_BINARY_16'           X
                      OR '&SYSLIST(&I)' EQ 'FLOAT_BINARY_34'           X
                      OR '&SYSLIST(&I)' EQ 'FLOAT_DECIMAL_7'           X
                      OR '&SYSLIST(&I)' EQ 'FLOAT_DECIMAL_16'          X
                      OR '&SYSLIST(&I)' EQ 'FLOAT_DECIMAL_34'          X
                      OR '&SYSLIST(&I)' EQ 'FLOAT_HEX_7'               X
                      OR '&SYSLIST(&I)' EQ 'FLOAT_HEX_15'              X
                      OR '&SYSLIST(&I)' EQ 'FLOAT_HEX_30'              X
                      OR '&SYSLIST(&I)' EQ 'FLOAT_SHORT'               X
                      OR '&SYSLIST(&I)' EQ 'FLOAT_LONG'                X
                      OR '&SYSLIST(&I)' EQ 'FLOAT_EXTENDED'            X
                      OR '&SYSLIST(&I)' EQ 'INDEX'                     X
                      OR '&SYSLIST(&I)' EQ 'POINTER') 1002 1004 1042
                    :&USAGE   SETC  '&SYSLIST(&I)'
                    :&I       SETA  &I+1
               AELSEIF ('&SYSLIST(&I)' EQ 'DISPLAY')
                    :&I SETA &I+1  RPI 1065 IGNORE (ITS THE DEFAULT)
               AELSEIF ('&SYSLIST(&I)' EQ 'LINE')
                    AIF ('&SYSLIST(&I+1)' EQ 'NUMBER'                  X
                         AND '&SYSLIST(&I+2)' EQ 'IS'                  X
                         AND '&SYSLIST(&I+3)' EQ 'PLUS')
                        :&I SETA &I+5
                    AELSE
                        :&I SETA &I+2  
                    AEND
                    MNOTE 8,'WS REPORT WRITER LINE CLAUSE IGNORED'
               AELSEIF ('&SYSLIST(&I)' EQ 'COLUMN')
                    AIF  (&I EQ 2)                
                        :&NEW_SYM SETC 'FILLER'            
                        :&SYM_NAME(&SYM_TOT) SETC 'FILLER'
                    AEND
                    AIF ('&SYSLIST(&I+1)' EQ 'NUMBER'                  X
                        AND '&SYSLIST(&I+2)' EQ 'IS')
                        :&I SETA &I+4
                    AELSE
                        :&I SETA &I+2  RPI 1065 IGNORE RW LINE NUM
                    AEND
                    MNOTE 8,'WS REPORT WRITER COLUMN CLAUSE IGNORED'
               AELSEIF ('&SYSLIST(&I)' EQ 'SOURCE')
                    AIF ('&SYSLIST(&I+1)' EQ 'IS')
                        :&I SETA &I+3
                    AELSE
                        :&I SETA &I+2  RPI 1065 IGNORE RW LINE NUM
                    AEND
                    MNOTE 8,'WS REPORT WRITER SOURCE CLAUSE IGNORED'
               AELSEIF ('&SYSLIST(&I)' EQ 'TYPE'                       X
                        AND '&SYSLIST(&I+1)' EQ 'IS')
                    :&I SETA &I+2  RPI 1065 IGNORE RW TYPE
                    MNOTE 8,'WS REPORT WRITER TYPE CLAUSE IGNORED'
                    AIF ('&SYSLIST(&I+2)' EQ 'PAGE')
                        :&I SETA &I+4
                    AELSE
                        :&I SETA &I+3
                    AEND
               AELSEIF ('&SYSLIST(&I)' EQ 'JUSTIFIED'                  X
                        OR '&SYSLIST(&I)' EQ 'JUST') RPI 1065
                        :&SYM_OPT(&SYM_TOT) SETC '&SYM_OPT(&SYM_TOT).R'
                    AIF ('&SYSLIST(&I+1)' EQ 'RIGHT')
                        :&I SETA &I+2
                    AELSE
                        :&I SETA &I+2   
                    AEND 
               AELSEIF ('&SYSLIST(&I)' EQ 'LEADING')
                    :&SYM_OPT(&SYM_TOT) SETC '&SYM_OPT(&SYM_TOT).L'
                    :&I SETA &I+1    
               AELSEIF ('&SYSLIST(&I)' EQ 'BLANK')
                    :&SYM_OPT(&SYM_TOT) SETC '&SYM_OPT(&SYM_TOT).B'
                    :&I SETA &I+1
                    AIF ('&SYSLIST(&I)' EQ 'WHEN')
                        :&I SETA &I+1
                    AEND
                    AIF ('&SYSLIST(&I)' EQ 'ZERO')
                        :&I SETA &I+1
                    AEND
               AELSEIF ('&SYSLIST(&I)' EQ 'GLOBAL')
                    :&SYM_OPT(&SYM_TOT) SETC '&SYM_OPT(&SYM_TOT).G'
                    :&I SETA &I+1
               AELSEIF ('&SYSLIST(&I)' EQ 'EXTERNAL')
                    :&SYM_OPT(&SYM_TOT) SETC '&SYM_OPT(&SYM_TOT).E'
                    :&I SETA &I+1
               AELSEIF (&I GT 2)
                    MNOTE 8,'WS &ERR_ID UNRECOGNIZED CLAUSE &SYSLIST(&IX
               )'
                    MEXIT
               AELSE
                    :&I SETA &I+1
               AEND
         AEND
         AEND
.*
.* SET PIC AND DEFAULT PIC_LEN
.*
.*  1.  IF LEADING S SET PIC_SIGN AND REMOVE S
.*  2.  DO NOT ALLOW QUOTE IN PIC CLAUSE
.*
         AENTRY  SET_PIC_AND_LEN
         :&PIC     SETC '&SYSLIST(&I)'
         AIF  ('&PIC'(1,1) EQ '''')
              :&PIC SETC '&PIC'(2,K'&PIC-2) 
         AEND
         AIF  ('&PIC'(1,1) EQ 'S')
              :&PIC_SIGN SETB 1
              :&PIC     SETC  '&PIC'(2,*)
         AEND
         :&J       SETA 1
         :&DEC_MODE SETB 0
         AWHILE (&J LE K'&PIC)
                AIF ('&PIC'(&J,1) EQ 'V')
                    :&DEC_MODE SETB 1
                AELSEIF ('&PIC'(&J,2) EQ 'X('                          X
                         OR '&PIC'(&J,2) EQ '9('                       X
                         OR '&PIC'(&J,2) EQ 'A('                       X
                         OR '&PIC'(&J,2) EQ 'P('                       X
                         OR '&PIC'(&J,2) EQ 'Z(')  RPI 1065 ADD P,A
                    AIF ('&PIC'(&J,1) EQ 'P')
                       :&DEC_MODE SETB 1 
                    AEND
                    :&PIC_DUP SETA '&PIC'(&J+2,1)
                    :&J SETA &J+3
                    AWHILE (&J LT K'&PIC                               X
                            AND '&PIC'(&J,1) NE ')')
                        :&DIGIT   SETA '&PIC'(&J,1)
                        :&PIC_DUP SETA &PIC_DUP*10+&DIGIT
                        :&J SETA &J+1
                    AEND
                    :&PIC_LEN SETA &PIC_LEN+&PIC_DUP
                    AIF (&DEC_MODE)
                        :&SYM_PIC_DEC(&SYM_TOT) SETA &SYM_PIC_DEC(&SYM_X
               TOT)+&PIC_DUP
                    AEND
                AELSEIF ('&PIC'(&J,1) EQ '''')  RPI 1032
                    MNOTE 8,'WS UNKNOWN PIC CLAUSE &PIC'
                    AEXIT AWHILE
                AELSE
                    AIF ('&PIC'(&J,1) EQ 'P')
                       :&DEC_MODE SETB 1
                    AEND
                    :&PIC_LEN SETA &PIC_LEN+1
                    AIF (&DEC_MODE)
                        :&SYM_PIC_DEC(&SYM_TOT) SETA &SYM_PIC_DEC(&SYM_X
               TOT)+1
                    AEND
                AEND
                :&J SETA &J+1
         AEND
         AEND
.*
.* PROCESS WS ITEM WITH ALL CLAUSE VALUES DEFINED
.*
         AENTRY WS_PROC_CLAUSES
         AIF   (&NP LT 2)
               :&NEW_SYM SETC 'FILLER'            
               :&SYM_NAME(&SYM_TOT) SETC 'FILLER'
         AELSEIF ('&USAGE' EQ 'COMP'                                   X
                  OR '&USAGE' EQ 'COMPUTATIONAL'                       X
                  OR '&USAGE' EQ 'BINARY'                              X
                  OR '&USAGE' EQ 'COMP_4'                              X
                  OR '&USAGE' EQ 'COMP_5')  RPI 1042 RPI 1090            
               AIF  ('&PIC' NE '')  
                    AIF  (&PIC_LEN LE 0) 
                         :&PIC_LEN SETA K'&PIC
                    AEND
                    AIF  (&PIC_LEN LE 4)
                         :&PIC_LEN SETA 2
                         :&PIC_TYPE SETC 'H'
                    AELSEIF (&PIC_LEN LE 9)
                         :&PIC_LEN  SETA 4
                         :&PIC_TYPE SETC 'F'
                    AELSEIF (&PIC_LEN LE 18)
                         :&PIC_LEN  SETA 8
                         :&PIC_TYPE SETC 'G'
                    AELSEIF (&ZC_EXTEND AND &PIC_LEN LE 39) RPI 1004
                         :&PIC_LEN  SETA 16
                         :&PIC_TYPE SETC 'Q'
                    AELSE
                         MNOTE 8,'WS INVALID COMP PIC LEN - &PIC_LEN'
                    AEND
               AEND
               :&NUM     SETC '&PIC_VAL'
               :&DEC_SYM SETA &SYM_PIC_DEC(&SYM_TOT)
               ACALL SCALE_NUM_LIT
               :&PIC_VAL SETC '&NUM'
         AELSEIF ('&USAGE' EQ 'COMP_1')                 
               :&PIC_LEN SETA 4
               :&PIC_TYPE SETC '1'       RPI 1004 WAS E NOW 1=EH
         AELSEIF ('&USAGE' EQ 'COMP_2')                
               :&PIC_LEN SETA 8
               :&PIC_TYPE SETC '2'       RPI 1004 WAS D NOW 2=DH
         AELSEIF ('&USAGE' EQ 'COMP_3')             
               AIF   ('&PIC' NE '')                       
                     AIF  (&PIC_LEN EQ 0)                 
                          :&PIC_LEN SETA K'&PIC
                     AEND
               AEND
               :&PIC_TYPE SETC 'P'
               :&NUM     SETC '&PIC_VAL'
               :&DEC_SYM SETA &SYM_PIC_DEC(&SYM_TOT)
               ACALL SCALE_NUM_LIT
               :&PIC_VAL SETC '&NUM'
         AELSEIF ('&USAGE' EQ 'FLOAT_HEX_7')     RPI 1004      
              :&PIC_LEN SETA 4
              :&PIC_TYPE SETC '1'
         AELSEIF ('&USAGE' EQ 'FLOAT_HEX_15')      RPI 1004      
              :&PIC_LEN SETA 8
              :&PIC_TYPE SETC '2'
         AELSEIF ('&USAGE' EQ 'FLOAT_HEX_30' AND &ZC_EXTEND) RPI 1004      
              :&PIC_LEN SETA 16
              :&PIC_TYPE SETC '3'
         AELSEIF ('&USAGE' EQ 'FLOAT_BINARY_7' AND &ZC_EXTEND) RPI 1004      
              :&PIC_LEN SETA 4
              :&PIC_TYPE SETC '4'
         AELSEIF ('&USAGE' EQ 'FLOAT_BINARY_16' AND &ZC_EXTEND) RPI1004      
              :&PIC_LEN SETA 8
              :&PIC_TYPE SETC '5'
         AELSEIF ('&USAGE' EQ 'FLOAT_BINARY_34' AND &ZC_EXTEND) RPI1004      
              :&PIC_LEN SETA 16
              :&PIC_TYPE SETC '6'
         AELSEIF ('&USAGE' EQ 'FLOAT_DECIMAL_7' AND &ZC_EXTEND) RPI1004      
              :&PIC_LEN SETA 4
              :&PIC_TYPE SETC '7'
         AELSEIF ('&USAGE' EQ 'FLOAT_DECIMAL_16' AND &ZC_EXTEND) RP1004      
              :&PIC_LEN SETA 8
              :&PIC_TYPE SETC '8'
         AELSEIF ('&USAGE' EQ 'FLOAT_DECIMAL_34' AND &ZC_EXTEND) RP1004      
              :&PIC_LEN SETA 16
              :&PIC_TYPE SETC '9'
         AELSEIF ('&USAGE' EQ 'FLOAT_SHORT' AND &ZC_EXTEND) RPI 1004      
              :&PIC_LEN SETA 4
              :&PIC_TYPE SETC '&ZC_FLOAT_SHORT_TYPE'
         AELSEIF ('&USAGE' EQ 'FLOAT_LONG' AND &ZC_EXTEND)  RPI 1004      
              :&PIC_LEN SETA 8
              :&PIC_TYPE SETC '&ZC_FLOAT_LONG_TYPE'
         AELSEIF ('&USAGE' EQ 'FLOAT_EXTENDED' AND &ZC_EXTEND) RPI 1004      
              :&PIC_LEN SETA 16
              :&PIC_TYPE SETC '&ZC_FLOAT_EXTENDED_TYPE'
         AELSEIF ('&USAGE' EQ 'INDEX')           RPI 1002         
              :&PIC_LEN SETA 4
              :&PIC_TYPE SETC 'I'
         AELSEIF ('&USAGE' EQ 'POINTER')                   
              :&PIC_LEN SETA 4
              :&PIC_TYPE SETC 'A'
         AELSEIF ('&USAGE' EQ 'PROCEDURE_POINTER')   RPI 1010                
              :&PIC_LEN SETA 4
              :&PIC_TYPE SETC 'A'
         AELSEIF (K'&PIC GT 0)
               AIF   (('&PIC'(1,1) FIND '9PV') GT 0) RPI 1062 ADD PV             
                     :&PIC_TYPE SETC 'Z'
                     :&NUM     SETC '&PIC_VAL'
                     :&DEC_SYM SETA &SYM_PIC_DEC(&SYM_TOT)
                     ACALL SCALE_NUM_LIT
                     :&PIC_VAL SETC '&NUM'
               AEND
               AIF   (&PIC_LEN EQ 0)               
                     :&PIC_LEN SETA K'&PIC
               AEND
         AEND
         :&SYM_PIC_TYPE(&SYM_TOT) SETC '&PIC_TYPE'
         :&SYM_PIC_SIGN(&SYM_TOT) SETB &PIC_SIGN
         :&SYM_PIC(&SYM_TOT) SETC '&PIC'     SYM FIELD PIC (999,X(3))
         AIF (K'&PIC_VAL GT 3)
             AIF ('&PIC_VAL'(1,2) EQ 'X"')   CONVERT X"??" TO X'??'
                 :&PIC_VAL SETC 'X'''.'&PIC_VAL'(3,K'&PIC_VAL-3).''''
             AEND
         AEND
         AIF  ('&PIC_TYPE' EQ 'X'                                      X
               AND '&PIC_VAL' NE '')
               :&AMP SETA ('&PIC_VAL' FIND '&&')
               AWHILE (&AMP GT 0)
                  :&PIC_VAL SETC '&PIC_VAL'(1,&AMP).'&&'.'&PIC_VAL'(&AMX
               P+1,*)
                  :&NEXT_AMP SETA ('&PIC_VAL'(&AMP+2,*) FIND '&&')
                  AIF (&NEXT_AMP GT 0)
                      :&AMP SETA &AMP+&NEXT_AMP+1
                  AELSE
                      :&AMP SETA 0
                  AEND
               AEND
         AELSEIF (K'&PIC_VAL GT 2)  REMOVE '..' FROM NUMERIC VALUES               
               AIF ('&PIC_VAL'(1,1) EQ '''')   RPI 1065
                   :&PIC_VAL SETC '&PIC_VAL'(2,K'&PIC_VAL-2)
               AEND
         AEND
         :&SYM_VAL(&SYM_TOT) SETC '&PIC_VAL' SYM FIELD VALUE (0,SPACE)
         :&SYM_VAL_ALL(&SYM_TOT) SETB &PIC_VAL_ALL  RPI 1012
         AIF   ('&PIC_TYPE' EQ 'P')
               :&PIC_LEN SETA &PIC_LEN/2+1
         AEND
         :&SYM_LEN(&SYM_TOT) SETA  &PIC_LEN  SYM FILED LENGTH
         :&SYM_DUP(&SYM_TOT) SETA  &DUP      SYM FIELD OCCURANCES
         AIF   (&PIC_LEN EQ 0)
               ZC_PIC_LEN
               :&PIC_LEN SETA  &SYM_LEN(&SYM_TOT)
         AEND
         :&WS_LOC  SETA  &WS_LOC+&SYM_DUP(&SYM_TOT)*&SYM_LEN(&SYM_TOT)
         AIF   (&DUP GT 1 AND '&INDEX' NE '')                     
               :&SET_TOT SETA  &SET_TOT+1
               :&SET_SYM_IX(&SET_TOT) SETA &SYM_TOT
               :&SET_SYM_LVL(&SET_TOT) SETA &CUR_SET_LVL
               :&SET_INDEX(&SET_TOT) SETC '&INDEX'
         AEND
         AEND
.*
.* ADD NEW LVL
.*
         AENTRY WS_ADD_LVL
         :&WS_LVL     SETA  &WS_LVL+1
         :&WS_LVL_NO(&WS_LVL) SETA &NEW_LVL_NO
         :&WS_LVL_SYM_IX(&WS_LVL) SETA 0
         AEND
         COPY  ZCGETFLD
         COPY  ZCNUMLIT
         MEND
         MACRO
.*********************************************************************
.* Copyright 2009 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 09/12/09                                                 *
.*********************************************************************
.* 09/12/09 zc390 gens ZCEND for END ???? to avoid END conflict              
.*********************************************************************
         ZCEND &TYPE
         AIF   ('&TYPE' NE 'PROGRAM')
               MNOTE 8,'ZCEND END_&TYPE NOT SUPPORTED YET'
         AEND
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/29/08                                                 *
.*********************************************************************
.* 04/29/08 initial coding for global CBL options call gen'd by zcobol  
.* 02/25/09 RPI 1004 SET ZC_FLOAT to DECIMAL/BINARY/HEX def. DECIMAL         
.* 03/06/09 RPI 1004 SET ZC_FLOAT from option FLOAT(?)  
.*********************************************************************
        ZCOBOL &VER=,      z390 version from tz390.version             X
               &PGM=,      program name from args[0] overides PGM-ID.  X
               &CDATE=,    current compile date or MM/DD/YY if notimingX
               &CTIME=,    current compile start time if timing        X
               &OPTIONS=   sublist of all options following program  
         COPY ZC_WS
.*
.* SAVE ALL ZCOBOL PARMS IN GLOBALS
.*
         :&ZC_VER   SETC '&VER'
         :&ZC_PGM   SETC '&PGM'
         :&ZC_CDATE SETC '&CDATE'
         :&ZC_CTIME SETC '&CTIME'
         :&ZC_LIST  SETC 'NOLIST,NOGEN,NOLISTUSE'
         :&ZC_OPTIONS SETC '&OPTIONS'
.*
.* DEFINE ZCOBOL CLOBAL OPTION DEFAULTS
.*
         :&ZC_COMMENT SETB 1     DEFAULT ON
         :&ZC_EXTEND  SETB 1     DEFAULT ON
         :&ZC_FLOAT   SETC 'DECIMAL' VS BINARY OR HEX FOR FLOAT-S/L/E
         :&ZC_FLOAT_SHORT_TYPE    SETC '7'
         :&ZC_FLOAT_LONG_TYPE     SETC '8'
         :&ZC_FLOAT_EXTENDED_TYPE SETC '9'
         :&ZC_R64     SETB 1     ALLOW 64 BIT REGISTER INSTRUCTIONS
.*
.* SET OVERRIDES FROM PARM OPTIONS
.*
         :&I   SETA 1
         :&NP  SETA N'&OPTIONS
         :&OPT_LIST SETC ''
         AWHILE (&I LE &NP)
               :&OPTION SETC (UPPER '&OPTIONS(&I)')
               AIF ('&OPTION' EQ 'CICS')    GEN DFHEISTG CSECT
                   :&ZC_CICS SETB 1
                   :&OPT_LIST SETC '&OPT_LIST,&OPTION'
               AELSEIF ('&OPTION' EQ 'COMMENT') GEN CBL SOURCE COMMENTS
                   :&ZC_COMMENT SETB 1
                   :&OPT_LIST SETC '&OPT_LIST,&OPTION'
               AELSEIF ('&OPTION'(1,6) EQ 'FLOAT(') FLOAT(DFP/BFP/HFP)           
                   :&ZC_FLOAT SETC '&OPTION'(7,K'&OPTION-7)
                   :&OPT_LIST SETC '&OPT_LIST,&OPTION'
                   AIF ('&ZC_FLOAT' EQ 'DECIMAL')
                       :&ZC_FLOAT_SHORT_TYPE    SETC '7'
                       :&ZC_FLOAT_LONG_TYPE     SETC '8'
                       :&ZC_FLOAT_EXTENDED_TYPE SETC '9'
                   AELSEIF ('&ZC_FLOAT' EQ 'HEX')
                       :&ZC_FLOAT_SHORT_TYPE    SETC '1'
                       :&ZC_FLOAT_LONG_TYPE     SETC '2'
                       :&ZC_FLOAT_EXTENDED_TYPE SETC '3'
                   AELSEIF ('&ZC_FLOAT' EQ 'BINARY')
                       :&ZC_FLOAT_SHORT_TYPE    SETC '4'
                       :&ZC_FLOAT_LONG_TYPE     SETC '5'
                       :&ZC_FLOAT_EXTENDED_TYPE SETC '6'
                   AELSE
                       MNOTE 8,'ZCOBOL INVALID FLOAT TYPE - &ZC_FLOAT'
                   AEND    
               AELSEIF ('&OPTION' EQ 'EXTEND')  ALLOW Q34 AND P31/Z31
                   :&ZC_EXTEND  SETB 1
                   :&OPT_LIST SETC '&OPT_LIST,&OPTION'
               AELSEIF ('&OPTION' EQ 'NOR64')  TURN OFF 64 BIT REG CODE
                   :&ZC_R64  SETB 0
                   :&OPT_LIST SETC '&OPT_LIST,&OPTION'
               AELSEIF ('&OPTION' EQ 'TRACE')   TRACE PARAGRAPHS ON LOG
                   :&ZC_TRACE   SETB 1
                   :&OPT_LIST SETC '&OPT_LIST,&OPTION'
               AELSEIF ('&OPTION' EQ 'TRUNC')   TRUNCATE NUM TO PIC(N)
                   :&ZC_TRUNC   SETB 1
                   :&OPT_LIST SETC '&OPT_LIST,&OPTION'
               AELSEIF ('&OPTION' EQ 'WARN')    ISSUE M NOTE LVL 4    
                   :&ZC_WARN    SETB 1
                   :&OPT_LIST SETC '&OPT_LIST,&OPTION'
               AELSEIF ('&OPTION' EQ 'NOCICS')  NO EXEC CICS
                   :&ZC_CICS SETB 0
                   :&OPT_LIST SETC '&OPT_LIST,&OPTION'
               AELSEIF ('&OPTION' EQ 'NOCOMMENT') NO SOURCE COMMENTS
                   :&ZC_COMMENT SETB 0
                   :&OPT_LIST SETC '&OPT_LIST,&OPTION'
               AELSEIF ('&OPTION' EQ 'NOEXTEND')  NO G64 AND P31 COMPS
                   :&ZC_EXTEND  SETB 0
                   :&OPT_LIST SETC '&OPT_LIST,&OPTION'
               AELSEIF ('&OPTION' EQ 'NOTRACE') NO TRACE PARAGRAPHS
                   :&ZC_TRACE   SETB 0
                   :&OPT_LIST SETC '&OPT_LIST,&OPTION'
               AELSEIF ('&OPTION' EQ 'NOTRUNC') NO TRUNCATE NUM TO PIC
                   :&ZC_TRUNC   SETB 0
                   :&OPT_LIST SETC '&OPT_LIST,&OPTION'
               AELSEIF ('&OPTION' EQ 'NOWARN') NO M NOTE LVL 4 WARNINGS
                   :&ZC_WARN    SETB 0
                   :&OPT_LIST SETC '&OPT_LIST,&OPTION'
               AEND
               :&I SETA &I+1
         AEND
         AIF   (K'&OPT_LIST GT 0)
               :&OPT_LIST SETC '&OPT_LIST'(2,*)
         AEND
         COPY  ZC_KEYS
     GEN_COMMENT 'ZCOBOL PGM=&ZC_PGM VER=&ZC_VER &ZC_CDATE &ZC_CTIME'
     GEN_COMMENT 'ZCOBOL OPTIONS=(&OPT_LIST)'
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/16/08                                                 *
.*********************************************************************
.* 07/19/09 RPI 1065 stub for pending support ZCSD REPLACING SD             
.*********************************************************************
         ZCSD
         MNOTE 8,'SD SORT DEFINITION NOT SUPPORTED YET'
         MEXIT
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 07/16/09                                                 *
.*********************************************************************
.* 07/16/09 RPI 1065 stub for START verb mapped to ZCSTART by ZC390
.*********************************************************************
         SORT
         MNOTE 8,'START NOT SUPPORTED YET'
         MEXIT
         MEND
        MACRO
.*********************************************************************
.* Copyright 2009 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 03/04/09                                                 *
.*********************************************************************
.* 04/24/09 RPI 1003 initial coding for ZC_CALC using IF as model
.* 07/30/09 RPI 1065 FUNCTION not supported yet (see IF101A)      
.*********************************************************************
.* ZC_CALC used by COMPUTE to gen code to calculate expression 
.* defined by positional parm list.  The result is stored in data 
.* field defined by T_NAME and positive T_IX or by temporary storage
.* field defined in ZCVT using negative T_IX to fetch characteristics
.* from global tables &TMP_NAME/TYPE/LEN/SIGN
.*********************************************************************
         ZC_CALC &T_NAME,&T_IX,&EXP
         COPY  ZC_WS
&ROUNDED SETB  0
&ONSIZE  SETB  0
&PREV_OP# SETA 0 PREV OP# ON STK OR 0 FOR NONE
&TMP_OFF  SETA 0 OFFSET TO NEXT TEMP STORE IN ZCVT_WORKAREA
.*
.* PUSH/POP VAR/LIT lNDEX AND OPERATOR STACKS FOR PARSING
.*
         LCLA  &STK_VAR_TOT      CUR TOTAL VAR/IOP IX'S ON STACK
         LCLA  &STK_VAR_IX(100)  VAR IX,-TMP IX, OR 0 FOR LIT VAL
         LCLA  &STK_OP_TOT       CUR TOTAL OP ON STACK
         LCLA  &STK_OP(10)       OP 1-6  '+-*/()'
         LCLA  &VAR_IOP_IX       POS PARM IX,NEG TMP IX, OR 0 FOR LIT
.*
.* GENERATED INTERMEDIATE OPCODE TABLE
.*
         LCLA  &IOP_TOT       TOTAL INTERMEDIATE LOG. OPS
         LCLA  &IOP_OP(100)   LOG. OPER. (+=1,-=2,*=3,/=4)
         LCLA  &IOP_F1_X(100) +PARM1 IX OR -TMP IX
         LCLA  &IOP_F2_X(100) +PARM2 IX OR -TMP IX
         LCLA  &IOP_F3_X(100) +TMP   IX FOR RESULT
.*
.*
.*
         LCLA  &MAX_TMP          MAX TMP ALLOCATED
         LCLA  &TMP_OFF          OFFSET FOR TMP FIELD
         LCLA  &CUR_TMP_FREE     CURRENT FREE TMP
         LCLA  &TMP_FREE_IX(100) CURRENT FREE TMP INDEXES 1-N
.*
.*  BUILD IOP'S AND THEN GEN CODE
.*
         ACALL IOP_BUILD
.*  ACALL LIST_IOPS   DEBUG
         ACALL IOP_GEN_CODE
         MEXIT
.*
.* BUILD IOP TABLE USING BNF PARM AND OPERATOR STACKS
.*   1.  PUSH +PARM PTRS AND -IOP PTRS ON STK_VAR
.*   2.  PUSH OPERATORS ON STK_OP (+-*/() = 123456)
.*   3.  POP  OP AND 2 VAR IX'S TO GEN IOP 
.*       WHEN OP PRECEDENCE DICTATES  
.*
         AENTRY IOP_BUILD
         :&NP   SETA  N'&SYSLIST  TOTAL EXP PARMS
         AIF (&NP EQ 0)
             MNOTE 8,'ZC_CALC MISSING EXPRESSION'
             MEXIT
         AEND
         :&LVL  SETA  0           CUR (..) LEVEL WITHIN IF PARMS
         :&IX_PARM_TOT SETA 0     CUR CONDITION PARM COUNT (A EQ B ETC)
         :&STK_OP_TOT SETA 0      RESET LOGICAL IOP OPERATOR STACK
         :&PARM_IX SETA  2        GET PARM INDEX (SKIP TARGET/INDEX)
         :&PREV_PARM SETC ''      PREV PARM
         :&PARM SETC ''           CUR  PARM
         :&SKIP_SIX SETB 0      SKIP SUBSCRIPTS IN CD'S
         ACALL  GET_PARM          GET NEXT PARM OR ''
         AWHILE ('&PARM' NE '')
               AIF ('&PARM' EQ '''(''')
                   :&LVL SETA &LVL+1
                   :&OP# SETA 5  OP_OPEN
                   ACALL PUSH_OP      PUSH OP 5=(
               AELSEIF ('&PARM' EQ ''')''')  OP_CLOSE
                   :&LVL SETA &LVL-1
                   AIF (&STK_OP_TOT GT 0) 
                       AWHILE (&STK_OP(&STK_OP_TOT) NE 5) FLUSH (..)
                           ACALL IOP_ADD_OP
                       AEND
                       ACALL POP_OP  REMOVE ( FOR MATCHING )
                   AELSE
                       MNOTE 8,'ZC_CALC UNBALANCED (..)'
                       MEXIT
                   AEND     
               AELSEIF ('&PARM' EQ '+' OR '&PARM' EQ '-')
                   AWHILE (&PREV_OP# EQ 1                              X
                           OR &PREV_OP# EQ 2                           X
                           OR &PREV_OP# EQ 3                           X
                           OR &PREV_OP# EQ 4)                             
                       ACALL IOP_ADD_OP
                   AEND
                   AIF ('&PARM' EQ '+')
                       :&OP# SETA 1
                   AELSE
                       :&OP# SETA 2
                   AEND
                   ACALL PUSH_OP      PUSH OP 5=(
               AELSEIF ('&PARM' EQ '*' OR '&PARM' EQ '/')
                   AWHILE (&PREV_OP# EQ 3 OR &PREV_OP# EQ 4)
                       ACALL IOP_ADD_OP
                   AEND    
                   AIF ('&PARM' EQ '*')
                       :&OP# SETA 3 OP_MPY
                   AELSE
                       :&OP# SETA 4 OP_DIV
                   AEND
                   ACALL PUSH_OP      PUSH OP 5=(
               AELSEIF ('&PARM' EQ 'FUNCTION')
                   MNOTE 8,'ZC_CALC FUNCTION NOT SUPPORTED YET'
                   MEXIT
               AELSE
                   :&VAR_IOP_IX SETA &PARM_IX
                   ACALL PUSH_VAR   PUSH 1ST PARM PTR FOR VAR  
                   :&SKIP_SIX SETB 1
               AEND
               ACALL GET_PARM
               AIF  (&SKIP_SIX) SKIP SUBSCRIPTS FOR VAR'S
                    :&SKIP_SIX SETB 0
                    AWHILE ('&PARM' EQ '''(''') SKIP SIX AND RMOD 
                        ACALL GET_PARM
                        AWHILE ('&PARM' NE '' AND '&PARM' NE ''')''')
                            ACALL GET_PARM
                        AEND
                        AIF ('&PARM' NE '')
                            ACALL GET_PARM
                        AEND
                    AEND
               AEND 
         AEND
.*
.* FLUSH REMAINING OPS IF ANY AT END OR PARMS
.*
         AWHILE (&STK_OP_TOT GT 0)
              ACALL IOP_ADD_OP
         AEND
         AEND
.*
.* GEN CODE FROM IOPS
.*
         AENTRY IOP_GEN_CODE
.*
.* GEN SINGLE IOP FROM STACK IF NO IOPS
.*
.*
.* GEN CODE FROM IOP TABLE WITH MULTIPLE ENTRIES
.*
         :&I   SETA 1
         AWHILE (&I LE &IOP_TOT)
               ACALL IOP_GEN_OP
               :&I SETA &I+1
         AEND
         AEND
.*
.* IOP ADD OP - ADD OP ON STK TO IOP TABLE
.*
         AENTRY IOP_ADD_OP
         ACALL POP_OP
         :&IOP_TOT SETA &IOP_TOT+1
         :&IOP_OP(&IOP_TOT) SETA &OP#  (1-4 = ADD,SUB,MPY,DIV)
         ACALL POP_VAR_IOP_IX
         :&IOP_F2_X(&IOP_TOT) SETA &VAR_IOP_IX
         ACALL POP_VAR_IOP_IX
         :&IOP_F1_X(&IOP_TOT) SETA &VAR_IOP_IX
         ACALL GET_TMP
         :&IOP_F3_X(&IOP_TOT) SETA &TMP_IX
         :&VAR_IOP_IX SETA -&TMP_IX
         ACALL PUSH_VAR
         AIF  (&IOP_F1_X(&IOP_TOT) LT 0)
              :&TMP_IX SETA -&IOP_F1_X(&IOP_TOT)
              ACALL FREE_TMP
         AEND
         AIF  (&IOP_F2_X(&IOP_TOT) LT 0)
              :&TMP_IX SETA -&IOP_F2_X(&IOP_TOT)
              ACALL FREE_TMP
         AEND
         AEND
.*
.* IOP GEN OP
.*
         AENTRY IOP_GEN_OP
         ACASE (&IOP_OP(&I))
         AWHEN 1  OP_ADD
             ACALL IOP_GEN_ADD
         AWHEN 2  OP_SUB
             ACALL IOP_GEN_SUB
         AWHEN 3  OP_MPY
             ACALL IOP_GEN_MPY
         AWHEN 4  OP_DIV
             ACALL IOP_GEN_DIV
         AELSE
             MNOTE 8,'ZC_CALC IOP INVALID OPCODE &IOP_OP(&I)'
             MEXIT
         AEND
         AEND
.*
.* POP VAR_IOP AND SET VAR_IOP_IX FROM TOP OF STK_VAR 
.*
         AENTRY POP_VAR_IOP_IX
         AIF  (&STK_VAR_TOT GT 0)
              :&VAR_IOP_IX SETA &STK_VAR(&STK_VAR_TOT) +VAR,-TMP 
              :&STK_VAR_TOT SETA &STK_VAR_TOT-1
         AELSE
              MNOTE 8,'ZC_CALC MISSING VAR STACK PTR'
              CALL LIST_IOPS
              MEXIT
         AEND
         AEND
.*
.* IOP GEN ADD
.*
         AENTRY IOP_GEN_ADD
         ACALL CALC_SETUP
         GEN_ADD &F3_N,&F3_XC,&F2_N,&F2_XC,&ROUNDED,&ONSIZE        
         AEND
.*
.* IOP GEN SUB
.*
         AENTRY IOP_GEN_SUB
         ACALL CALC_SETUP
         GEN_SUB &F3_N,&F3_XC,&F2_N,&F2_XC,&ROUNDED,&ONSIZE        
         AEND
.*
.* IOP GEN MPY
.*
         AENTRY IOP_GEN_MPY
         ACALL CALC_SETUP
         GEN_MPY &F3_N,&F3_XC,&F2_N,&F2_XC,&ROUNDED,&ONSIZE        
         AEND
.*
.* IOP GEN DIV
.*
         AENTRY IOP_GEN_DIV
         ACALL CALC_SETUP
         GEN_DIV &F1_N,&F1_T,&F1_L,0,      DIVIDEND                    X
               &F2_N,&F2_T,&F2_L,0,        DIVISOR                     X
               &F3_N,&F3_T,&F3_L,&F3_S,0,  QUOTIENT                    X
               ,,0,0,0,                    NO REMAINDER                X
               &ROUNDED,&ONSIZE        
         AEND
.*
.*
.* CALC_SETUP
.*
.*     1.  GEN SIX FOR F1 ABD F2 FIELDS IF ANY
.*     2.  SET TMP_NAME/TYPE/LEN/SIGN TARGET FIELD FROM F1/F2 TYPES
.*     3.  GEN MOVE F1 TO TARGET FIELD IF REQUIRED FOR ADD,SUB,MPY
.*
         AENTRY CALC_SETUP
         AIF   (&IOP_F1_X(&I) GE 0)
               :&VAR_PARM_IX SETA &IOP_F1_X(&I)-1
               :&VAR_PREV_PARM SETC ''
               :&FIELD_SS1 SETB 1
               :&FIELD_REG SETC 'ZC_R2'
               ACALL  GET_VAR_PARM   GEN SIX CODE FOR VAR IF ANY
               :&F1_N SETC '&FIELD_NAME'
               :&F1_X SETA &FIELD_IX
               :&F1_XC SETC '&F1_X'
               AIF (&F1_X GT 0)
                   :&F1_T SETC '&SYM_PIC_TYPE(&F1_X)'
                   :&F1_L SETA &SYM_LEN(&F1_X)
               AELSE
                   :&F1_X  SETA 0
                   :&F1_XC SETC '0'
                   ACALL SET_LIT_TYPE_LEN
                   :&F1_T SETC '&LIT_TYPE'
                   :&F1_L SETA &LIT_LEN
               AEND
         AELSE
               :&IOP SETA -&IOP_F1_X(&I)
               :&F1_N SETC '&TMP_NAME(&IOP)'
               :&F1_T SETC '&TMP_TYPE(&IOP)'
               :&F1_L SETA &TMP_LEN(&IOP)
               :&F1_X SETA -&IOP
               :&F1_XC SETC '-&IOP'
         AEND
         AIF   (&IOP_F2_X(&I) GE 0)
               :&VAR_PARM_IX SETA &IOP_F2_X(&I)-1
               :&VAR_PREV_PARM SETC ''
               :&FIELD_SS1 SETB 1
               :&FIELD_REG SETC 'ZC_R3'
               ACALL  GET_VAR_PARM   GEN SIX CODE FOR VAR IF ANY
               :&F2_N SETC '&FIELD_NAME'
               :&F2_X SETA &FIELD_IX
               :&F2_XC SETC '&F2_X'
               AIF (&F2_X GT 0)
                   :&F2_T SETC '&SYM_PIC_TYPE(&F2_X)'
                   :&F2_L SETA &SYM_LEN(&F2_X)
               AELSE
                   :&F2_X  SETA 0
                   :&F2_XC SETC '0'
                   ACALL SET_LIT_TYPE_LEN
                   :&F2_T SETC '&LIT_TYPE'
                   :&F2_L SETA &LIT_LEN
               AEND
         AELSE
               :&IOP SETA -&IOP_F2_X(&I)
               :&F2_N SETC '&TMP_NAME(&IOP)'
               :&F2_T SETC '&TMP_TYPE(&IOP)'
               :&F2_L SETA &TMP_LEN(&IOP)
               :&F2_X SETA -&IOP
               :&F2_XC SETC '-&IOP'
         AEND
         AIF   (&I LT &IOP_TOT)
               :&TMP_IX SETA &IOP_F3_X(&I)
               :&F3_X SETA -&TMP_IX
               :&F3_XC SETC '-&TMP_IX'
               ACALL CALC_F3_TYPE
               :&F3_N SETC '&TMP_NAME(&TMP_IX)(&F3_L)'  
               :&TMP_TYPE(&TMP_IX) SETC '&F3_T'
               :&TMP_LEN(&TMP_IX)  SETA '&F3_L'
               :&F3_S SETB 1
               :&TMP_SIGN(&TMP_IX) SETB &F3_S
               AIF (&IOP_OP(&I) NE 4)  MOVE 1ST OP TO TEMP IF NOT DIV
                   :&LAB SETC '&F1_N'
                   ACALL RESET_LAB_LEN
                   GEN_MOVE &F3_N,&F3_XC,&LAB,&F1_XC
               AEND
         AELSE
               :&F3_N SETC '&T_NAME'
               :&F3_X SETA &T_IX
               :&F3_XC SETC '&F3_X'
               :&F3_T SETC '&SYM_PIC_TYPE(&T_IX)'
               :&F3_L SETA &SYM_LEN(&T_IX)
               :&F3_S SETB &SYM_PIC_SIGN(&T_IX)
               AIF  ('&F3_N' NE '&F1_N')
                   :&LAB SETC '&F1_N'
                   ACALL RESET_LAB_LEN
                   GEN_MOVE &F3_N,&F3_XC,&LAB,&F1_XC
               AEND
         AEND
         AEND
.*
.* GET TMP - SET TMP_IX TO FREE TMP
.*
         AENTRY GET_TMP
         AIF   (&CUR_TMP_FREE EQ 0)
               :&MAX_TMP SETA &MAX_TMP+1
               :&TMP_NAME(&MAX_TMP) SETC 'ZCVT_WORKAREA+&TMP_OFF'
               :&TMP_OFF SETA &TMP_OFF+16
               :&TMP_IX SETA &MAX_TMP
         AELSE
               :&TMP_IX SETA &TMP_FREE_IX(&CUR_TMP_FREE)
               :&CUR_TMP_FREE SETA &CUR_TMP_FREE-1
         AEND
         AEND
.*
.* FREE TMP ADD TMP_IX TO FREE TMP FEILD LIST
.*
         AENTRY FREE_TMP
         :&CUR_TMP_FREE SETA &CUR_TMP_FREE+1
         :&TMP_FREE_IX(&CUR_TMP_FREE) SETA &TMP_IX
         AEND
.*
.* SET LIT TYPE LEN FROM FIELD_NAME VALUE
.*
         AENTRY SET_LIT_TYPE_LEN
         :&LIT_LEN SETA 0
         :&FLT SETA ('&FIELD_NAME' INDEX '.')
         AIF (&FLT GT 0)
             AIF (K'&FIELD_NAME GT 16)
                 :&LIT_TYPE SETC '9'
             AELSE 
                 :&LIT_TYPE SETC '8'
             AEND
         AELSE
             AIF (K'&FIELD_NAME GT 18)
                 :&LIT_TYPE SETC 'Q'
             AELSEIF (K'&FIELD_NAME GT 9) 
                 :&LIT_TYPE SETC 'G'
             AELSEIF (K'&FIELD_NAME GT 5) 
                 :&LIT_TYPE SETC 'F'
             AELSE 
                 :&LIT_TYPE SETC 'H'
             AEND
         AEND
         AEND
,*
.* PUSH VAR - PUSH VAR_IOP_IX (INDEX OF FIRST CD PARM OR -IOP INDEX)
.*         
         AENTRY PUSH_VAR
         :&STK_VAR_TOT SETA &STK_VAR_TOT+1
         :&STK_VAR(&STK_VAR_TOT) SETA &VAR_IOP_IX
         AEND
.*
.* PUSH OP_# - PUSH LOGICAL OPERATOR '(+-*/()' = '123456'
.*
         AENTRY PUSH_OP
         :&IX_PARM_TOT SETA 0             RESET CD PARM COUNTER AT LOP
         :&STK_OP_TOT SETA &STK_OP_TOT+1
         :&STK_OP(&STK_OP_TOT) SETA &OP#
         :&PREV_OP# SETA &OP#
         AEND           
.*
.* POP OP - POP LOGICAL OPERATOR NOT, AND, OR, '''('''
.*
         AENTRY POP_OP
         AIF   (&STK_OP_TOT GE 1)
               :&OP# SETA   &STK_OP(&STK_OP_TOT)
               :&STK_OP_TOT SETA &STK_OP_TOT-1
               AIF (&STK_OP_TOT GT 0)
                   :&PREV_OP# SETA &STK_OP(&STK_OP_TOT)
               AELSE
                   :&PREV_OP# SETA 0  NONE
               AEND
         AELSE
               MNOTE 8,'ZC_CALC POP OP ERROR - EMPTY STACK'
         AEND           
         AEND
.*
.* IOP GEN VAR - GEN SIX CODE FOR VAR AT VAR_PARM_IX IF ANY  
.*
         AENTRY IOP_GEN_VAR
         :&VAR_PARM_IX SETA &VAR_PARM_IX-1
         :&FIELD_SS1 SETB 1
         ACALL  GET_VAR_PARM
         AEND
.*
.*
.* IOP GEN 88 - GEN 1 OR MORE CONDITION 88 LEVEL COMPARES
.*
         AENTRY IOP_GEN_88
         :&FIELD1    SETC '&FIELD_NAME'
         :&FIELD1_IX SETA &FIELD_IX
         :&V88_IX    SETA &SYM_LOC(&FIELD_88_IX)  FIRST VALUE INDEX
         :&V88_MULT  SETB 0                       ASSUME NOT MULT
         :&CCT SETC 'EQ'       NO  THEN EQ = OK
         AWHILE (&V88_IX GT 0)
               GEN_COMP &FIELD1,&FIELD1_IX,&V88_VAL(&V88_IX),0
               :&V88_IX SETA &V88_NEXT(&V88_IX)
               AIF (&V88_IX GT 0)
                   AIF (&IOP_OP(&I) NE 1)
                       AIF (NOT &V88_MULT)
                           :&V88_MULT SETB 1
                           :&IOP_LAB SETA &IOP_LAB+1   IOP T LABEL
                       AEND
                       GEN_BC &CCT,IF_&IE_TCNT(&IE_LVL)_IOP_&IOP_LAB
                   AELSE
                       GEN_BC &CCT,IF_&IE_TCNT(&IE_LVL)_&IE_BCNT(&IE_LVX
               L)
                   AEND
               AEND
         AEND
         AEND
.*
.* GET DFHRESP VALUE
.*
         AENTRY GET_DFHRESP_VALUE
         GBLA  &DFHRESP_TOT
         GBLC  &DFHRESP_KEY(30),&DFHRESP_VALUE(30)
         AIF   (&DFHRESP_TOT EQ 0)
               :&DFHRESP_VALUE(01) SETC '0' DFHRESP(NORMAL) 
               :&DFHRESP_VALUE(02) SETC '1' DFHRESP(ERROR)
               :&DFHRESP_VALUE(03) SETC '12' DFHRESP(FILENOTFOUND) 
               :&DFHRESP_VALUE(04) SETC '12' DFHRESP(DSIDERR)      
               :&DFHRESP_VALUE(05) SETC '13' DFHRESP(NOTFND)       
               :&DFHRESP_VALUE(06) SETC '14' DFHRESP(DUPREC)       
               :&DFHRESP_VALUE(07) SETC '15' DFHRESP(DUPKEY)       
               :&DFHRESP_VALUE(08) SETC '16' DFHRESP(INVREQ)
               :&DFHRESP_VALUE(09) SETC '18' DFHRESP(NOSPACE)      
               :&DFHRESP_VALUE(10) SETC '19' DFHRESP(NOTOPEN)      
               :&DFHRESP_VALUE(11) SETC '20' DFHRESP(ENDFILE)      
               :&DFHRESP_VALUE(13) SETC '21' DFHRESP(ILLOGIC)      
               :&DFHRESP_VALUE(14) SETC '22' DFHRESP(LENGERR)
               :&DFHRESP_VALUE(15) SETC '26' DFHRESP(ITEMERR)      
               :&DFHRESP_VALUE(16) SETC '27' DFHRESP(PGMIDERR)
               :&DFHRESP_VALUE(17) SETC '31' DFHRESP(EXPIRED)      
               :&DFHRESP_VALUE(18) SETC '36' DFHRESP(MAPFAIL)      
               :&DFHRESP_VALUE(19) SETC '38' DFHRESP(INVMPSZ)      
               :&DFHRESP_VALUE(20) SETC '40' DFHRESP(OVERFLOW)     
               :&DFHRESP_VALUE(21) SETC '44' DFHRESP(QIDERR)       
               :&DFHRESP_VALUE(22) SETC '72' DFHRESP(SUPPRESSED)     
               :&DFHRESP_VALUE(23) SETC '84' DFHRESP(DISABLED)     
               :&DFHRESP_KEY(01) SETC 'NORMAL' 
               :&DFHRESP_KEY(02) SETC 'ERROR'
               :&DFHRESP_KEY(03) SETC 'FILENOTFOUND' 
               :&DFHRESP_KEY(04) SETC 'DSIDERR'      
               :&DFHRESP_KEY(05) SETC 'NOTFND'       
               :&DFHRESP_KEY(06) SETC 'DUPREC'       
               :&DFHRESP_KEY(07) SETC 'DUPKEY'       
               :&DFHRESP_KEY(08) SETC 'INVREQ' 
               :&DFHRESP_KEY(09) SETC 'NOSPACE'      
               :&DFHRESP_KEY(10) SETC 'NOTOPEN'      
               :&DFHRESP_KEY(11) SETC 'ENDFILE'      
               :&DFHRESP_KEY(13) SETC 'ILLOGIC'      
               :&DFHRESP_KEY(14) SETC 'LENGERR'
               :&DFHRESP_KEY(15) SETC 'ITEMERR'      
               :&DFHRESP_KEY(16) SETC 'PGMIDERR'
               :&DFHRESP_KEY(17) SETC 'EXPIRED'      
               :&DFHRESP_KEY(18) SETC 'MAPFAIL'      
               :&DFHRESP_KEY(19) SETC 'INVMPSZ'      
               :&DFHRESP_KEY(20) SETC 'OVERFLOW'     
               :&DFHRESP_KEY(21) SETC 'QIDERR'       
               :&DFHRESP_KEY(22) SETC 'SUPPRESSED'     
               :&DFHRESP_KEY(23) SETC 'DISABLED'     
               :&DFHRESP_TOT SETA 23
         AEND
         AIF   ('&SYSLIST(&VAR_PARM_IX+1)' EQ '''('''                  X
                OR '&SYSLIST(&VAR_PARM_IX+3)' EQ ''')''')
               :&PARM SETC '&SYSLIST(&VAR_PARM_IX+2)'
               :&VAR_PARM_IX SETA &VAR_PARM_IX+3
         AELSE
               MNOTE 8,'ZC_CALC INVALID DFHRESP PARM FORMAT AT &PARM'
               MEXIT
         AEND
         :&J SETA 1
         AWHILE (&J LE &DFHRESP_TOT)
               AIF ('&PARM' EQ '&DFHRESP_KEY(&J)')
                   :&PARM SETC '&DFHRESP_VALUE(&J)'
                   AEXIT AENTRY
               AEND
               :&J SETA &J+1
         AEND
         MNOTE 8,'ZC_CALC INVALID OR UNKNOWN DFHRESP VALUE - &PARM'
         AEND
.*
.* GET DFHVALUE VALUE
.*
         AENTRY GET_DFHVALUE_VALUE
         GBLA  &DFHVALUE_TOT
         GBLC  &DFHVALUE_KEY(30),&DFHVALUE_VALUE(30)
         AIF   (&DFHVALUE_TOT EQ 0)
               :&DFHVALUE_VALUE(01) SETC '18' DFHVALUE(OPEN) 
               :&DFHVALUE_VALUE(02) SETC '19' DFHVALUE(CLOSED)
               :&DFHVALUE_KEY(01) SETC 'OPEN' 
               :&DFHVALUE_KEY(02) SETC 'CLOSED'
               :&DFHVALUE_TOT SETA 2
         AEND
         AIF   ('&SYSLIST(&VAR_PARM_IX+1)' EQ '''('''                  X
                OR '&SYSLIST(&VAR_PARM_IX+3)' EQ ''')''')
               :&PARM SETC '&SYSLIST(&VAR_PARM_IX+2)'
               :&VAR_PARM_IX SETA &VAR_PARM_IX+3
         AELSE
               MNOTE 8,'ZC_CALC INVALID DFHVALUE PARM FORMAT AT &PARM'
               MEXIT
         AEND
         :&J SETA 1
         AWHILE (&J LE &DFHVALUE_TOT)
               AIF ('&PARM' EQ '&DFHVALUE_KEY(&J)')
                   :&PARM SETC '&DFHVALUE_VALUE(&J)'
                   AEXIT AENTRY
               AEND
               :&J SETA &J+1
         AEND
         MNOTE 8,'ZC_CALC INVALID DFHVALUE VALUE - &PARM'
         AEND
.*
.* GET NEXT IF PARM (SUBSTITUTE DFHRESP(CODE) WITH LITERAL VALUE)
.*
         AENTRY GET_PARM
         :&PREV_PARM SETC '&PARM'
         :&PARM_IX SETA &PARM_IX+1
         AIF (&PARM_IX LE &NP)
             :&PARM SETC '&SYSLIST(&PARM_IX)'     
         AELSE
             AIF (&LVL NE 0)
                 MNOTE 8,'ZC_CALC UNBALANCED (...)'
             AEND
             :&PARM SETC ''
         AEND
         AEND
.*
.* GET VAR PARM USING VAR_PARM_IX UNTIL NEXT OP                                
.*
         AENTRY GET_VAR_PARM
         :&PREV_PARM SETC '&PARM'
         :&VAR_PARM_IX SETA &VAR_PARM_IX+1
         AIF   (&VAR_PARM_IX LE &NP)
               :&PARM SETC '&SYSLIST(&VAR_PARM_IX)'
               AIF ('&PARM'(1,1) NE '''')              
                   :&SAVE_PARM_IX SETA &PARM_IX
                   :&PARM_IX SETA &VAR_PARM_IX
                   ACALL GET_PARM_FIELD
                   :&VAR_PARM_IX SETA &PARM_IX-1
                   :&PARM_IX SETA &SAVE_PARM_IX
               AELSE
                   :&FIELD_IX SETA 0
               AEND
         AELSE
               :&PARM SETC ''
         AEND
         AEND
.*
.* LIST IOPS FOR AID IN DEBUGGING
.* 
         AENTRY LIST_IOPS
         :&J   SETA 1
         MNOTE 'ZCOBOL IOP TABLE LISTING - TOTAL IOPS = &IOP_TOT'
         AWHILE (&J LE &IOP_TOT)
               MNOTE 'IOP=&J OP=&IOP_OP(&J) F1=&IOP_F1_X(&J) F2=&IOP_F1X
               _X(&J) F3=&TMP_TYPE(&J)'
               :&J SETA &J+1
         AEND
         AEND
.*
.* CALC F3_T TYPE FROM F1_T AND F2_T ALSO SET F3_L FOR TYPE P
.*
         AENTRY CALC_F3_TYPE
         :&EXTEND_FP_TYPE SETC '9'               
         :&EXTEND_FP_LNG  SETA 16
         :&NOEXTEND_FP_TYPE SETC '2'
         :&NOEXTEND_FP_LNG  SETA 8
         ACASE (C2A('&F1_T'))
         AWHEN C'1',C'2',C'3',C'4',C'5',C'6',C'7',C'8',C'9'
               AIF (&ZC_EXTEND)
                   :&F3_T SETC '&EXTEND_FP_TYPE'
                   :&F3_L SETA &EXTEND_FP_LNG
               AELSE
                   :&F3_T SETC '&NOEXTEND_FP_TYPE'
                   :&F3_L SETA &NOEXTEND_FP_LNG
               AEND
         AWHEN C'F'
               ACASE (C2A('&F2_T'))
               AWHEN C'1',C'2',C'3',C'4',C'5',C'6',C'7',C'8',C'9'
                   AIF (&ZC_EXTEND)
                       :&F3_T SETC '&EXTEND_FP_TYPE'
                       :&F3_L SETA &EXTEND_FP_LNG
                   AELSE
                       :&F3_T SETC '&NOEXTEND_FP_TYPE'
                       :&F3_L SETA &NOEXTEND_FP_LNG
                   AEND
               AWHEN C'F'
                 :&F3_T SETC 'Q'
               AWHEN C'G'
                 :&F3_T SETC 'Q'
               AWHEN C'H'
                 :&F3_T SETC 'G'
               AWHEN C'P'
                 AIF (&F2_L GT 5)
                    :&F3_T SETC 'Q'
                 AELSE
                    :&F3_T SETC 'G'
                 AEND
               AWHEN C'Q'
                 :&F3_T SETC 'Q'
               AWHEN C'Z'
                 AIF (&F2_L GT 9)
                    :&F3_T SETC 'Q'
                 AELSE
                    :&F3_T SETC 'G'
                 AEND
               AELSE
                MNOTE 8,'ZC_CALC INVALID TYPE &F2_T'
                MEXIT
               AEND
         AWHEN C'G'
               ACASE (C2A('&F2_T'))
               AWHEN C'1',C'2',C'3',C'4',C'5',C'6',C'7',C'8',C'9'
                   AIF (&ZC_EXTEND)
                       :&F3_T SETC '&EXTEND_FP_TYPE'
                       :&F3_L SETA &EXTEND_FP_LNG
                   AELSE
                       :&F3_T SETC '&NOEXTEND_FP_TYPE'
                       :&F3_L SETA &NOEXTEND_FP_LNG
                   AEND
               AWHEN C'F'
                 :&F3_T SETC 'Q'
               AWHEN C'G'
                 :&F3_T SETC 'Q'
               AWHEN C'H'
                 :&F3_T SETC 'Q'
               AWHEN C'P'
                 :&F3_T SETC 'Q'
               AWHEN C'Q'
                 :&F3_T SETC 'Q'
               AWHEN C'Z'
                 :&F3_T SETC 'Q'
               AELSE
                MNOTE 8,'ZC_CALC INVALID TYPE &F2_T'
                MEXIT
               AEND
         AWHEN C'H'
               ACASE (C2A('&F2_T'))
               AWHEN C'1',C'2',C'3',C'4',C'5',C'6',C'7',C'8',C'9'
                   AIF (&ZC_EXTEND)
                       :&F3_T SETC '&EXTEND_FP_TYPE'
                       :&F3_L SETA &EXTEND_FP_LNG
                   AELSE
                       :&F3_T SETC '&NOEXTEND_FP_TYPE'
                       :&F3_L SETA &NOEXTEND_FP_LNG
                   AEND
               AWHEN C'F'
                 :&F3_T SETC 'G'
               AWHEN C'G'
                 :&F3_T SETC 'Q'
               AWHEN C'H'
                 :&F3_T SETC 'G'
               AWHEN C'P'
                 AIF (&F2_L LE 2)
                    :&F3_T SETC 'F'
                 AELSEIF (&F2_L LE 7)
                    :&F3_T SETC 'G'
                 AELSE
                    :&F3_T SETC 'Q'
                 AEND
               AWHEN C'Q'
                 :&F3_T SETC 'Q'
               AWHEN C'Z'
                 AIF (&F2_L LE 4)
                    :&F3_T SETC 'F'
                 AELSEIF (&F2_L LE 13)
                    :&F3_T SETC 'G'
                 AELSE
                    :&F3_T SETC 'Q'
                 AEND
               AELSE
                MNOTE 8,'ZC_CALC INVALID TYPE &F2_T'
                MEXIT
               AEND
         AWHEN C'P'
               ACASE (C2A('&F2_T'))
               AWHEN C'1',C'2',C'3',C'4',C'5',C'6',C'7',C'8',C'9'
                   AIF (&ZC_EXTEND)
                       :&F3_T SETC '&EXTEND_FP_TYPE'
                       :&F3_L SETA &EXTEND_FP_LNG
                   AELSE
                       :&F3_T SETC '&NOEXTEND_FP_TYPE'
                       :&F3_L SETA &NOEXTEND_FP_LNG
                   AEND
               AWHEN C'F'
                 AIF (&F1_L LE 5)
                    :&F3_T SETC 'G'
                 AELSE
                    :&F3_T SETC 'Q'
                 AEND
               AWHEN C'G'
                 :&F3_T SETC 'Q'
               AWHEN C'H'
                 AIF (&F1_L LE 2)
                    :&F3_T SETC 'F'
                 AELSEIF (&F1_L LE 7)
                    :&F3_T SETC 'G'
                 AELSE
                    :&F3_T SETC 'Q'
                 AEND
               AWHEN C'P'
                 AIF (&F1_L+&F2_L  LE 16)
                    :&F3_T SETC 'P'
                    :&F3_L SETA &F1_L+&F2_L
                 AELSE
                    :&F3_T SETC 'Q'
                 AEND
               AWHEN C'Q'
                 :&F3_T SETC 'Q'
               AWHEN C'Z'
                 AIF (&F1_L+&F2_L LE 31)
                     :&F3_T SETC 'P'
                     :&F3_L SETA (&F1_L+&F2_L)/2+1
                 AELSE
                    :&F3_T SETC 'Q'
                 AEND
               AELSE
                MNOTE 8,'ZC_CALC INVALID TYPE &F2_T'
                MEXIT
               AEND
         AWHEN C'Q'
               ACASE (C2A('&F2_T'))
               AWHEN C'1',C'2',C'3',C'4',C'5',C'6',C'7',C'8',C'9'
                   AIF (&ZC_EXTEND)
                       :&F3_T SETC '&EXTEND_FP_TYPE'
                       :&F3_L SETA &EXTEND_FP_LNG
                   AELSE
                       :&F3_T SETC '&NOEXTEND_FP_TYPE'
                       :&F3_L SETA &NOEXTEND_FP_LNG
                   AEND
               AWHEN C'F'
                 :&F3_T SETC 'Q'
               AWHEN C'G'
                 :&F3_T SETC 'Q'
               AWHEN C'H'
                 :&F3_T SETC 'Q'
               AWHEN C'P'
                 :&F3_T SETC 'Q'
               AWHEN C'Q'
                 :&F3_T SETC 'Q'
               AWHEN C'Z'
                 :&F3_T SETC 'Q'
               AELSE
                MNOTE 8,'ZC_CALC INVALID TYPE &F2_T'
                MEXIT
               AEND
         AWHEN C'Z'
               ACASE (C2A('&F2_T'))
               AWHEN C'1',C'2',C'3',C'4',C'5',C'6',C'7',C'8',C'9'
                   AIF (&ZC_EXTEND)
                       :&F3_T SETC '&EXTEND_FP_TYPE'
                       :&F3_L SETA &EXTEND_FP_LNG
                   AELSE
                       :&F3_T SETC '&NOEXTEND_FP_TYPE'
                       :&F3_L SETA &NOEXTEND_FP_LNG
                   AEND
               AWHEN C'F'
                 AIF (&F1_L GE 9)
                    :&F3_T SETC 'G'
                 AELSE
                    :&F3_T SETC 'Q'
                 AEND
               AWHEN C'G'
                 :&F3_T SETC 'Q'
               AWHEN C'H'
                 AIF (&F1_L LE 4)
                    :&F3_T SETC 'F'
                 AELSEIF (&F1_L LE 13)
                    :&F3_T SETC 'G'
                 AELSE
                    :&F3_T SETC 'Q'
                 AEND
               AWHEN C'P'
                 AIF (&F1_L+2*&F2_L-1 LE 31)
                     :&F3_T SETC 'P'
                     :&F3_L SETA &F1_L/2+1+&F2_L
                 AELSE
                    :&F3_T SETC 'Q'
                 AEND
               AWHEN C'Q'
                 :&F3_T SETC 'Q'
               AWHEN C'Z'
                 AIF (&F1_L+&F2_L LE 31)
                     :&F3_T SETC 'P'
                     :&F3_L SETA (&F1_L+&F2_L)/2+1
                 AELSE
                    :&F3_T SETC 'Q'
                 AEND
               AELSE
                MNOTE 8,'ZC_CALC INVALID F2 TYPE &F2_T'
                MEXIT
               AEND
         AELSE
               MNOTE  8,'ZC_CALC INVALID F1 TYPE &F1_T'
               MEXIT
         AEND
         ACASE (C2A('&F3_T'))
         AWHEN C'1'
              :&F3_L SETA 4
         AWHEN C'2'
              :&F3_L SETA 8
         AWHEN C'3'
              :&F3_L SETA 16
         AWHEN C'4'
              :&F3_L SETA 4
         AWHEN C'5'
              :&F3_L SETA 8
         AWHEN C'6'
              :&F3_L SETA 16
         AWHEN C'7'
              :&F3_L SETA 4
         AWHEN C'8'
              :&F3_L SETA 8
         AWHEN C'9'
              :&F3_L SETA 16
         AWHEN C'F'
              :&F3_L SETA 4
         AWHEN C'G'
              :&F3_L SETA 8
         AWHEN C'H'
              :&F3_L SETA 2
         AWHEN C'Q'
              :&F3_L SETA 16
         AEND
         AEND
         COPY ZCRSTLAB
         COPY ZCGETFLD
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/07/08                                                 *
.*********************************************************************
.* 04/08/08 initial coding to list all ws sym addr, len, pic, val
.* 05/03/08 align fields and call GEN_COMMENT for report lines    
.* 10/06/08 ZSTRMAC
.*********************************************************************
         ZC_DATA_LIST                                        
         COPY  ZC_WS
         AIF   (&SYM_TOT EQ 0)
               MEXIT
         AEND
         AIF   (NOT &LK_MODE)
               GEN_COMMENT 'ZCOBOL WORKING STORAGE SECTION DATA ITEMS'
         AELSE
               GEN_COMMENT 'ZCOBOL LINKAGE SECTION DATA ITEMS'
         AEND
         GEN_COMMENT 'LVL DATA NAME                      ADDR     LEN  X
                   DUP TYP PIC        VALUE'
         ACTR  100000
         :&I       SETA  1
         AWHILE (&I LE &SYM_TOT)
                AIF   ((NOT &LK_MODE AND &SYM_LK(&I) EQ 0)             X
                      OR (&LK_MODE AND &SYM_LK(&I) GT 0))
                    :&LVL     SETC  '0&SYM_LVL(&I)'
                    :&LVL     SETC  '&LVL'(K'&LVL-1,2).' '
                    :&SYM     SETC  '&SYM_NAME(&I)'
                    AIF  (K'&SYM LT 30)
                         :&SYM  SETC  '&SYM                            X
                 '(1,30)
                    AEND
                    :&ADDR    SETC  A2X(&SYM_LOC(&I))
                    :&LEN     SETC  A2X(&SYM_LEN(&I))
                    :&DUP     SETC  '&SYM_DUP(&I)  '
                    :&PICTYPE SETC  '&SYM_PIC_TYPE(&I)  '
                    :&PIC     SETC  '&SYM_PIC(&I)'
                    AIF   (K'&PIC LE 15)
                         :&PIC SETC  '&PIC               '(1,10)
                    AEND
                    :&VAL SETC  (DOUBLE '&SYM_VAL(&I)')
                    GEN_COMMENT  '&LVL &SYM &ADDR &LEN &DUP &PICTYPE &PX
               IC &VAL'
               AEND
               :&I SETA &I+1
         AEND
         MEND   
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/14/08                                                 *
.*********************************************************************
.* 04/14/08 initial coding for global find symbol 
.* 10/06/08 ZSTRMAC
.*********************************************************************
         ZC_FILE_FIND &FILE     
         COPY  ZC_WS     
&FILE_IX  SETA  1
         AWHILE (&FILE_IX LE &FILE_TOT)
                AIF   ('&FILE_NAME(&FILE_IX)' EQ '&FILE')
                      MEXIT
                AEND
                :&FILE_IX SETA &FILE_IX+1
         AEND
&FILE_IX SETA 0
        MEND       
         MACRO
.*********************************************************************
.* Copyright 2009 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 07/17/09                                                 *
.*********************************************************************
.* 07/17/09 RPI 1065 get qualified name for ZCGETFLD and_SYM_INDEX
.* 07/17/09 RPI 1065 set heading to 30 for max base name +#n#+ tail
.*********************************************************************
.*  1.   Build qualified FIELD_NAME FROM GBL QNAME vars   
.*  2.   If qualified name > 63, truncate to leading 30 + #n# +
.*       trailing up to 63.  
.*  3.   n is unique trunc counter
.*********************************************************************
         ZC_GET_QNAME
         COPY  ZC_WS
         AIF   (&QNAME_LEN GT 63)  RPI 1065 BUILD TRUN NAME ALIAS
               :&HEAD SETC '&QNAME(1)'
               :&QI SETA 2
               AWHILE (K'&HEAD LT 30)
                   :&HEAD SETC '&HEAD._OF_&QNAME(&QI)'
                   :&QI SETA &QI+1
               AEND
               :&QI SETA &QNAME_TOT-1
               :&TAIL SETC '&QNAME(&QNAME_TOT)'
               AWHILE (K'&TAIL LT 30)
                     :&TAIL SETC '&QNAME(&QI)._OF_&TAIL'
                     :&QI SETA &QI-1
               AEND
               GBLA &ZC_TRNC_LAB
               :&ZC_TRNC_LAB SETA &ZC_TRNC_LAB+1
               :&HEAD SETC '&HEAD'(1,30).'#&ZC_TRNC_LAB.#'
               :&LTAIL SETA 63-K'&HEAD
               :&FIELD_NAME SETC '&HEAD'.'&TAIL'(K'&TAIL-&LTAIL+1,*)
         AELSE
               :&QI SETA 2  
               :&FIELD_NAME SETC '&QNAME(1)'             
               AWHILE (&QI LE &QNAME_TOT)
                   :&FIELD_NAME SETC '&FIELD_NAME._OF_&QNAME(&QI)'
                   :&QI SETA &QI+1
               AEND
         AEND
         MEND
         MACRO
.*********************************************************************
.* Copyright 2009 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 01/26/09                                                 *
.*********************************************************************
.* 01/26/09 initial coding to set &PIC_DIGITS from &SYM_PIC(&IX)
.*********************************************************************
         ZC_PIC_DIGITS &IX
         COPY  ZC_WS
         :&PIC SETC '&SYM_PIC(&IX)'
         :&PIC_DIGITS SETA 0
         :&I SETA 1
         AWHILE (&I LE K'&PIC)
               :&CHAR SETC '&PIC'(&I,1)
               AIF ('&CHAR' EQ '9' OR '&CHAR' EQ 'Z')
                   :&PIC_DIGITS SETA &PIC_DIGITS+1
               AELSEIF ('&CHAR' EQ '(')
                   :&DUP SETA '&PIC'(&I+1,1)
                   :&I SETA &I+2
                   AWHILE (&I LT K'&PIC AND '&PIC'(&I,1) NE ')')
                       :&DIG SETA '&PIC'(&I,1)
                       :&DUP SETA &DUP*10+&DIG
                       :&I SETA &I+1
                   AEND
                   :&PIC_DIGITS SETA &PIC_DIGITS+&DUP-1
               AEND
               :&I SETA &I+1
         AEND
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author.  Don Higgins                                              *
.* Date   - 04/07/08                                                 *
.*********************************************************************
.* 04/08/08 initial coding to set SYM_LEN(&SYM_TOT) from SYM_PIC 
.* 05/02/08 just set SYM_LEN(&SYM_TOT) based on &SYM_PIC(&SYM_TOT) 
.* 10/06/08 ZSTRMAC
.*********************************************************************
         ZC_PIC_LEN                                       
         COPY  ZC_WS            
         :&LEN     SETA  0
         :&MASK    SETC  '&SYM_PIC(&SYM_TOT)'
         :&MASK_LEN SETC K'&MASK
         :&I       SETA  1
         AWHILE (&I LE &MASK_LEN)
               :&CHAR    SETC  '&MASK'(&I,1)
               AIF   ('&CHAR' EQ '9'                                   X
                      OR '&CHAR' EQ 'Z'                                X
                      OR '&CHAR' EQ 'X')    
                    :&LEN SETA  &LEN+1
               AELSEIF ('&CHAR' EQ '(')
                    :&LEN     SETA   0
                    :&I       SETA   &I+1
                    AWHILE (&I LE &MASK_LEN                            X
                            AND '&MASK'(&I,1) NE ')')
                        :&CHAR    SETC  '&MASK'(&I,1)
                        AIF ('&CHAR' GE '0' AND '&CHAR' LE '9')     
                            :&LEN SETA  &LEN*10+&CHAR
                        AELSE
                            MNOTE 8,'PIC MASK ERROR &LVL &SYM_NAME(&SYMX
               _TOT)'
                            MEXIT
                        AEND
                        :&I SETA &I+1
                    AEND
               AELSEIF ('&CHAR' NE 'S' AND '&CHAR' NE '.')      
                    MNOTE 8,'PIC MASK ERROR &LVL &SYM_NAME(&SYMTOT)'
                    MEXIT
               AEND
               :&I SETA &I+1
         AEND
&SYM_LEN(&SYM_TOT) SETA &LEN
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/07/08                                                 *
.*********************************************************************
.* 10/14/08 INITIAL CODDING
.* 08/06/09 RPI 1062 ADD PROCEDURE SECTION AND PARAGRAPH STATISTICS
.*********************************************************************
         ZC_STATS      
         COPY  ZC_WS
         MNOTE *.'ZCOBOL TOTAL SYMBOLS                 = &SYM_TOT'
         MNOTE *.'ZCOBOL TOTAL SYMBOL DUPLICATES       = &SYM_DUP_TOT'
         MNOTE *.'ZCOBOL TOTAL SYMBOL MAX DUP CHAIN    = &SYM_DUP_MAX'
         MNOTE *.'ZCOBOL TOTAL SYMBOL LEVEL 88         = &V88_TOT'
         MNOTE *.'ZCOBOL TOTAL SYMBOL SET INDEXES      = &SET_TOT'
         MNOTE *.'ZCOBOL TOTAL SYMBOL LINKAGE SECTIONS = &LK_TOT'
         MNOTE *.'ZCOBOL TOTAL PROCEDURE SECTIONS      = &SN_TOT'
         MNOTE *.'ZCOBOL TOTAL PROCEDURE PARAGRAPHS    = &PG_TOT'
         MNOTE *.'ZCOBOL TOTAL PROCEDURE PARAGRAPH DUP = &PG_DUP_TOT'
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/07/08                                                 *
.*********************************************************************
.* 04/09/08 initial coding for global find symbol 
.* 07/26/08 add hash table search replacing serial search
.* 10/06/08 ZSTRMAC
.* 11/17/08  replace hash calc with GBLA &(ZC_IX_&SYM) to save/fetch ix
.*********************************************************************
         ZC_SYM_FIND &SYM
         GBLA  &(ZC_IX_&SYM)
         GBLA  &SYM_IX
         :&SYM_IX SETA &(ZC_IX_&SYM)
         MEND
         MACRO
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/07/08                                                 *
.*********************************************************************
.* 07/27/08 initial coding 
.* 10/06/08 ZSTRMAC
.* 10/14/08 USE ZC_SYM_FIND TO ELIM DUP CODE
.* 11/17/08  replace hash calc with GBLA &(ZC_IX_&SYM) to save/fetch ix
.* 07/08/09 RPI 1065 truncate to 63 via ..FIRST 25.._T#N_..REMAINING..
.* 08/10/09 RPI 1065 only replace base name if not proc div alias name
.*********************************************************************
         ZC_SYM_INDEX &SYM,&QIX  
         COPY  ZC_WS    
         ZC_SYM_FIND &SYM
         AIF   (&SYM_IX EQ 0)  NO MATCHING BASE FOUND
               GBLA &(ZC_IX_&SYM)
               :&(ZC_IX_&SYM) SETA &SYM_TOT
         AELSE 
               AIF  (&SYM_LVL(&SYM_TOT) EQ 1                           X
                     AND &SYM_LVL(&SYM_IX) EQ 1)  RPI 1065 01'S UNIQUE
                   MNOTE 8,'ZC_SYM_INDEX - DUPLICATE 01 SYMBOLS - &SYM'    
               AELSE
                    :&SYM_DUP_TOT SETA &SYM_DUP_TOT+1
                    AIF (&SYM_FXT(&SYM_IX) EQ 0) IS THIS FIRST DUP
                         :&SYM_FXT(&SYM_IX)  SETA &SYM_IX
                         :&SYM_FXT(&SYM_TOT) SETA &SYM_IX
                         :&SYM_NXT(&SYM_IX) SETA &SYM_TOT
                         :&QSYM_IX SETA &SYM_IX   YES, FIX FIRST 
                         ACALL FIX_DUP_QUAL_SYM
                    AELSE
                         :&SYM_FXT(&SYM_TOT) SETA &SYM_IX
                         :&SYM_NXT(&SYM_TOT) SETA &SYM_NXT(&SYM_IX)
                         :&SYM_NXT(&SYM_IX) SETA &SYM_TOT
                    AEND
                    :&QSYM_IX SETA &SYM_TOT       FIX NEXT DUP
                    ACALL FIX_DUP_QUAL_SYM 
               AEND
         AEND      
         MEXIT
.*
.* FIX DUP QUALIFIED SYMBOL NAMES TO BE UNIQUE BY ADDING _OF_QUAL
.*
         AENTRY FIX_DUP_QUAL_SYM
         AIF (&SYM_LVL(&QSYM_IX) EQ 1)  RPI 1065 DON'T CHANGE 01
              AEXIT AENTRY
         AEND
         :&CUR_QIX SETA &SYM_QIX(&QSYM_IX)  FIRST INDEX LEVEL
         :&QNAME(1)  SETC '&SYM_NAME(&QSYM_IX)' BASE NAME
         :&QNAME_LEN SETA K'&QNAME(1)
         :&QNAME_TOT SETA 1
         AWHILE (&CUR_QIX GT 0)        RPI 1065 USE ZC_GET_QNAME
              AIF (&QNAME_TOT LT 50)
                  :&QNAME_TOT SETA &QNAME_TOT+1
                  :&QNAME(&QNAME_TOT) SETC '&SYM_NAME(&CUR_QIX)'
                  :&QNAME_LEN SETA &QNAME_LEN+4+K'&QNAME(&QNAME_TOT)
              AELSE
                  MNOTE 8,'ZC_SYM_INDEX MAX LEVELS EXCEEDED'
                  MEXIT
              AEND
              :&CUR_QIX SETA &SYM_QIX(&CUR_QIX)
         AEND
         ZC_GET_QNAME
         ZC_SYM_FIND &FIELD_NAME
         AIF (&SYM_IX GT 0)
             MNOTE 8,'ZC_SYM_INDEX DUP SYM - &FIELD_NAME'
             MEXIT
         AEND
         GBLA &(ZC_IX_&FIELD_NAME)               CREATE ALIAS FOR FIND
         :&(ZC_IX_&FIELD_NAME) SETA &QSYM_IX
         AIF (NOT &ZC_PROC_DIV) RPI 1065 IS THIS PROC DIV REF
             :&SYM_NAME(&QSYM_IX) SETC '&FIELD_NAME' NO, REPLACE NAME
         AELSE
             :&FIELD_NAME SETC '&SYM_NAME(&QSYM_IX)' USE PRIOR NAME
         AEND
         AEND
         MEND       
.*
.* GET DFHRESP - SET &DFHLIT FOR &DFHRESP
.*
         AENTRY GET_DFHRESP
         GBLB  &ZC_DFHRESP
         AIF   (NOT &ZC_DFHRESP)
               :&ZC_DFHRESP SETB 1
               COPY ZC_DFHRESP                            RPI 1057
         AEND
         :&DFHSYM SETC 'DFHRESP_&DFHRESP'
         GBLC  &(&DFHSYM)
         :&DFHLIT SETC '&(&DFHSYM)'
         AIF   (K'&DFHLIT EQ 0)
               MNOTE 8,'ZCDFHLIT DFHRESP VALUE NOT FOUND - &DFHRESP'
               MEXIT
         AEND
         AEND
.*
.* GET DFHVALUE - SET &DFHLIT FOR &DFHVALUE
.*
         AENTRY GET_DFHVALUE
         GBLB  &ZC_DFHVALUE
         AIF   (NOT &ZC_DFHVALUE)
               :&ZC_DFHVALUE SETB 1
               COPY ZC_DFHVALUE                           RPI 1057
         AEND
         :&DFHSYM SETC 'DFHVALUE_&DFHVALUE'
         GBLC  &(&DFHSYM)
         :&DFHLIT SETC '&(&DFHSYM)'
         AIF   (K'&DFHLIT EQ 0)
               MNOTE 8,'ZCDFHLIT DFHVALUE NOT FOUND - &DFHVALUE'
               MEXIT
         AEND
         AEND
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/07/08                                                 *
.*********************************************************************
.* 02/23/08 RPI 1001 ADD SUPPORT FOR SIX ON CONDITION 88 LEVEL FIELD
.* 03/17/08 RPI 1004 COMBINE - WITH LITERAL VALUE                   
.* 07/09/09 RPI 1065 ONLY COMBINE +- IF FIELD IS ONLY +-            
.* 07/17/09 RPI 1065 TRUNC QUAL NAMES GT 63 USING ZC_GET_QNAME                  
.* 08/11/09 RPI 1065 REPLACE ZC_GET_QNAME USING ONLY FIND_QUAL_ALIAS             
.*********************************************************************
.* GET RX ADDRESSABLE QUALIFIED PARM FIELD FROM &SYSLIST(&PARM_IX)
.* INPUT
.*  1. &PARM_IX   SETA MUST BE SET TO CURRENT SYSLIST PARM
.*  2. &FIELD_REG SETC MUST BE SET TO TARGET REG FOR SUBSC VAR ADDR
.*  3. &FIELD_SS1 SETB MUST BE SET TO 1 IF OFF(LEN,REG) REQ VS OFF(REG)
.* OUTPUT
.*  1. &FIELD_IX   SETA = SYM_IX FOR FIELD IF FIELD FOUND ELSE 0 (LIT)
.*  2. &FIELD_SIX  SETB = 1 IF ADDR IN FIELD_REG DUE TO SUBS/INDEX/RMOD
.*  3. &FIELD_RMD  SETB = 1 IF (OFF:LEN) RFF. MOD. CHANGED FOLLOWING:
.*  3. &FIELD_OFF  SETA = OFFSET DEFAULT 0 MAY BE CHANGED BY RMOD
.*  4. &FIELD_LEN  SETA = LENGTH DEFAULT SYM_LEN(FIELD_IX) RMOD CHNG    
.*  5. &FIELD_NAME SETC = FIELD NAME, OFF(REG), OR OFF(LEN,REG) IF SS1
.*  6. &FIELD_88_IX SETA - 88 LVL INDEX ELSE 0
.* WHERE USED:
.*  1. ADD, DIVIDE, IF, GO, INSPECT, MULTIPLY, SUBTRACT, TRANSFORM
.*     GEN_DISPLAY.
.* USES:
.*  1. ZC_SYM_FIND  - find field &FIELD_NAME and set &FIELD_IX
.*  2. ZC_SYM_INDEX - resolve duplicate names if qualified
.*  3. ZC_GET_QNAME - build qualified name with turncation if > 63
.* NOTES
.*  1. May generate base setting code if required
.*  2. May generate subscript code if required 
.*  3. Errors - not found, no base, missing subsc., invalid subsc.
.*********************************************************************
         AENTRY GET_PARM_FIELD
         :&QNAME(1) SETC '&SYSLIST(&PARM_IX)'
         :&QNAME_LEN SETA K'&QNAME(1)    RPI 1065 CALC QUAL LENGTH
         :&QNAME_TOT SETA 1
         :&FIELD_NAME SETC '&QNAME(1)'
         :&FIELD_IX  SETA 0           RPI 1065 ASSUME NOT FOUND
         :&FIELD_SIX SETB 0           ASSUME NO SUBSCRIPT/INDEX
         :&FIELD_RMD SETB 0           ASSUME NO REF. MOD. (OFF:LEN)
         :&PARM_IX SETA &PARM_IX+1
         AIF ('&FIELD_NAME' EQ '-' OR '&FIELD_NAME' EQ '+') RPI 1065
             :&FIELD_NAME SETC '&FIELD_NAME&SYSLIST(&PARM_IX)'
             :&PARM_IX SETA &PARM_IX+1
             AEXIT AENTRY
         AEND
         AWHILE ('&SYSLIST(&PARM_IX)' EQ 'OF'                          X
               OR '&SYSLIST(&PARM_IX)' EQ 'IN')
               AIF (&QNAME_TOT GT 50)
                   MNOTE 8,'ZCGENFLD MAX QUAL LEVELS EXCEEDED'
                   MEXIT
               AEND
               :&QNAME_TOT SETA &QNAME_TOT+1
               :&QNAME(&QNAME_TOT) SETC '&SYSLIST(&PARM_IX+1)'
               :&QNAME_LEN SETA &QNAME_LEN+4+K'&QNAME(&QNAME_TOT)
               :&PARM_IX SETA &PARM_IX+2
         AEND
         ZC_SYM_FIND &FIELD_NAME
         :&FIELD_IX SETA &SYM_IX
         AIF   (&QNAME_TOT EQ 1)
               AIF   (&FIELD_IX EQ 0)  FIELD NOT FOUND
                     AEXIT AENTRY
               AEND
         AELSE
               ACALL FIND_QUAL_ALIAS  FIND ALIAS OF QUAL FIELD
         AEND
         AIF   (&FIELD_IX GT 0)
               AIF (&SYM_LVL(&FIELD_IX) EQ 88)
                   :&FIELD_88_IX SETA &FIELD_IX
                   :&FIELD_IX   SETA &SYM_REF(&FIELD_88_IX)
               AELSE
                   :&FIELD_88_IX SETA 0
               AEND
               :&FIELD_NAME SETC '&SYM_NAME(&FIELD_IX)' 
               AIF (NOT &ZC_PROC_DIV) RPI 1065 NO BASE/SIX IN WS
                   AEXIT AENTRY
               AEND
               GEN_BASE &FIELD_IX  GEN BASE IF REQ'D FOR RX ACCESS
               AIF   ('&SYSLIST(&PARM_IX)' EQ '''(''') SUBSC FOUND
                     AIF (&SYM_SIT(&FIELD_IX) GT 0)
                         ACALL GEN_SUBSCRIPT
                         AIF ('&SYSLIST(&PARM_IX)' EQ '''(''') RMOD FND
                             ACALL CALC_RMOD_OFF_LEN
                         AEND
                     AELSE
                         ACALL CALC_RMOD_OFF_LEN
                     AEND
               AELSEIF ('&SYM_SIT(&FIELD_IX)' GT 0)
                     MNOTE 8,'ZCGETFLD SUBSCRIPT MISSING FOR &FIELD_NAMX
               E'
                     MEXIT
               AEND
         AEND
         AEND
.*
.* FIND QUAL ALIAS CREATE ALIAS AND SET FIELD NAME RPI 1062
.*
         AENTRY FIND_QUAL_ALIAS
         :&CUR_SYM_IX SETA &SYM_FXT(&FIELD_IX)
         AIF (&CUR_SYM_IX EQ 0)   ARE THERE DUP SYMBOLS
             AEXIT AENTRY
         AEND
         AWHILE (&CUR_SYM_IX GT 0)  SEARCH DUP SYMBOLS FOR MATCH
               ACTR 4096
               :&QI SETA 2
               :&CUR_QIX SETA &SYM_QIX(&CUR_SYM_IX)
               :&QNAME_FOUND SETB 1
               AWHILE (&QNAME_FOUND AND &QI LE &QNAME_TOT)
                   ACALL FIND_QNAME
                   AIF (&QNAME_FOUND)
                       AIF (&QI EQ &QNAME_TOT)
                           :&FIELD_NAME SETC '&SYM_NAME(&CUR_SYM_IX)'
                           :&FIELD_IX   SETA &CUR_SYM_IX  RPI 1062
                           AEXIT AENTRY
                       AELSE
                           :&QI      SETA &QI+1  NEXT QNAME. NEXT LVL
                           :&CUR_QIX SETA &SYM_QIX(&CUR_QIX_TEST) 
                       AEND
                   AEND
               AEND 
               :&CUR_SYM_IX SETA &SYM_NXT(&CUR_SYM_IX)  NEXT DUP SYM 
         AEND
         MNOTE 8,'ZCGETFLD QUAL FIELD NOT FOUND - &FIELD_NAME'
         AEND
.*
.* FIND SYM LEVEL MATCHING QNAME(QI) STARTING AT SYM_NAME(CUR_QIX)
.* RETURN WITH QNAME_FOUND T/F
.*
         AENTRY FIND_QNAME
         :&CUR_QIX_TEST SETA &CUR_QIX
         AWHILE (&CUR_QIX_TEST GT 0) 
               AIF   ('&QNAME(&QI)' EQ '&SYM_NAME(&CUR_QIX_TEST)')
                     AEXIT AENTRY
               AELSEIF ('&QNAME(&QI)_OF_' EQ '&SYM_NAME(&CUR_QIX_TEST)'X
               (1,K'&QNAME(&QI)+4))  CHECK BASE OF QUALIFIED LEVEL 
                     AEXIT AENTRY
               AELSE
               AEND
               :&CUR_QIX_TEST SETA &SYM_QIX(&CUR_QIX_TEST)  NEXT LVL
         AEND
         :&QNAME_FOUND SETB 0  NOT FOUND, FORCE NEXT DUP SYM SEARCH
         AEND
.*
.* PARSE AND GENERATE CODE FOR FIELD WITH 1 OR MORE SUBSCRIPTS
.*
         AENTRY GEN_SUBSCRIPT
         :&TOT_SIX SETA &SYM_SIT(&FIELD_IX)
         :&PARM_IX SETA &PARM_IX+1    POS TO FIRST SUBSCRIPT/INDEX
         :&CUR_SYM_IX SETA &FIELD_IX  CUR SYM WITH OCCURS
         AIF   (&SYM_DUP(&CUR_SYM_IX) LE 1)
               ACALL GET_NEXT_OCCURS_SYM 
         AEND
         :&CUR_SIX SETA 0
         AWHILE (&PARM_IX LE N'&SYSLIST                                X
                 AND &CUR_SYM_IX GT 0                                  X
                 AND &CUR_SIX LE &TOT_SIX                              X
                 AND '&SYSLIST(&PARM_IX)' NE ''')''')
               :&CUR_SIX SETA &CUR_SIX+1
               :&SIX_NAME(&CUR_SIX) SETC '&SYSLIST(&PARM_IX)' NAME/LIT 
               :&SIX_OCCUR(&TOT_SIX-&CUR_SIX+1) SETA &CUR_SYM_IX 
               AIF ('&SYSLIST(&PARM_IX+1)' EQ '+'                      X
                    OR '&SYSLIST(&PARM_IX+1)' EQ '-')
                    :&SIX_OFF(&CUR_SIX) SETC '&SYSLIST(&PARM_IX+1)&SYSLX
               IST(&PARM_IX+2)'      
                    :&PARM_IX SETA &PARM_IX+2   
               AELSE
                    :&SIX_OFF(&CUR_SIX) SETC ''
               AEND
               :&PARM_IX SETA &PARM_IX+1
               ACALL GET_NEXT_OCCURS_SYM
         AEND
         AIF   (&CUR_SIX NE &TOT_SIX                                   X
               OR '&SYSLIST(&PARM_IX) NE ''')''')
               MNOTE 8,'ZCGETFLD SUBSCRIPT MISMATCH'
               MEXIT
         AEND
         :&PARM_IX SETA &PARM_IX+1
.*
.* GENERATE SUBSCRIPT CODE
.*
         GEN_SIX
         AEND
.*
.* GET NEXT OCCURS SYM
.*
       AENTRY GET_NEXT_OCCURS_SYM
       :&CUR_SYM_IX SETA &SYM_QIX(&CUR_SYM_IX)
       AWHILE (&CUR_SYM_IX GT 0)
          AIF (&SYM_DUP(&CUR_SYM_IX) GT 1)
              AEXIT AENTRY  EXIT WITH NEXT OCCURS CUR_SYM_IX
          AEND
          :&CUR_SYM_IX SETA &SYM_QIX(&CUR_SYM_IX)
       AEND
       AEND
.*
.* CALC RMOD OFF SET - CALC OFFSET AND LENGTH FROM (OFF:LEN)
.*
         AENTRY CALC_RMOD_OFF_LEN
         AIF   ('&SYSLIST(&PARM_IX+2)' EQ ':'                          X
               AND '&SYSLIST(&PARM_IX+4)' EQ ''')''')
               :&FIELD_OFF SETA &SYSLIST(&PARM_IX+1)-1
               :&FIELD_LEN SETA &SYSLIST(&PARM_IX+3)
               AIF (&FIELD_OFF+&FIELD_LEN GT &SYM_LEN(&FIELD_IX))
                   MNOTE 8,'ZCGETFLD RMOD OFF+LEN > FIELD LENGTH'
                   MEXIT
               AEND
               AIF (&FIELD_SS1)
                   AIF (&FIELD_SIX)
                       :&FIELD_NAME SETC '&FIELD_OFF.(&FIELD_LEN,&FIELDX
               _REG)'
                   AELSE
                       :&FIELD_NAME SETC '&FIELD_NAME+&FIELD_OFF.(&FIELX
               D_LEN)'
                   AEND
               AELSE
                   AIF (&FIELD_SIX)
                       :&FIELD_NAME SETC '&FIELD_OFF.(&FIELD_REG)'
                   AELSE
                       :&FIELD_NAME SETC '&FIELD_NAME+&FIELD_OFF'
                   AEND
               AEND
               :&PARM_IX SETA &PARM_IX+5
         AELSE
               MNOTE 8,'ZCGETFLD RMOD SYNTAX ERROR (LIT:LIT) ONLY'
               MEXIT
         AEND
         AEND
.*
.* END OF ZCGETFLD.CPY
.*
.*********************************************************************
.* Copyright 2009 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 08/16/09                                                 *
.*********************************************************************
.* 08/16/09 move SN/PG logic shared by GEN_B, GEN_BC, GEN_ALTER
.* 08/05/09 RPI 1065 add support for PG OF SN    
.*********************************************************************
.*
.* SET PG_LAB FROM PG_NAME AND SN_NAME
.*
       AENTRY  GET_PG_LAB
       AIF     ('&PG_NAME' EQ '')
               :&ZC_PG_LAB SETC 'SN_&SN_NAME'
               AEXIT AENTRY
       AEND
       GBLA    &(ZC_PG_&PG_NAME)
       AIF     (&(ZC_PG_&PG_NAME) GT 0) IS THIS PG DEFINED
               AIF     (&(ZC_PG_&PG_NAME) GT 1) IS IT DUPLICATED
                       AIF  ('&SN_NAME' NE '')  IS THERE EXPLICIT SN
                            :&ZC_PG_LAB SETC 'SN_&SN_NAME._PG_&PG_NAME'
                       AELSEIF ('&LAST_SN_NAME' NE '') ARE WE IN SN
                            :&ZC_PG_LAB SETC 'SN_&LAST_SN_NAME._PG_&PG_X
               NAME'
                       AELSE
                            MNOTE 8,'GEN_B NO SECTION FOR DUP PG - &PG_X
               NAME' 
                            MEXIT
                       AEND
               AELSE
                   :&ZC_PG_LAB SETC 'PG_&PG_NAME'
               AEND
       AELSEIF (&(ZC_PG_&PG_NAME) EQ -1)  IS THIS SECTION
               :&ZC_PG_LAB SETC 'SN_&PG_NAME'
       AELSE
               :&ZC_PG_LAB SETC 'PG_&PG_NAME'
       AEND
       AEND
.*
.* SCALE NUL LIT - REMOVE DECIMAL POINT AND SCALE FIXED NUMERIC LITERAL  
.*    &NUM     - SETC LITERAL VALUE WHICH IS SCALED
.*    &DEC_SYM - DECIMAL PLACES REQUIRED FROM SYM_PIC_DEC (SET BY WS)
.*
         AENTRY SCALE_NUM_LIT
         AIF (&ZC_DEC_IS_COMMA)
             :&DEC_IX SETA ('&NUM' FIND ',')
         AELSE
             :&DEC_IX SETA ('&NUM' FIND '.')
         AEND
         AIF (&DEC_IX GT 0)
               :&DEC_NUM SETA K'&NUM-&DEC_IX
               AIF (&DEC_IX GT 1)
                 AIF (&DEC_IX LT K'&NUM)
                   :&NUM SETC '&NUM'(1,&DEC_IX-1).'&NUM'(&DEC_IX+1,*)
                 AELSE
                   :&NUM SETC '&NUM'(1,&DEC_IX-1)
                 AEND
               AELSE
                   :&NUM SETC '&NUM'(2,*)
               AEND
         AELSE
               :&DEC_NUM SETA 0
         AEND
         AIF (&DEC_NUM EQ &DEC_SYM)
             AEXIT AENTRY
         AEND
         AIF (&DEC_NUM GT &DEC_SYM)
             :&LNUM SETA K'&NUM-(&DEC_NUM-&DEC_SYM)
             AIF (&LNUM GT 0)
                 :&NUM SETC '&NUM'(1,&LNUM)
             AELSE
                 :&NUM SETC '0'
             AEND
         AELSE 
             :&NUM SETC '&NUM'.(&DEC_SYM-&DEC_NUM)'0'
         AEND
         AEND
.********************************************************************
.* RESET LAB LEN - REMOVE SS1 LENGTH IF ANY FROM LAB 
.* USED BY ZC_CALC, GEN_ADD
.********************************************************************
.* 05/26/09 RPI 1019 INITIAL CODING SEE TESTSIX1 CALC TEST
.********************************************************************
         AENTRY RESET_LAB_LEN
         AIF   ('&LAB'(1,1) GE '0')  IS THIS O(L,R) 
               :&ILAB SETA ('&LAB' INDEX '(')
               AIF (&ILAB GT 1)
                   :&FIELD_OFF SETA '&LAB'(1,&ILAB-1)
                   :&JLAB SETA ('&LAB' INDEX ',')
                   AIF (&JLAB GT &ILAB+1)
                     :&FIELD_LEN SETA '&LAB'(&ILAB+1,&JLAB-1)
                     :&FIELD_REG SETC '&LAB'(&JLAB+1,K'&LAB-&JLAB-1)
                     :&LAB SETC '&LAB'(1,&ILAB).'&LAB'(&JLAB+1,*) O(R)
                   AEND
               AEND
         AELSEIF ('&LAB'(1,5) EQ 'ZCVT_') STRIP ZCVT_WORKAREA+N(LEN)
               :&ILAB SETA ('&LAB' INDEX '(')
               AIF (&ILAB GT 1)
                   :&LAB SETC '&LAB'(1,&ILAB-1)
               AEND
         AEND
         AEND
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/07/08                                                 *
.*********************************************************************
.* 06/14/09 RPI 1057 sync with AZ390 DFHRESP and DFHVALUE support
.* 09/02/09 RPI 1079 add DFHRESP(NOTALLOC)=F'61'     
.*********************************************************************
               GBLC &(DFHRESP_NORMAL) 
               GBLC &(DFHRESP_ERROR)
               GBLC &(DFHRESP_TERMIDERR)
               GBLC &(DFHRESP_FILENOTFOUND) 
               GBLC &(DFHRESP_DSIDERR)      
               GBLC &(DFHRESP_NOTFND)       
               GBLC &(DFHRESP_DUPREC)       
               GBLC &(DFHRESP_DUPKEY)       
               GBLC &(DFHRESP_INVREQ)
               GBLC &(DFHRESP_IOERR)
               GBLC &(DFHRESP_NOSPACE)      
               GBLC &(DFHRESP_NOTOPEN)      
               GBLC &(DFHRESP_ENDFILE)      
               GBLC &(DFHRESP_ILLOGIC)      
               GBLC &(DFHRESP_LENGERR)
               GBLC &(DFHRESP_ITEMERR)      
               GBLC &(DFHRESP_PGMIDERR)
               GBLC &(DFHRESP_TRANSIDERR)
               GBLC &(DFHRESP_ENDDATA) 
               GBLC &(DFHRESP_EXPIRED)      
               GBLC &(DFHRESP_MAPFAIL)      
               GBLC &(DFHRESP_INVMPSZ)      
               GBLC &(DFHRESP_OVERFLOW)     
               GBLC &(DFHRESP_QIDERR)       
               GBLC &(DFHRESP_ENQBUSY)      
               GBLC &(DFHRESP_ENVDEFERR)    
               GBLC &(DFHRESP_NOTALLOC)     RPI 1079 
               GBLC &(DFHRESP_SUPPRESSED)     
               GBLC &(DFHRESP_END)          
               GBLC &(DFHRESP_DISABLED)     
               :&(DFHRESP_NORMAL)       SETC   '0'  
               :&(DFHRESP_ERROR)        SETC   '1'  
               :&(DFHRESP_TERMIDERR)    SETC   '11' 
               :&(DFHRESP_FILENOTFOUND) SETC   '12' 
               :&(DFHRESP_DSIDERR)      SETC   '12' 
               :&(DFHRESP_NOTFND)       SETC   '13' 
               :&(DFHRESP_DUPREC)       SETC   '14' 
               :&(DFHRESP_DUPKEY)       SETC   '15' 
               :&(DFHRESP_INVREQ)       SETC   '16' 
               :&(DFHRESP_IOERR)        SETC   '17' 
               :&(DFHRESP_NOSPACE)      SETC   '18' 
               :&(DFHRESP_NOTOPEN)      SETC   '19' 
               :&(DFHRESP_ENDFILE)      SETC   '20' 
               :&(DFHRESP_ILLOGIC)      SETC   '21' 
               :&(DFHRESP_LENGERR)      SETC   '22' 
               :&(DFHRESP_ITEMERR)      SETC   '26' 
               :&(DFHRESP_PGMIDERR)     SETC   '27' 
               :&(DFHRESP_TRANSIDERR)   SETC   '28' 
               :&(DFHRESP_ENDDATA)      SETC   '29' 
               :&(DFHRESP_EXPIRED)      SETC   '31' 
               :&(DFHRESP_MAPFAIL)      SETC   '36' 
               :&(DFHRESP_INVMPSZ)      SETC   '38' 
               :&(DFHRESP_OVERFLOW)     SETC   '40' 
               :&(DFHRESP_QIDERR)       SETC   '44' 
               :&(DFHRESP_ENQBUSY)      SETC   '55' 
               :&(DFHRESP_ENVDEFERR)    SETC   '56' 
               :&(DFHRESP_NOTALLOC)     SETC   '61'   RPI 1079
               :&(DFHRESP_SUPPRESSED)   SETC   '72' 
               :&(DFHRESP_END)          SETC   '83' 
               :&(DFHRESP_DISABLED)     SETC   '84' 
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/07/08                                                 *
.*********************************************************************
.* 06/14/09 RPI 1057 sync with AZ390 DFHVALUE support
.*********************************************************************
               GBLC &(DFHVALUE_NOTAPPLIC) 
               GBLC &(DFHVALUE_VSAM) 
               GBLC &(DFHVALUE_ESDS) 
               GBLC &(DFHVALUE_KSDS) 
               GBLC &(DFHVALUE_RRDS) 
               GBLC &(DFHVALUE_BASE) 
               GBLC &(DFHVALUE_PATH) 
               GBLC &(DFHVALUE_FIXED) 
               GBLC &(DFHVALUE_VARIABLE) 
               GBLC &(DFHVALUE_OPEN) 
               GBLC &(DFHVALUE_CLOSED)
               GBLC &(DFHVALUE_ENABLED)
               GBLC &(DFHVALUE_DISABLED)
               GBLC &(DFHVALUE_UNENABLED)
               GBLC &(DFHVALUE_READABLE)
               GBLC &(DFHVALUE_NOTREADABLE)
               GBLC &(DFHVALUE_UPDATABLE)
               GBLC &(DFHVALUE_NOTUPDATABLE)
               GBLC &(DFHVALUE_BROWSABLE)
               GBLC &(DFHVALUE_NOTBROWSABLE)
               GBLC &(DFHVALUE_ADDABLE)   
               GBLC &(DFHVALUE_NOTADDABLE)
               GBLC &(DFHVALUE_DELETABLE)
               GBLC &(DFHVALUE_NOTDELETABLE)
               GBLC &(DFHVALUE_VRRDS)     
               :&(DFHVALUE_NOTAPPLIC)     SETC   '1'   
               :&(DFHVALUE_VSAM)          SETC   '2'   
               :&(DFHVALUE_ESDS)          SETC   '5'   
               :&(DFHVALUE_KSDS)          SETC   '6'   
               :&(DFHVALUE_RRDS)          SETC   '7'   
               :&(DFHVALUE_BASE)          SETC   '10'  
               :&(DFHVALUE_PATH)          SETC   '11'  
               :&(DFHVALUE_FIXED)         SETC   '12'  
               :&(DFHVALUE_VARIABLE)      SETC   '13'  
               :&(DFHVALUE_OPEN)          SETC   '18'  
               :&(DFHVALUE_CLOSED)        SETC   '19'  
               :&(DFHVALUE_ENABLED)       SETC   '23'  
               :&(DFHVALUE_DISABLED)      SETC   '24'  
               :&(DFHVALUE_UNENABLED)     SETC   '33'  
               :&(DFHVALUE_READABLE)      SETC   '35'  
               :&(DFHVALUE_NOTREADABLE)   SETC   '36'  
               :&(DFHVALUE_UPDATABLE)     SETC   '37'  
               :&(DFHVALUE_NOTUPDATABLE)  SETC   '38'  
               :&(DFHVALUE_BROWSABLE)     SETC   '39'  
               :&(DFHVALUE_CNOTBROWSABLE) SETC   '40'  
               :&(DFHVALUE_ADDABLE)       SETC   '41'  
               :&(DFHVALUE_NOTADDABLE)    SETC   '42'  
               :&(DFHVALUE_DELETABLE)     SETC   '43'  
               :&(DFHVALUE_NOTDELETABLE)  SETC   '44'  
               :&(DFHVALUE_VRRDS)         SETC   '732' 
.*********************************************************************
.* Copyright 2009 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 08/15/09                                                 *
.*********************************************************************
.* 08/15/09 RPI 106 global keywords to identifed as not vars or lits        
.*********************************************************************
         GBLB &ZCKW_EQUAL
         GBLB &ZCKW_GREATER
         GBLB &ZCKW_LESS
         GBLB &ZCKW_THAN
         GBLB &ZCKW_TO
&ZCKW_EQUAL   SETB 1
&ZCKW_GREATER SETB 1
&ZCKW_LESS    SETB 1
&ZCKW_THAN    SETB 1
&ZCKW_TO      SETB 1
.*********************************************************************
.* Copyright 2008 Automated Software Tools Corporation               *
.* This source code is part of z390 zCOBOL/assembler/emulator package*
.* The z390 package is distributed under GNU general public license  *
.* Author - Don Higgins                                              *
.* Date   - 04/07/08                                                 *
.*********************************************************************
.* 04/08/08 initial coding to define global WS variables 
.* 04/30/08 add 88 definitions for use in literal compares/moves etc.
.* 06/10/08 add LINKAGE SECTION support                                   
.* 07/26/08 add zcob_sym_find hash table                                  
.* 11/26/08 add IE_TYPE 4 FOR PERFORM n TIMES stmt, UNTIL stmt       
.* 12/21/08 add SYM_FILLER_VAL_CNT for use by GEN_INIT_WS          
.* 12/22/08 add SYM_SUB_CNT for use by ZCGETFLD.CPY subscript parser          
.* 02/05/09 add TOT_SIX and SIX_NAME,SIX_OFF,SIX_OCCURS for subscripts
.* 02/08/09 add FIELD_RMD to indicate (off:len) reference modification 
.* 02/23/09 RPI 1001 add &FIELD_88_IX set by ZCGETFLD.CPY
.* 02/25/09 RPI 1004 add &ZC_FLOAT SET TO DEFUALT DFP           
.* 02/26/09 RPI 1012 add &SYM_VAL_ALL FLAG           
.* 03/10/09 RPI 1013 add &ZC_FLOAT_SHORT/LONG/EXTENDED_TYPE
.* 04/24/09 RPI 1003 add &TMP_NAME/TYPE/LEN/SIGN for ZC_CALC,GEN_???
.* 07/09/09 RPI 1065 move &FILE_IX from SYM_REF to SYM_FD 
.* 07/17/09 RPI 1065 add &QNAME(50) &QNAME_LEN &QNAME_TOT 
.*          for ZC_GET_QNAME used by ZCGETFLD and ZC_SYM_INDEX  
.* 08/03/09 RPI 1065 add &ZC_DEC_IS_COMMA special name support
.* 08/04/09 RPI 1065 support qualified paragraph names SN_NAME/PG_NAME             
.* 08/09/09 RPI 1065 add ZC_ERROR to skip GEN_BC after GEN_COMP error      
.* 08/09/09 RPI 1065 use FXT for head of dup sym, NXT for next dup.     
.* 08/18/09 RPI 1065 add SYM_OPT for options R=JUST,                    
.* 09/08/09 RPI 1065 replace SYM_DEP_IX with SYM_DEPEND name                    
.* 09/09/09 RPI 1065 replace FILE_TYPE with FILE_ORG,FILE_MODE,FILE_KEY                    
.*********************************************************************
.*
.* PGM NAME AND ZCOBOL VERSION CHECKED BY ZC390NUC IN ZC390LIB.390
.*
         GBLC  &ZC_PGM       NAME FROM FIRST CMD PARM (IGNORE PGM-ID)
         GBLC  &ZC_VER       CURRENT Z390 VERSION FROM TZ390.VER
         GBLC  &ZC_CDATE     COMPILE DATE OR MM/DD/YY IF NOTIMING
         GBLC  &ZC_CTIME     COMPILE START TIME IF TIMING ELSE ''
         GBLC  &ZC_LIST      LISTING OPTION FOR INTERNAL CODE GEN
         GBLC  &ZC_OPTIONS   ALL OPTIONS FOLLOWING PGM NAME        
.*
.* ZCOBOL OPTIONS
.*
         GBLB  &ZC_PROC_DIV  SET AT START OF PROCEDURE DIVISION
         GBLB  &ZC_CICS      CICS COBOL PROGRAM WITH DFHEISTG WS CSECT
         GBLB  &ZC_CICS_DSA_VALUE IGNORE VALUES AND ISSUE 1 WARNING
         GBLB  &ZC_COMMENT   LIST SOURCE AS COMMENTS IN MLC FOR PRN
         GBLC  &ZC_LIST      LIST OPTION FOR ZCOBOL INTERNAL CODE GEN
         GBLB  &ZC_EXTEND    COMP S9(39) TYPE G, COMP-3 S9(31) TYPE P
         GBLB  &ZC_R64       USE 64 BIT REGS FOR G TYPE S9(18) DSG ETC.  
         GBLB  &ZC_TRACE     DISPLAY PARAGRAPH LABEL TRACE DURING EXEC
         GBLB  &ZC_TRUNC     TRUNCATE NUM DATA TO PIC SIZE (NOT YET)
         GBLB  &ZC_WARN      GENERATE WARNING LEVEL 4 M NOTES
         GBLC  &ZC_FLOAT     FLOATING POINT TYPE (DECIMAL,HEX,BINARY)
         GBLC  &ZC_FLOAT_SHORT_TYPE    1/4/7 SET FROM FLOAT(???)
         GBLC  &ZC_FLOAT_LONG_TYPE     2/5/8 SET FROM FLOAT(???)
         GBLC  &ZC_FLOAT_EXTENDED_TYPE 3/7/9 SET FROM FLOAT(???)
         GBLB  &ZC_DEC_IS_COMMA        SPEC NAMES OPTION
         GBLB  &ZC_ERROR               FLAG TO INDICATE STMT ERROR
.*
.* GLOBAL LIMITS
.*
&MAX_PM     SETA 20    MAXIMUM NESTED PERFORMS (CAN BE SET HIGHER)
&MAX_IE     SETA 100   MAXIMUM NEXTED IF, EVALUATE, READ END-READ
&MAX_WS_LVL SETA 50 MAXIMUM WS LEVELS          
&MAX_SYM    SETA 20000 MAXIMUM WS SYMBOLS 
&MAX_FILE   SETA  100
.*
.* FILE TABLE DEFINED FROM SELECT AND FD STATEMENTS
.*
         GBLA  &FILE_TOT               TOTAL FILES DEFINED
         GBLA  &FILE_IX                FILE INDEX ELSE 0 FOR NOT FOUND
         GBLC  &FILE_NAME(&MAX_FILE)   FILE NAME FROM SELECT
         GBLC  &FILE_ORG(&MAX_FILE)    FILE TYPE (QSAM,LSEQ,KSDS,RRDS)
         GBLC  &FILE_MODE(&MAX_FILE)   FILE MODE (SEQ,RAN,DYN)         
         GBLC  &FILE_KEY(&MAX_FILE)    FILE INDEXED RECORD KEY FIELD          
         GBLC  &FILE_XRBA(&MAX_FILE)   FILE RELATIVE XRBA FIELD
         GBLC  &FILE_DDNAME(&MAX_FILE) FILE DDNAME OR DSN IN QUOTES
         GBLC  &FILE_RECORD(&MAX_FILE) FILE RECORD FOR READ
         GBLC  &FILE_STATUS(&MAX_FILE) FILE STATUS FIELD NAME
         GBLC  &FILE_BLKSI1(&MAX_FILE) MIN BLOCK SIZE (DEF CHAR)
         GBLC  &FILE_BLKSI2(&MAX_FILE) MAX BLOCK SIZE (DEF CHAR)
         GBLB  &FILE_BLKSI_RCDS(&MAX_FILE) MIN/MAX BLKSI IN RECORDS 
         GBLC  &FILE_LRECL1(&MAX_FILE) MIN REC SIZE (DEF CHAR)
         GBLC  &FILE_LRECL2(&MAX_FILE) MAX REC SIZE (DEF CHAR)
         GBLC  &FILE_DEPENDING(&MAX_FILE) VAR LRECL FLD FOR FILE 
.*
.* WS BASE REGISTERS (GEN_ID sys init, GEN_BASE dynamic,PERIOD reset)
.*
.*   1.  Cnrrent preset WS base regs  = R7
.*   2.  Currnet dynamic WS base regs = R6 and R5
.*
         GBLC &BASE_WS
&BASE_SYS SETC 'ZC_R13'           FIRST WS SYSTEM BASE
         GBLA &BASE_WS_HIGH
&BASE_WS_HIGH SETA 4096-16        MAX WS SYSTEM BASE OFFSET RPI 1065
         GBLC &BASE_B1,&BASE_B2
         GBLB &BASE_B1_USED,&BASE_B2_USED  FOR DROP AT PERIOD
&BASE_B1 SETC 'ZC_R6'                FIRST  DYNAMIC WS BASE REG
&BASE_B2 SETC 'ZC_R7'                SECOND DYNAMIC WS BASE REG
         GBLA &BASE_B1_LOW,&BASE_B1_HIGH          
         GBLA &BASE_B2_LOW,&BASE_B2_HIGH          
         GBLA &BASE_LRU           LEAST RECENTLY USED WS DYNAMIC BASE
.*
.* LK BASE REGISTERS (GEN_BASE for dynamic,PERIOD for reset)
.*
.*   1.  Currnet dynamic WS base regs = R4 and R5
.*
         GBLC &LBASE_B1,&LBASE_B2
         GBLB &LBASE_B1_USED,&LBASE_B2_USED FOR DROP AT PERIOD
&LBASE_B1 SETC 'ZC_R4'               FIRST  DYNAMIC LK BASE REG
&LBASE_B2 SETC 'ZC_R5'               SECOND DYNAMIC LK BASE REG
         GBLA &LBASE_B1_LOW,&LBASE_B1_HIGH LOW HIGH BASE OFFSETS
         GBLA &LBASE_B2_LOW,&LBASE_B2_HIGH LOW HIGH BASE OFFSETS
         GBLA &LBASE_B1_IX        SYM IX OF BASE VAR IN WS
         GBLA &LBASE_B2_IX        SYM IX OF BASE VAR IN WS
         GBLA &LBASE_LRU          LEAST RECENTLY USED LK DYNAMIC BASE
.*
.* GET PARM FIELD (ZCGETFLD.CPY) TO GET QUAL. SUBSC. FIELD NAME/ADDR
.*  
         GBLA  &PARM_IX                INPUT/UPDATE PARM INDEX
         GBLC  &FIELD_REG              INPUT REG FOR SUBSC/RMOD FLD ADR
         GBLB  &FIELD_SS1              INPUT SS1 FIELD OFF(LEN,REG) 
         GBLB  &FIELD_SIX              OUTPUT REG USED FOR SUB/IDX/RMOD 
         GBLB  &FIELD_RMD              OUTPUT REF MODS (OFF:LEN)
         GBLA  &FIELD_IX               OUTPUT SYM_IX OF FIELD
         GBLA  &FIELD_88_IX            OUTPUT SYM_IX OF 88 FIELD           
         GBLC  &FIELD_NAME             OUTPUT SOURCE/TARGET NAME
.*                                       SS1 AND     SIX > O(L,R)
.*                                       SS1 AND NOT SIX > N+O(L)
.*                                       NOT SS1 AND SIX > O(R)
.*                                       NOT SS1 NOT SIX > N+O
         GBLA  &FIELD_OFF              OUTPUT OFF IF RMOD ELSE 0
         GBLA  &FIELD_LEN              OUTPUT LEN IF RMOD ELSE 0
.*
.*
.* SYMBOL TABLE 
.*
         GBLA  &SYM_TOT                TOT FD AND WS SYMBOLS
         GBLA  &SYM_IX                 SYM INDEX IF FOUND ELSE 0
         GBLC  &SYM_RX                 SYM BDDD SET BY GEN_SYM_RX
         GBLA  &SYM_IX_LST             SYM LAST WS TYPE 1 SYM INDEX
         GBLA  &SYM_DUP_TOT            SYM TOTAL DUPLICATES 
         GBLA  &SYM_DUP_MAX            SYM MAX DUPLICATE CHAIN LENGTH 
         GBLA  &SYM_CUR_DUP            SYM CURRENT DUP CHAIN COUNT
         GBLA  &SYM_FILLER_VAL_CNT     FILLER WITH VALUE CNT IF CICS
         GBLA  &PIC_DIGITS             DIGITS IN PIC BY ZC_PIC_DIGITS
         GBLC  &SYM_NAME(&MAX_SYM)     SYM NAME
         GBLA  &SYM_FXT(&MAX_SYM)      SYM NAME FIRST DUPLICATE SYM_IX
         GBLA  &SYM_NXT(&MAX_SYM)      SYM NAME DUPLICATE NEXT SYM_IX
         GBLA  &SYM_LK(&MAX_SYM)       LINKAGE SECTION SYM_IX OF 01 LVL
         GBLA  &SYM_QIX(&MAX_SYM)  SYM QUALIFIER INDEX TO NEXT LVL NAME
         GBLA  &SYM_SIT(&MAX_SYM)  SYM SUBSCRIPT/INDEX TOTAL REQ'D
         GBLA  &SYM_LVL(&MAX_SYM)  SYM LEVEL 
         GBLA  &SYM_REF(&MAX_SYM)  SYM REF INDEX (88 SYM,RDEF,OR VAR)
         GBLA  &SYM_FD(&MAX_SYM)   SYM FD INDEX OR ZERO
         GBLA  &SYM_LOC(&MAX_SYM)  SYM WS OFFSET OR 88 VAL INDEX
         GBLA  &SYM_LEN(&MAX_SYM)  SYM LENGTH 
         GBLA  &SYM_DUP(&MAX_SYM)  SYM OCCURS N TIMES (MAX FOR DEPEND)                 
         GBLA  &SYM_DUP_MIN(&MAX_SYM)  SYM MIN OCCURS DEPENDING            
         GBLC  &SYM_DEPEND(&MAX_SYM)   SYM NAME FOR DEPENDING ON           
         GBLC  &SYM_VAL(&MAX_SYM)  SYM VALUE (0,SPACE,'...') T=1,2
         GBLB  &SYM_VAL_ALL(&MAX_SYM)  SYM VALUE ALL FLAG
         GBLC  &SYM_PIC(&MAX_SYM)  SYM PIC (999,X(3) ETC.)
         GBLC  &SYM_PIC_TYPE(&MAX_SYM)  SYM PIC TYPE A,D,E,F,H,P,X,Z
         GBLB  &SYM_PIC_SIGN(&MAX_SYM)  SYM PIC (S9...)
         GBLA  &SYM_PIC_DEC(&MAX_SYM)   SYM DECIMAL PLACES (999V99)
         GBLC  &SYM_OPT(&MAX_SYM)       SYM OPTIONS
.*               B = BLANK WHEN ZERO
.*               E = EXTERNAL
.*               G = GLOBAL
.*               L = LEADING       
.*               R = JUST/JUSTIFY RIGHT
.*               S = SYNC/SYNCHRONIZE (ALIGN TO OPTIMUM BOUNDARY)
.*
.* SECTION AND PARAGRAPH NAMES
.*
         GBLA &SN_TOT              TOTAL SECTIONS (SEE LABEL MACRO)
         GBLA &PG_TOT              TOTAL PARAGRAPH NAMES 
         GBLA &PG_DUP_TOT          TOTAL DUPLICATE PARAGRAH NAMES
.*
.* QNAME - QUALIFIED NAME LEVELS
.*
         GBLC &QNAME(50)           QUALIFEID BASE AND LEVEL NAMES
         GBLA &QNAME_LEN           TOT LEN OF QUAL NAME A_OF_B_OF_C ETC
         GBLA &QNAME_TOT           TOT NUMBER OF LEVELS INC 1=BASE NAME
.*
.* SYM 88 VALUES - SYM_LOC POINTS TO STARTING VALUE IF MORE THAN 1
.*
         GBLA &V88_TOT            TOTAL 88 LEVEL VALUES
         GBLC &V88_VAL(&MAX_SYM)  88 VALUE
         GBLA &V88_NEXT(&MAX_SYM) INDEX OF NEXT VALUE OR 0
         GBLC &V88(&MAX_SYM)
.*
.* SET POINTERS FOR ALL SYMBOLS WITH OCCURS
.*
         GBLA &CUR_SET_LVL    CURRENT SUBSCRIPT LEVEL RESET TO 1 AT 01
         GBLA &SET_TOT  TOTAL OCCURS AND SET POINTERS TO GENERATED
         GBLA &SET_SYM_IX(&MAX_SYM) INDEX TO SYM WITH OCCURS
         GBLA &SET_SYM_LVL(&MAX_SYM) SUBSCRIPT LEVEL 1-N 
         GBLC &SET_INDEX(&MAX_SYM)  INDEX BY ALIAS NAME IF ANY
.*
.* LK LINKAGE SECTION - SEE &SYM_LK AND SYM_REF FOR DSECT ALSO 
.*
         GBLB &LK_MODE            SET LK MODE ON AT LINKAGE SECTION
         GBLA &LK_SAVE_WS_LOC     SAVE LAST WS_LOC RESTORED AT DATA END
         GBLA &LAST_LK_DSECT_IX   SAVE IX OF LAST 01 DSECT IN LK SECT
         GBLA &LK_TOT             TOTAL LK 01 LEVEL DSECTS
.*
.* IF/ELSE, EVALUATE, READ, AND PERFORM - NESTED COMPARE/BRANCH DATA
.*
         GBLA &IF_CNT               UNIQUE IF COUNTER
         GBLA &MAX_IOP_TF           MAX IF_IOP_TF FIELDS REQUIRED
         GBLB &PERIOD_NEXT          REQ LABEL FOR NEXT SENTENCE AT .
         GBLA &PERIOD_NEXT_LAB      UNIQUE NEXT SENENCE LABEL COUNTER
         GBLA &EVAL_LAB             UNIQUE EVALUTE LABEL COUNTER
         GBLA &AT_END_LAB           UNIQUE READ AT END LABEL COUNTER
         GBLA &PM_LAB               UNIQUE PERFORM LABEL COUNTER
         GBLA &ADD_LAB               UNIQUE ADD      LABEL COUNTER
         GBLA &SUB_LAB               UNIQUE SUBTRACT LABEL COUNTER
         GBLA &MPY_LAB               UNIQUE MULTIPLY LABEL COUNTER
         GBLA &DIV_LAB               UNIQUE DIVIDE   LABEL COUNTER
         GBLC &LAST_PG_NAME         LAST PROC DIV PARAGRAPH NAME   
         GBLC &LAST_SN_NAME         LAST PROC DIV SECTION NAME  
         GBLA &IE_LVL               CURRENT LEVEL FOR IF OR EVALUATE
         GBLA &IE_TYPE(&MAX_IE)     1=IF, 2=EVALUATE, 3=END_READ 4=PM
.*                                  11=ADD,12=SUB,13=MPY,14=DIV
         GBLA &IE_TCNT(&MAX_IE)     IE TYPE  COUNT                  
         GBLA &IE_BCNT(&MAX_IE)     IE BLOCK COUNT WITHIN TYPE     
         GBLB &IE_ELSE(&MAX_IE)     CURRENT IF OR ELSE BLOCK FLAG
         GBLA &IE_EVAL(&MAX_IE)     CURRENT EVAL LABEL #
         GBLA &IE_EVAL_IX(&MAX_IE)  CURRENT EVAL SYM INDEX       
         GBLA &IE_WHEN(&MAX_IE)     CURRENT EVAL WHEN LABEL #
         GBLC &IE_PM_LAB(&MAX_IE)   CURRENT PM STMT LOOP LABEL
.*
.* GO TO DEPENDING ON LABEL 
.*
         GBLA &ZC_GO_DEP            COUNT OF GO TO DEPENDING ON  TABLES
.*
.* CURRENT WS LOC, LEVEL, AND PENDING LENGTH SYMBOL PTRS
.*
         GBLA  &WS_LOC            CURRENT WS LOC OFFSET (SEE GEN_ID)
         GBLA  &ZC_DCB_LEN        LENGTH OF DCB GEN'D BY GEN_FD IN WS
&ZC_DCB_LEN SETA X'68'
         GBLA  &WS_LVL            CURRENT WS INDENT LEVEL
         GBLA  &WS_LVL_NO(&MAX_WS_LVL)       CUR LV # 01-49 (77=01)
         GBLA  &WS_LVL_SYM_IX(&MAX_WS_LVL)   CUR WS ITEM SYMBOL INDEX
         GBLC  &WS_LVL_USE(&MAX_WS_LVL)      CUR WS LEVEL USAGE 
         GBLB  &WS_LVL_RDEF(&MAX_WS_LVL)     CUR WS ITEM IS  REDEFINE
         GBLA  &WS_LVL_RDEF_END(&MAX_WS_LVL) CUR WS ITEM RDEF END LOC
         GBLA  &WS_LVL_RDEF_IX(&MAX_WS_LVL)  CUR WS ITEM RDEF SYM IX
.*
.* VAR - GENERATED WS 77 ITEMS FOR USE BY GENERATED CODE
.*
         GBLA  &VAR_TOT     TOTAL VARS NAMED ZC_VAR_&VAR_TOT
.*
.* SIX SUBSCRIPT DATA PASSED BETWEEN ZCGETFLD AND GEN_SIX
.*
         GBLA &TOT_SIX       TOTAL SUBSCRIPTS
         GBLC &SIX_NAME(10)  SUBSCRIPT/INDEX/LIT FROM FIELD(PARMS)
         GBLC &SIX_OFF(10)   SUBSCRIPT OFFSETS +/-NUM ELSE ''
         GBLA &SIX_OCCUR(10) OCCURS SYM_IX (TO GET LENGTH, ETC.)
.*
.* TMP variables for ZC_CALC, GEN_ADD, GEN_SUB, GEN_MPY, GEN_DIV
.* wheb target index is negative (used to store and fetch temp values)
.*
         GBLC &TMP_NAME(100) - NAME -  ZCVT_WORKAREA+16*(IX-1)
         GBLC &TMP_TYPE(100) - TYPE OF TEMP VALUE '1-9FGHPQ'
         GBLA &TMP_LEN(100)  - LENGTH OF TEMP VALUE FOR P
         GBLB &TMP_SIGN(100) - SIGNED OR UNSIGNED P OR Z FIELD
.*
.* END OF CBL_WS.CPY
.*
